{"version":3,"file":"js/spectre.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxVA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAUA;AACA;AATA;AAEA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAaA;AACA;AAZA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;AC3GA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAYA;AACA;AAXA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACjMA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AA0EA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAIA;AAIA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpzBA;AAEA;AAYA;AACA;AACA;AAEA;AAdA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAYA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxHA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AAQA;AAPA;AACA;AACA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAKA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAKA;AAKA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClNA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClEA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAqCA;AAnCA;AAOA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAKA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAjfA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3BA;AAGA;AAEA;AAGA;AAcA;AAVA;AACA;AAIA;AAEA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9NA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAWA;AACA;AANA;AAOA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClGA;AAEA;AAKA;AACA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AA1BA;AAEA;AA2BA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;;AAfA;AAkBA;AAGA;AACA;AACA;AACA;AACA;;AANA;;;;;;;;;;;;;;;;;;;;;AC3DA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAYA;AACA;AAXA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1NA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AAEA;AAQA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAMA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5GA;AAKA;AAFA;AAEA;AAIA;AAEA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AAEA;AAQA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAYA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxJA;AACA;AACA;AAEA;AAMA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AAEA;AASA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACnHA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAOA;AACA;AANA;AACA;AACA;AACA;AAKA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC9DA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;ACjCA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AAGA;AAoBA;AAlBA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvEA;AACA;AAGA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;AClOA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AAEA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;ACrEA;AAEA;AAQA;AANA;AACA;AACA;AACA;AACA;AAGA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClDA;AAYA;AACA;AACA;AAbA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;ACtGA;AACA;AACA;AAGA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;ACpCA;AAEA;AACA;AAGA;AACA;AACA;AAGA;AAiBA;AAfA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtOA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AALA;AACA;AACA;AAKA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7CA;AAEA;AAMA;AAIA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;AC9bA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AAMA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAMA;AAEA;AAGA;AAEA;AAEA;AAMA;AAEA;AAEA;AACA;AACA;AAEA;AAIA;AAEA;AAEA;AAMA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAMA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAIA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AArdA;AAwdA;AAEA;;;;;;;;;;;;;;;;;;;;;ACzoBA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxGA;AACA;AACA;AAGA;AACA;AAEA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AApCA;AACA;AACA;AACA;AAEA;AAgCA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AAGA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAlOA;AAqOA;;;;;;;;;;;;;;;;;;AC3OA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AAQA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAIA;AAIA;AAIA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;ACpeA;AAEA;AADA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAGA;AAIA;AAGA;AAGA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAUA;AACA;AAEA;AACA;AAeA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAYA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;;;;;;;;;;;;;;;;ACtUA;AAEA;AAGA;AAFA;AAoBA;AACA;AACA;AACA;AAEA;AAkBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAGA;AAEA;AAEA;AAGA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AAIA;AAIA;AAKA;AAIA;AAIA;AAIA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAIA;AAIA;AAIA;AAKA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAmBA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAGA;AAmBA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAIA;AAGA;AAGA;AAGA;AAIA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9+BA;AAGA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7JA;AAIA;AAQA;AAPA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AASA;AAEA;AAKA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAKA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAYA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AAKA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AAKA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;ACxkBA;AAGA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvLA;;;;;AAKA;AAEA;AAGA;AAIA;AAHA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnEA;AAGA;AAIA;AAHA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;ACrXA;AAGA;AAGA;AAKA;AAJA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AAKA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAIA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;;;;AC9lBA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjhBA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChBA;AACA;AAEA;AAGA;AAeA;AAoBA;AAhBA;AAEA;AAIA;AAEA;AACA;AACA;AAIA;AAGA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAMA;AAAA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvQA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;;;;;;AAMA;;;;;;AAMA;;;AAGA;AACA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;;;AAGA;;;;AAQA;AACA;AACA;;;;;;;;;;;;;;;;;ACnEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;AAMA;AACA;AACA;;;;;;AAMA;AACA;;;AAGA;AACA;;;;;;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;;;;;;;;;;;;;;;;;;;;;;AAuBA;AACA;AACA;;;;;;;;;;;;;;;AC/OA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC5BA;AAMA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;;;AAGA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjDA;AAEA;AAKA;AAJA;AAGA;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAsDA;AAjDA;AAEA;AAMA;AAgBA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAIA;AAEA;AACA;AAEA;AAmBA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AASA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;;AArOA;AACA;AACA;AAsOA;;;;;;;;;;;;;;;;;ACvQA;AACA;AAGA;AAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAzMA;;;;;;;;;;;;;;;;;;;;AAoBA;AACA;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtBA;AACA;AAEA;AAEA;AACA;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA","sources":["webpack://spectrejs/./src/Constants.ts","webpack://spectrejs/./src/cameras/Camera.ts","webpack://spectrejs/./src/cameras/OrthographicCamera.ts","webpack://spectrejs/./src/cameras/PerspectiveCamera.ts","webpack://spectrejs/./src/controls/OrbitControls.ts","webpack://spectrejs/./src/core/BufferAttribute.ts","webpack://spectrejs/./src/core/BufferGeometry.ts","webpack://spectrejs/./src/core/Defines.ts","webpack://spectrejs/./src/core/GPUBufferWrapper.ts","webpack://spectrejs/./src/core/Object3D.ts","webpack://spectrejs/./src/core/Pipeline.ts","webpack://spectrejs/./src/core/RenderableObject.ts","webpack://spectrejs/./src/core/ResourceManagers.ts","webpack://spectrejs/./src/core/Scene.ts","webpack://spectrejs/./src/core/binds/BindBuffer.ts","webpack://spectrejs/./src/core/binds/BindSampler.ts","webpack://spectrejs/./src/core/binds/BindTexture.ts","webpack://spectrejs/./src/core/binds/BindValue.ts","webpack://spectrejs/./src/geometries/BoxGeometry.ts","webpack://spectrejs/./src/geometries/PlaneGeometry.ts","webpack://spectrejs/./src/geometries/SphereGeometry.ts","webpack://spectrejs/./src/lights/DirectionalLight.ts","webpack://spectrejs/./src/lights/DirectionalLightShadow.ts","webpack://spectrejs/./src/lights/Light.ts","webpack://spectrejs/./src/lights/LightShadow.ts","webpack://spectrejs/./src/loaders/FileLoader.ts","webpack://spectrejs/./src/loaders/ImageLoader.ts","webpack://spectrejs/./src/loaders/Loader.ts","webpack://spectrejs/./src/loaders/LoadingManager.ts","webpack://spectrejs/./src/loaders/TextureLoader.ts","webpack://spectrejs/./src/materials/Material.ts","webpack://spectrejs/./src/materials/MeshBasicMaterial.ts","webpack://spectrejs/./src/materials/MeshPhongMaterial.ts","webpack://spectrejs/./src/math/Box3.ts","webpack://spectrejs/./src/math/Color.ts","webpack://spectrejs/./src/math/ColorManagement.ts","webpack://spectrejs/./src/math/Euler.ts","webpack://spectrejs/./src/math/Frustum.ts","webpack://spectrejs/./src/math/MathUtils.ts","webpack://spectrejs/./src/math/Matrix3.ts","webpack://spectrejs/./src/math/Matrix4.ts","webpack://spectrejs/./src/math/Plane.ts","webpack://spectrejs/./src/math/Quaternion.ts","webpack://spectrejs/./src/math/Sphere.ts","webpack://spectrejs/./src/math/Spherical.ts","webpack://spectrejs/./src/math/Vector2.ts","webpack://spectrejs/./src/math/Vector3.ts","webpack://spectrejs/./src/math/Vector4.ts","webpack://spectrejs/./src/objects/Mesh.ts","webpack://spectrejs/./src/renderers/WebGPURenderer.ts","webpack://spectrejs/./src/shaders/MeshBasicShader.ts","webpack://spectrejs/./src/shaders/MeshPhongShader.ts","webpack://spectrejs/./src/shaders/Shader.ts","webpack://spectrejs/./src/shaders/ShaderBasic.ts","webpack://spectrejs/./src/textures/Source.ts","webpack://spectrejs/./src/textures/Texture.ts","webpack://spectrejs/./src/textures/TextureMipmapGenerator.ts","webpack://spectrejs/./src/utils/CommonUtils.ts","webpack://spectrejs/./src/utils/TempValues.ts","webpack://spectrejs/webpack/bootstrap","webpack://spectrejs/webpack/runtime/define property getters","webpack://spectrejs/webpack/runtime/hasOwnProperty shorthand","webpack://spectrejs/webpack/runtime/make namespace object","webpack://spectrejs/./src/spectre.ts"],"sourcesContent":["/* eslint-disable no-unused-vars */\nexport type NumberArrayType = Float32Array | Int32Array | Int8Array | Uint32Array | Uint16Array | Uint8Array;\n\nexport const GPUPrimitiveTopology = {\n    PointList: \"point-list\" as GPUPrimitiveTopology,\n    LineList: \"line-list\" as GPUPrimitiveTopology,\n    LineStrip: \"line-strip\" as GPUPrimitiveTopology,\n    TriangleList: \"triangle-list\" as GPUPrimitiveTopology,\n    TriangleStrip: \"triangle-strip\" as GPUPrimitiveTopology,\n};\n\nexport const GPUCompareFunction = {\n    Never: \"never\" as GPUCompareFunction,\n    Less: \"less\" as GPUCompareFunction,\n    Equal: \"equal\" as GPUCompareFunction,\n    LessEqual: \"less-equal\" as GPUCompareFunction,\n    Greater: \"greater\" as GPUCompareFunction,\n    NotEqual: \"not-equal\" as GPUCompareFunction,\n    GreaterEqual: \"greater-equal\" as GPUCompareFunction,\n    Always: \"always\" as GPUCompareFunction,\n};\n\nexport const GPUStoreOp = {\n    Store: \"store\",\n    Discard: \"discard\",\n};\n\nexport const GPULoadOp = {\n    Load: \"load\",\n    Clear: \"clear\",\n};\n\nexport const GPUFrontFace = {\n    CCW: \"ccw\",\n    CW: \"cw\",\n};\n\nexport const GPUCullMode = {\n    None: \"none\" as GPUCullMode,\n    Front: \"front\" as GPUCullMode,\n    Back: \"back\" as GPUCullMode,\n};\n\nexport const GPUIndexFormat = {\n    Uint16: \"uint16\" as GPUIndexFormat,\n    Uint32: \"uint32\" as GPUIndexFormat,\n};\n\nexport const GPUVertexFormat = {\n    Uint8x2: \"uint8x2\" as GPUVertexFormat,\n    Uint8x4: \"uint8x4\" as GPUVertexFormat,\n    Sint8x2: \"sint8x2\" as GPUVertexFormat,\n    Sint8x4: \"sint8x4\" as GPUVertexFormat,\n    Unorm8x2: \"unorm8x2\" as GPUVertexFormat,\n    Unorm8x4: \"unorm8x4\" as GPUVertexFormat,\n    Snorm8x2: \"snorm8x2\" as GPUVertexFormat,\n    Snorm8x4: \"snorm8x4\" as GPUVertexFormat,\n    Uint16x2: \"uint16x2\" as GPUVertexFormat,\n    Uint16x4: \"uint16x4\" as GPUVertexFormat,\n    Sint16x2: \"sint16x2\" as GPUVertexFormat,\n    Sint16x4: \"sint16x4\" as GPUVertexFormat,\n    Unorm16x2: \"unorm16x2\" as GPUVertexFormat,\n    Unorm16x4: \"unorm16x4\" as GPUVertexFormat,\n    Snorm16x2: \"snorm16x2\" as GPUVertexFormat,\n    Snorm16x4: \"snorm16x4\" as GPUVertexFormat,\n    Float16x2: \"float16x2\" as GPUVertexFormat,\n    Float16x4: \"float16x4\" as GPUVertexFormat,\n    Float32: \"float32\" as GPUVertexFormat,\n    Float32x2: \"float32x2\" as GPUVertexFormat,\n    Float32x3: \"float32x3\" as GPUVertexFormat,\n    Float32x4: \"float32x4\" as GPUVertexFormat,\n    Uint32: \"uint32\" as GPUVertexFormat,\n    Uint32x2: \"uint32x2\" as GPUVertexFormat,\n    Uint32x3: \"uint32x3\" as GPUVertexFormat,\n    Uint32x4: \"uint32x4\" as GPUVertexFormat,\n    Sint32: \"sint32\" as GPUVertexFormat,\n    Sint32x2: \"sint32x2\" as GPUVertexFormat,\n    Sint32x3: \"sint32x3\" as GPUVertexFormat,\n    Sint32x4: \"sint32x4\" as GPUVertexFormat,\n};\n\nexport const GPUTextureFormat = {\n    // 8-bit formats\n\n    R8Unorm: \"r8unorm\" as GPUTextureFormat,\n    R8Snorm: \"r8snorm\",\n    R8Uint: \"r8uint\",\n    R8Sint: \"r8sint\",\n\n    // 16-bit formats\n\n    R16Uint: \"r16uint\" as GPUTextureFormat,\n    R16Sint: \"r16sint\" as GPUTextureFormat,\n    R16Float: \"r16float\" as GPUTextureFormat,\n    RG8Unorm: \"rg8unorm\" as GPUTextureFormat,\n    RG8Snorm: \"rg8snorm\" as GPUTextureFormat,\n    RG8Uint: \"rg8uint\" as GPUTextureFormat,\n    RG8Sint: \"rg8sint\" as GPUTextureFormat,\n\n    // 32-bit formats\n\n    R32Uint: \"r32uint\" as GPUTextureFormat,\n    R32Sint: \"r32sint\" as GPUTextureFormat,\n    R32Float: \"r32float\" as GPUTextureFormat,\n    RG16Uint: \"rg16uint\" as GPUTextureFormat,\n    RG16Sint: \"rg16sint\" as GPUTextureFormat,\n    RG16Float: \"rg16float\" as GPUTextureFormat,\n    RGBA8Unorm: \"rgba8unorm\" as GPUTextureFormat,\n    RGBA8UnormSRGB: \"rgba8unorm-srgb\" as GPUTextureFormat,\n    RGBA8Snorm: \"rgba8snorm\" as GPUTextureFormat,\n    RGBA8Uint: \"rgba8uint\" as GPUTextureFormat,\n    RGBA8Sint: \"rgba8sint\" as GPUTextureFormat,\n    BGRA8Unorm: \"bgra8unorm\" as GPUTextureFormat,\n    BGRA8UnormSRGB: \"bgra8unorm-srgb\" as GPUTextureFormat,\n    // Packed 32-bit formats\n    RGB9E5UFloat: \"rgb9e5ufloat\" as GPUTextureFormat,\n    RGB10A2Unorm: \"rgb10a2unorm\" as GPUTextureFormat,\n    RG11B10uFloat: \"rgb10a2unorm\" as GPUTextureFormat,\n\n    // 64-bit formats\n\n    RG32Uint: \"rg32uint\" as GPUTextureFormat,\n    RG32Sint: \"rg32sint\" as GPUTextureFormat,\n    RG32Float: \"rg32float\" as GPUTextureFormat,\n    RGBA16Uint: \"rgba16uint\" as GPUTextureFormat,\n    RGBA16Sint: \"rgba16sint\" as GPUTextureFormat,\n    RGBA16Float: \"rgba16float\" as GPUTextureFormat,\n\n    // 128-bit formats\n\n    RGBA32Uint: \"rgba32uint\" as GPUTextureFormat,\n    RGBA32Sint: \"rgba32sint\" as GPUTextureFormat,\n    RGBA32Float: \"rgba32float\" as GPUTextureFormat,\n\n    // Depth and stencil formats\n\n    Stencil8: \"stencil8\" as GPUTextureFormat,\n    Depth16Unorm: \"depth16unorm\" as GPUTextureFormat,\n    Depth24Plus: \"depth24plus\" as GPUTextureFormat,\n    Depth24PlusStencil8: \"depth24plus-stencil8\" as GPUTextureFormat,\n    Depth32Float: \"depth32float\" as GPUTextureFormat,\n\n    // BC compressed formats usable if 'texture-compression-bc' is both\n    // supported by the device/user agent and enabled in requestDevice.\n\n    BC1RGBAUnorm: \"bc1-rgba-unorm\" as GPUTextureFormat,\n    BC1RGBAUnormSRGB: \"bc1-rgba-unorm-srgb\" as GPUTextureFormat,\n    BC2RGBAUnorm: \"bc2-rgba-unorm\" as GPUTextureFormat,\n    BC2RGBAUnormSRGB: \"bc2-rgba-unorm-srgb\" as GPUTextureFormat,\n    BC3RGBAUnorm: \"bc3-rgba-unorm\" as GPUTextureFormat,\n    BC3RGBAUnormSRGB: \"bc3-rgba-unorm-srgb\" as GPUTextureFormat,\n    BC4RUnorm: \"bc4-r-unorm\" as GPUTextureFormat,\n    BC4RSNorm: \"bc4-r-snorm\" as GPUTextureFormat,\n    BC5RGUnorm: \"bc5-rg-unorm\" as GPUTextureFormat,\n    BC5RGSnorm: \"bc5-rg-snorm\" as GPUTextureFormat,\n    BC6HRGBUFloat: \"bc6h-rgb-ufloat\" as GPUTextureFormat,\n    BC6HRGBFloat: \"bc6h-rgb-float\" as GPUTextureFormat,\n    BC7RGBAUnorm: \"bc7-rgba-unorm\" as GPUTextureFormat,\n    BC7RGBAUnormSRGB: \"bc7-rgba-srgb\" as GPUTextureFormat,\n\n    // 'depth24unorm-stencil8' extension\n\n    Depth24UnormStencil8: \"depth24unorm-stencil8\" as GPUTextureFormat,\n\n    // 'depth32float-stencil8' extension\n\n    Depth32FloatStencil8: \"depth32float-stencil8\" as GPUTextureFormat,\n};\n\nexport const GPUAddressMode = {\n    ClampToEdge: \"clamp-to-edge\" as GPUAddressMode,\n    Repeat: \"repeat\" as GPUAddressMode,\n    MirrorRepeat: \"mirror-repeat\" as GPUAddressMode,\n};\n\nexport const GPUFilterMode = {\n    Linear: \"linear\" as GPUFilterMode,\n    Nearest: \"nearest\" as GPUFilterMode,\n};\n\nexport const GPUMipmapFilterMode = {\n    Linear: \"linear\" as GPUMipmapFilterMode,\n    Nearest: \"nearest\" as GPUMipmapFilterMode,\n};\n\nexport const GPUBlendFactor = {\n    Zero: \"zero\" as GPUBlendFactor,\n    One: \"one\" as GPUBlendFactor,\n    SrcColor: \"src-color\" as GPUBlendFactor,\n    OneMinusSrcColor: \"one-minus-src-color\" as GPUBlendFactor,\n    SrcAlpha: \"src-alpha\" as GPUBlendFactor,\n    OneMinusSrcAlpha: \"one-minus-src-alpha\" as GPUBlendFactor,\n    DstColor: \"dst-color\" as GPUBlendFactor,\n    OneMinusDstColor: \"one-minus-dst-color\" as GPUBlendFactor,\n    DstAlpha: \"dst-alpha\" as GPUBlendFactor,\n    OneMinusDstAlpha: \"one-minus-dst-alpha\" as GPUBlendFactor,\n    SrcAlphaSaturated: \"src-alpha-saturated\" as GPUBlendFactor,\n    BlendColor: \"blend-color\" as GPUBlendFactor,\n    OneMinusBlendColor: \"one-minus-blend-color\" as GPUBlendFactor,\n};\n\nexport const GPUBlendOperation = {\n    Add: \"add\",\n    Subtract: \"subtract\",\n    ReverseSubtract: \"reverse-subtract\",\n    Min: \"min\",\n    Max: \"max\",\n};\n\nexport const GPUColorWriteFlags = {\n    None: 0,\n    Red: 0x1,\n    Green: 0x2,\n    Blue: 0x4,\n    Alpha: 0x8,\n    All: 0xf,\n};\n\nexport const GPUStencilOperation = {\n    Keep: \"keep\",\n    Zero: \"zero\",\n    Replace: \"replace\",\n    Invert: \"invert\",\n    IncrementClamp: \"increment-clamp\",\n    DecrementClamp: \"decrement-clamp\",\n    IncrementWrap: \"increment-wrap\",\n    DecrementWrap: \"decrement-wrap\",\n};\n\nexport const GPUBindingType = {\n    UniformBuffer: \"uniform-buffer\",\n    StorageBuffer: \"storage-buffer\",\n    ReadonlyStorageBuffer: \"readonly-storage-buffer\",\n    Sampler: \"sampler\",\n    ComparisonSampler: \"comparison-sampler\",\n    SampledTexture: \"sampled-texture\",\n    MultisampledTexture: \"multisampled-texture\",\n    ReadonlyStorageTexture: \"readonly-storage-texture\",\n    WriteonlyStorageTexture: \"writeonly-storage-texture\",\n};\n\nexport const GPUTextureDimension = {\n    OneD: \"1d\",\n    TwoD: \"2d\",\n    ThreeD: \"3d\",\n};\n\nexport const GPUTextureViewDimension = {\n    OneD: \"1d\",\n    TwoD: \"2d\",\n    TwoDArray: \"2d-array\",\n    Cube: \"cube\",\n    CubeArray: \"cube-array\",\n    ThreeD: \"3d\",\n};\n\nexport const GPUInputStepMode = {\n    Vertex: \"vertex\",\n    Instance: \"instance\",\n};\n\nexport const GPUSamplerBindingType = {\n    Filtering: \"filtering\" as GPUSamplerBindingType,\n    NonFiltering: \"non-filtering\" as GPUSamplerBindingType,\n    Comparison: \"comparison\" as GPUSamplerBindingType,\n};\n\nexport const GPUBufferBindingType = {\n    Uniform: \"uniform\" as GPUBufferBindingType,\n    Storage: \"storage\" as GPUBufferBindingType,\n    ReadOnlyStorage: \"read-only-storage\" as GPUBufferBindingType,\n};\n\nexport const GPUChunkSize = 16; // size of a chunk in bytes (STD140 layout)\n\nexport const BlendColorFactor = 211;\nexport const OneMinusBlendColorFactor = 212;\n\nexport const GPUMapModeFlags = {\n    Read: 0x0001,\n    Write: 0x0002,\n};\n\nexport enum MOUSE {\n    LEFT = 0,\n    MIDDLE = 1,\n    RIGHT = 2,\n    ROTATE = 0,\n    DOLLY = 1,\n    PAN = 2,\n}\n\nexport enum TOUCH {\n    ROTATE = 0,\n    PAN = 1,\n    DOLLY_PAN = 2,\n    DOLLY_ROTATE = 3,\n}\n\nexport const UVMapping = 300;\nexport const CubeReflectionMapping = 301;\nexport const CubeRefractionMapping = 302;\nexport const EquirectangularReflectionMapping = 303;\nexport const EquirectangularRefractionMapping = 304;\nexport const CubeUVReflectionMapping = 306;\nexport const RepeatWrapping = 1000;\nexport const ClampToEdgeWrapping = 1001;\nexport const MirroredRepeatWrapping = 1002;\nexport const NearestFilter = 1003;\nexport const NearestMipmapNearestFilter = 1004;\nexport const NearestMipMapNearestFilter = 1004;\nexport const NearestMipmapLinearFilter = 1005;\nexport const NearestMipMapLinearFilter = 1005;\nexport const LinearFilter = 1006;\nexport const LinearMipmapNearestFilter = 1007;\nexport const LinearMipMapNearestFilter = 1007;\nexport const LinearMipmapLinearFilter = 1008;\nexport const LinearMipMapLinearFilter = 1008;\nexport const UnsignedByteType = 1009;\nexport const ByteType = 1010;\nexport const ShortType = 1011;\nexport const UnsignedShortType = 1012;\nexport const IntType = 1013;\nexport const UnsignedIntType = 1014;\nexport const FloatType = 1015;\nexport const HalfFloatType = 1016;\nexport const UnsignedShort4444Type = 1017;\nexport const UnsignedShort5551Type = 1018;\nexport const UnsignedInt248Type = 1020;\nexport const AlphaFormat = 1021;\nexport const RGBAFormat = 1023;\nexport const LuminanceFormat = 1024;\nexport const LuminanceAlphaFormat = 1025;\nexport const DepthFormat = 1026;\nexport const DepthStencilFormat = 1027;\nexport const RedFormat = 1028;\nexport const RedIntegerFormat = 1029;\nexport const RGFormat = 1030;\nexport const RGIntegerFormat = 1031;\nexport const RGBAIntegerFormat = 1033;\n\nexport const NoColorSpace = \"\";\nexport const SRGBColorSpace = \"srgb\";\nexport const LinearSRGBColorSpace = \"srgb-linear\";\nexport const DisplayP3ColorSpace = \"display-p3\";\n\nexport type MagnificationTextureFilter = typeof NearestFilter | typeof LinearFilter;\n\nexport type MinificationTextureFilter =\n    | typeof NearestFilter\n    | typeof NearestMipmapNearestFilter\n    | typeof NearestMipMapNearestFilter\n    | typeof NearestMipmapLinearFilter\n    | typeof NearestMipMapLinearFilter\n    | typeof LinearFilter\n    | typeof LinearMipmapNearestFilter\n    | typeof LinearMipMapNearestFilter\n    | typeof LinearMipmapLinearFilter\n    | typeof LinearMipMapLinearFilter;\n\nexport type DeepTexturePixelFormat = typeof DepthFormat | typeof DepthStencilFormat;\n\nexport type TextureDataType =\n    | typeof UnsignedByteType\n    | typeof ByteType\n    | typeof ShortType\n    | typeof UnsignedShortType\n    | typeof IntType\n    | typeof UnsignedIntType\n    | typeof FloatType\n    | typeof HalfFloatType\n    | typeof UnsignedShort4444Type\n    | typeof UnsignedShort5551Type\n    | typeof UnsignedInt248Type;\n\nexport type Mapping =\n    | typeof UVMapping\n    | typeof EquirectangularReflectionMapping\n    | typeof EquirectangularRefractionMapping;\n\nexport type Wrapping = typeof RepeatWrapping | typeof ClampToEdgeWrapping | typeof MirroredRepeatWrapping;\n\nexport type ColorSpace =\n    | typeof NoColorSpace\n    | typeof SRGBColorSpace\n    | typeof LinearSRGBColorSpace\n    | typeof DisplayP3ColorSpace;\n","import { Object3D } from \"../core/Object3D\";\nimport { BindBuffer } from \"../core/binds/BindBuffer\";\nimport { Matrix4 } from \"../math/Matrix4\";\nimport { Vector3 } from \"../math/Vector3\";\nimport { IdentifyMatrix4 } from \"../utils/TempValues\";\n\nconst u_projection = \"projectionMatrix\";\nconst u_view = \"matrixWorldInverse\";\nexport class Camera extends Object3D {\n    public get type() {\n        return \"Camera\";\n    }\n\n    public static Is(object: Object3D) {\n        return object instanceof Camera;\n    }\n\n    public get isCamera() {\n        return true;\n    }\n\n    public matrixWorldInverse = new Matrix4();\n\n    public projectionMatrix = new Matrix4();\n\n    public projectionMatrixInverse = new Matrix4();\n\n    private _uniforms: Map<string, BindBuffer> = new Map();\n\n    constructor() {\n        super();\n        this.matrixAutoUpdate = true;\n        this.matrixWorldNeedsUpdate = true;\n        this._initInitialUniform();\n    }\n\n    override copy(source: Camera, recursive = false) {\n        super.copy(source, recursive);\n\n        this.matrixWorldInverse.copy(source.matrixWorldInverse);\n\n        this.projectionMatrix.copy(source.projectionMatrix);\n        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);\n\n        return this;\n    }\n\n    getWorldDirection(target: Vector3) {\n        this.updateWorldMatrix(true, false);\n\n        const e = this.matrixWorld.elements;\n\n        return target.set(-e[8], -e[9], -e[10]).normalize();\n    }\n\n    updateMatrixWorld() {\n        super.updateMatrixWorld();\n\n        this.matrixWorldInverse.copy(this.matrixWorld).invert();\n    }\n\n    updateWorldMatrix(updateParents = false, updateChildren = false) {\n        super.updateWorldMatrix(updateParents, updateChildren);\n\n        this.matrixWorldInverse.copy(this.matrixWorld).invert();\n    }\n\n    clone() {\n        return new Camera().copy(this);\n    }\n\n    public update() {\n        this.updateWorldMatrix();\n        this._updateUniformValue();\n    }\n\n    private _updateUniformValue() {\n        let uniform = this._uniforms.get(u_projection);\n        uniform.data = this.projectionMatrix.toArray();\n        uniform.update();\n        uniform = this._uniforms.get(u_view);\n        uniform.data = this.matrixWorldInverse.toArray();\n        uniform.update();\n    }\n\n    private _initInitialUniform() {\n        const matrixBuffer = IdentifyMatrix4.toArray();\n        const projectionUniform = new BindBuffer(matrixBuffer);\n        this._uniforms.set(u_projection, projectionUniform);\n\n        const viewUniform = new BindBuffer(matrixBuffer);\n        this._uniforms.set(u_view, viewUniform);\n    }\n\n    public get uniforms() {\n        return this._uniforms;\n    }\n}\n","import { Object3D } from \"../core/Object3D\";\nimport { Camera } from \"./Camera\";\n\nexport class OrthographicCamera extends Camera {\n    public get type() {\n        return \"OrthographicCamera\";\n    }\n\n    public static Is(object: Object3D) {\n        return object instanceof OrthographicCamera;\n    }\n\n    public zoom = 1;\n    public view: any = null;\n\n    public left = -1;\n    public right = 1;\n    public top = 1;\n    public bottom = -1;\n\n    public near = 0.1;\n    public far = 2000;\n\n    constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {\n        super();\n        this.left = left;\n        this.right = right;\n        this.top = top;\n        this.bottom = bottom;\n        this.near = near;\n        this.far = far;\n\n        this.updateProjectionMatrix();\n    }\n\n    copy(source: OrthographicCamera, recursive = false) {\n        super.copy(source, recursive);\n\n        this.left = source.left;\n        this.right = source.right;\n        this.top = source.top;\n        this.bottom = source.bottom;\n        this.near = source.near;\n        this.far = source.far;\n\n        this.zoom = source.zoom;\n        this.view = source.view === null ? null : Object.assign({}, source.view);\n\n        return this;\n    }\n\n    setViewOffset(fullWidth: number, fullHeight: number, x: number, y: number, width: number, height: number) {\n        if (this.view === null) {\n            this.view = {\n                enabled: true,\n                fullWidth: 1,\n                fullHeight: 1,\n                offsetX: 0,\n                offsetY: 0,\n                width: 1,\n                height: 1,\n            };\n        }\n\n        this.view.enabled = true;\n        this.view.fullWidth = fullWidth;\n        this.view.fullHeight = fullHeight;\n        this.view.offsetX = x;\n        this.view.offsetY = y;\n        this.view.width = width;\n        this.view.height = height;\n\n        this.updateProjectionMatrix();\n    }\n\n    clearViewOffset() {\n        if (this.view !== null) {\n            this.view.enabled = false;\n        }\n\n        this.updateProjectionMatrix();\n    }\n\n    updateProjectionMatrix() {\n        const dx = (this.right - this.left) / (2 * this.zoom);\n        const dy = (this.top - this.bottom) / (2 * this.zoom);\n        const cx = (this.right + this.left) / 2;\n        const cy = (this.top + this.bottom) / 2;\n\n        let left = cx - dx;\n        let right = cx + dx;\n        let top = cy + dy;\n        let bottom = cy - dy;\n\n        if (this.view !== null && this.view.enabled) {\n            const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;\n            const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n\n            left += scaleW * this.view.offsetX;\n            right = left + scaleW * this.view.width;\n            top -= scaleH * this.view.offsetY;\n            bottom = top - scaleH * this.view.height;\n        }\n\n        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);\n\n        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n    }\n}\n","import { Object3D } from \"../core/Object3D\";\nimport { Camera } from \"./Camera\";\nimport * as MathUtils from \"../math/MathUtils\";\n\nexport class PerspectiveCamera extends Camera {\n    public get type() {\n        return \"PerspectiveCamera\";\n    }\n\n    public static Is(object: Object3D) {\n        return object instanceof PerspectiveCamera;\n    }\n\n    public fov = 50;\n    public aspect = 1;\n    public near = 0.1;\n    public far = 2000;\n    public zoom = 1;\n    public focus = 10;\n    public view: any;\n    public filmGauge = 35;\n    public filmOffset = 10;\n\n    constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {\n        super();\n\n        this.fov = fov;\n        this.zoom = 1;\n\n        this.near = near;\n        this.far = far;\n        this.focus = 10;\n\n        this.aspect = aspect;\n        this.view = null;\n\n        this.filmGauge = 35; // width of the film (default in millimeters)\n        this.filmOffset = 0; // horizontal film offset (same unit as gauge)\n\n        this.updateProjectionMatrix();\n    }\n\n    copy(source: PerspectiveCamera, recursive = false) {\n        super.copy(source, recursive);\n\n        this.fov = source.fov;\n        this.zoom = source.zoom;\n\n        this.near = source.near;\n        this.far = source.far;\n        this.focus = source.focus;\n\n        this.aspect = source.aspect;\n        this.view = source.view === null ? null : Object.assign({}, source.view);\n\n        this.filmGauge = source.filmGauge;\n        this.filmOffset = source.filmOffset;\n\n        return this;\n    }\n\n    /**\n     * Sets the FOV by focal length in respect to the current .filmGauge.\n     *\n     * The default film gauge is 35, so that the focal length can be specified for\n     * a 35mm (full frame) camera.\n     *\n     * Values for focal length and film gauge must have the same unit.\n     */\n    setFocalLength(focalLength: number) {\n        /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n        const vExtentSlope = (0.5 * this.getFilmHeight()) / focalLength;\n\n        this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);\n        this.updateProjectionMatrix();\n    }\n\n    /**\n     * Calculates the focal length from the current .fov and .filmGauge.\n     */\n    getFocalLength() {\n        const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);\n\n        return (0.5 * this.getFilmHeight()) / vExtentSlope;\n    }\n\n    getEffectiveFOV() {\n        return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);\n    }\n\n    getFilmWidth() {\n        // film not completely covered in portrait format (aspect < 1)\n        return this.filmGauge * Math.min(this.aspect, 1);\n    }\n\n    getFilmHeight() {\n        // film not completely covered in landscape format (aspect > 1)\n        return this.filmGauge / Math.max(this.aspect, 1);\n    }\n\n    /**\n     * Sets an offset in a larger frustum. This is useful for multi-window or\n     * multi-monitor/multi-machine setups.\n     *\n     * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n     * the monitors are in grid like this\n     *\n     *   +---+---+---+\n     *   | A | B | C |\n     *   +---+---+---+\n     *   | D | E | F |\n     *   +---+---+---+\n     *\n     * then for each monitor you would call it like this\n     *\n     *   const w = 1920;\n     *   const h = 1080;\n     *   const fullWidth = w * 3;\n     *   const fullHeight = h * 2;\n     *\n     *   --A--\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n     *   --B--\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n     *   --C--\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n     *   --D--\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n     *   --E--\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n     *   --F--\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n     *\n     *   Note there is no reason monitors have to be the same size or in a grid.\n     */\n    setViewOffset(fullWidth: number, fullHeight: number, x: number, y: number, width: number, height: number) {\n        this.aspect = fullWidth / fullHeight;\n\n        if (this.view === null) {\n            this.view = {\n                enabled: true,\n                fullWidth: 1,\n                fullHeight: 1,\n                offsetX: 0,\n                offsetY: 0,\n                width: 1,\n                height: 1,\n            };\n        }\n\n        this.view.enabled = true;\n        this.view.fullWidth = fullWidth;\n        this.view.fullHeight = fullHeight;\n        this.view.offsetX = x;\n        this.view.offsetY = y;\n        this.view.width = width;\n        this.view.height = height;\n\n        this.updateProjectionMatrix();\n    }\n\n    clearViewOffset() {\n        if (this.view !== null) {\n            this.view.enabled = false;\n        }\n\n        this.updateProjectionMatrix();\n    }\n\n    updateProjectionMatrix() {\n        const near = this.near;\n        let top = (near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov)) / this.zoom;\n        let height = 2 * top;\n        let width = this.aspect * height;\n        let left = -0.5 * width;\n        const view = this.view;\n\n        if (this.view !== null && this.view.enabled) {\n            const fullWidth = view.fullWidth,\n                fullHeight = view.fullHeight;\n\n            left += (view.offsetX * width) / fullWidth;\n            top -= (view.offsetY * height) / fullHeight;\n            width *= view.width / fullWidth;\n            height *= view.height / fullHeight;\n        }\n\n        const skew = this.filmOffset;\n        if (skew !== 0) left += (near * skew) / this.getFilmWidth();\n\n        this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);\n\n        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n    }\n}\n","import { Camera } from \"../cameras/Camera\";\nimport { OrthographicCamera } from \"../cameras/OrthographicCamera\";\nimport { PerspectiveCamera } from \"../cameras/PerspectiveCamera\";\nimport { MOUSE } from \"../Constants\";\nimport { Matrix4 } from \"../math/Matrix4\";\nimport { Quaternion } from \"../math/Quaternion\";\nimport { Spherical } from \"../math/Spherical\";\nimport { Vector2 } from \"../math/Vector2\";\nimport { Vector3 } from \"../math/Vector3\";\n\nconst STATE = {\n    NONE: -1,\n    ROTATE: 0,\n    DOLLY: 1,\n    PAN: 2,\n    TOUCH_ROTATE: 3,\n    TOUCH_DOLLY: 4,\n    TOUCH_PAN: 5,\n};\n\nconst EPS = 0.000001;\nconst twoPI = 2 * Math.PI;\n/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n * @author nicolaspanel / http://github.com/nicolaspanel\n *\n * This set of controls performs orbiting, dollying (zooming), and panning.\n * Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n *    Orbit - left mouse / touch: one finger move\n *    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n *    Pan - right mouse, or arrow keys / touch:  finger swipe\n */\nexport class OrbitControls {\n    camera: PerspectiveCamera | OrthographicCamera;\n    domElement: HTMLElement;\n    window: Window;\n\n    // API\n    enabled: boolean;\n    target: Vector3;\n\n    enableZoom: boolean;\n    zoomSpeed: number;\n    minDistance: number;\n    maxDistance: number;\n    enableRotate: boolean;\n    rotateSpeed: number;\n    enablePan: boolean;\n    keyPanSpeed: number;\n    autoRotate: boolean;\n    autoRotateSpeed: number;\n    minZoom: number;\n    maxZoom: number;\n    minPolarAngle: number;\n    maxPolarAngle: number;\n    minAzimuthAngle: number;\n    maxAzimuthAngle: number;\n    enableKeys: boolean;\n    keys: { LEFT: number; UP: number; RIGHT: number; BOTTOM: number };\n    mouseButtons: { ORBIT: MOUSE; ZOOM: MOUSE; PAN: MOUSE };\n    enableDamping: boolean;\n    dampingFactor: number;\n\n    private spherical: Spherical;\n    private sphericalDelta: Spherical;\n    private scale: number;\n    private target0: Vector3;\n    private position0: Vector3;\n    private zoom0: any;\n    private state: number;\n    private panOffset: Vector3;\n    private zoomChanged: boolean;\n\n    private rotateStart: Vector2;\n    private rotateEnd: Vector2;\n    private rotateDelta: Vector2;\n\n    private panStart: Vector2;\n    private panEnd: Vector2;\n    private panDelta: Vector2;\n\n    private dollyStart: Vector2;\n    private dollyEnd: Vector2;\n    private dollyDelta: Vector2;\n\n    private updateLastPosition: Vector3;\n    private updateLastTargetPosition: Vector3;\n    private updateOffset: Vector3;\n    private updateQuat: Quaternion;\n    private updateLastQuaternion: Quaternion;\n    private updateQuatInverse: Quaternion;\n\n    private panLeftV: Vector3;\n    private panUpV: Vector3;\n    private panInternalOffset: Vector3;\n\n    private onContextMenu: any;\n    private onMouseUp: any;\n    private onMouseDown: any;\n    private onMouseMove: any;\n    private onMouseWheel: any;\n    private onTouchStart: any;\n    private onTouchEnd: any;\n    private onTouchMove: any;\n    private onKeyDown: any;\n\n    constructor(object: PerspectiveCamera | OrthographicCamera, domElement: HTMLElement, domWindow?: Window) {\n        this.camera = object;\n\n        this.domElement = domElement;\n        this.window = domWindow !== undefined ? domWindow : window;\n\n        // Set to false to disable this control\n        this.enabled = true;\n\n        // \"target\" sets the location of focus, where the object orbits around\n        this.target = new Vector3();\n\n        // How far you can dolly in and out ( PerspectiveCamera only )\n        this.minDistance = 0;\n        this.maxDistance = Infinity;\n\n        // How far you can zoom in and out ( OrthographicCamera only )\n        this.minZoom = 0;\n        this.maxZoom = Infinity;\n\n        // How far you can orbit vertically, upper and lower limits.\n        // Range is 0 to Math.PI radians.\n        this.minPolarAngle = 0; // radians\n        this.maxPolarAngle = Math.PI; // radians\n\n        // How far you can orbit horizontally, upper and lower limits.\n        // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n        this.minAzimuthAngle = -Infinity; // radians\n        this.maxAzimuthAngle = Infinity; // radians\n\n        // Set to true to enable damping (inertia)\n        // If damping is enabled, you must call controls.update() in your animation loop\n        this.enableDamping = false;\n        this.dampingFactor = 0.25;\n\n        // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n        // Set to false to disable zooming\n        this.enableZoom = true;\n        this.zoomSpeed = 1.0;\n\n        // Set to false to disable rotating\n        this.enableRotate = true;\n        this.rotateSpeed = 1.0;\n\n        // Set to false to disable panning\n        this.enablePan = true;\n        this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n        // Set to true to automatically rotate around the target\n        // If auto-rotate is enabled, you must call controls.update() in your animation loop\n        this.autoRotate = false;\n        this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n        // Set to false to disable use of the keys\n        this.enableKeys = true;\n\n        // The four arrow keys\n        this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n        // Mouse buttons\n        this.mouseButtons = {\n            ORBIT: MOUSE.LEFT,\n            ZOOM: MOUSE.MIDDLE,\n            PAN: MOUSE.RIGHT,\n        };\n\n        // for reset\n        this.target0 = this.target.clone();\n        this.position0 = this.camera.position.clone();\n        this.zoom0 = (this.camera as any).zoom;\n\n        // for update speedup\n        this.updateOffset = new Vector3();\n        // so camera.up is the orbit axis\n        this.updateQuat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));\n        this.updateQuatInverse = this.updateQuat.clone().invert();\n        this.updateLastPosition = new Vector3();\n        this.updateLastTargetPosition = new Vector3();\n        this.updateLastQuaternion = new Quaternion();\n\n        this.state = STATE.NONE;\n        this.scale = 1;\n\n        // current position in spherical coordinates\n        this.spherical = new Spherical();\n        this.sphericalDelta = new Spherical();\n\n        this.panOffset = new Vector3();\n        this.zoomChanged = false;\n\n        this.rotateStart = new Vector2();\n        this.rotateEnd = new Vector2();\n        this.rotateDelta = new Vector2();\n\n        this.panStart = new Vector2();\n        this.panEnd = new Vector2();\n        this.panDelta = new Vector2();\n\n        this.dollyStart = new Vector2();\n        this.dollyEnd = new Vector2();\n        this.dollyDelta = new Vector2();\n\n        this.panLeftV = new Vector3();\n        this.panUpV = new Vector3();\n        this.panInternalOffset = new Vector3();\n\n        // event handlers - FSM: listen for events and reset state\n\n        this.onMouseDown = (event: MouseEvent) => {\n            if (this.enabled === false) return;\n            event.preventDefault();\n            if ((event as any).button === this.mouseButtons.ORBIT) {\n                if (this.enableRotate === false) return;\n                this.rotateStart.set(event.clientX, event.clientY);\n                this.state = STATE.ROTATE;\n            } else if (event.button === this.mouseButtons.ZOOM) {\n                if (this.enableZoom === false) return;\n                this.dollyStart.set(event.clientX, event.clientY);\n                this.state = STATE.DOLLY;\n            } else if (event.button === this.mouseButtons.PAN) {\n                if (this.enablePan === false) return;\n                this.panStart.set(event.clientX, event.clientY);\n                this.state = STATE.PAN;\n            }\n\n            if (this.state !== STATE.NONE) {\n                document.addEventListener(\"mousemove\", this.onMouseMove, false);\n                document.addEventListener(\"mouseup\", this.onMouseUp, false);\n                //this.dispatchEvent( START_EVENT );\n            }\n        };\n\n        this.onMouseMove = (event: MouseEvent) => {\n            if (this.enabled === false) return;\n\n            event.preventDefault();\n\n            if (this.state === STATE.ROTATE) {\n                if (this.enableRotate === false) return;\n                this.rotateEnd.set(event.clientX, event.clientY);\n                this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);\n                const element = this.domElement;\n\n                // rotating across whole screen goes 360 degrees around\n                this.rotateLeft(((2 * Math.PI * this.rotateDelta.x) / (element as any).clientWidth) * this.rotateSpeed);\n                // rotating up and down along whole screen attempts to go 360, but limited to 180\n                this.rotateUp(((2 * Math.PI * this.rotateDelta.y) / (element as any).clientHeight) * this.rotateSpeed);\n                this.rotateStart.copy(this.rotateEnd);\n\n                this.update();\n            } else if (this.state === STATE.DOLLY) {\n                if (this.enableZoom === false) return;\n\n                this.dollyEnd.set(event.clientX, event.clientY);\n                this.dollyDelta.subVectors(this.dollyEnd, this.dollyStart);\n\n                if (this.dollyDelta.y > 0) {\n                    this.dollyIn(this.getZoomScale());\n                } else if (this.dollyDelta.y < 0) {\n                    this.dollyOut(this.getZoomScale());\n                }\n\n                this.dollyStart.copy(this.dollyEnd);\n                this.update();\n            } else if (this.state === STATE.PAN) {\n                if (this.enablePan === false) return;\n\n                this.panEnd.set(event.clientX, event.clientY);\n                this.panDelta.subVectors(this.panEnd, this.panStart);\n                this.pan(this.panDelta.x, this.panDelta.y);\n                this.panStart.copy(this.panEnd);\n                this.update();\n            }\n        };\n\n        this.onMouseUp = () => {\n            if (this.enabled === false) return;\n            document.removeEventListener(\"mousemove\", this.onMouseMove, false);\n            document.removeEventListener(\"mouseup\", this.onMouseUp, false);\n\n            this.state = STATE.NONE;\n        };\n\n        this.onMouseWheel = (event: WheelEvent) => {\n            if (\n                this.enabled === false ||\n                this.enableZoom === false ||\n                (this.state !== STATE.NONE && this.state !== STATE.ROTATE)\n            )\n                return;\n\n            event.preventDefault();\n            event.stopPropagation();\n\n            if (event.deltaY < 0) {\n                this.dollyOut(this.getZoomScale());\n            } else if (event.deltaY > 0) {\n                this.dollyIn(this.getZoomScale());\n            }\n\n            this.update();\n\n            //this.dispatchEvent( START_EVENT ); // not sure why these are here...\n            //this.dispatchEvent( END_EVENT );\n        };\n\n        this.onKeyDown = (event: ControlEvent) => {\n            if (this.enabled === false || this.enableKeys === false || this.enablePan === false) return;\n\n            switch (event.keyCode) {\n                case this.keys.UP:\n                    {\n                        this.pan(0, this.keyPanSpeed);\n                        this.update();\n                    }\n                    break;\n                case this.keys.BOTTOM:\n                    {\n                        this.pan(0, -this.keyPanSpeed);\n                        this.update();\n                    }\n                    break;\n                case this.keys.LEFT:\n                    {\n                        this.pan(this.keyPanSpeed, 0);\n                        this.update();\n                    }\n                    break;\n                case this.keys.RIGHT:\n                    {\n                        this.pan(-this.keyPanSpeed, 0);\n                        this.update();\n                    }\n                    break;\n            }\n        };\n\n        this.onTouchStart = (event: ControlEvent) => {\n            if (this.enabled === false) return;\n\n            switch (event.touches.length) {\n                // one-fingered touch: rotate\n                case 1:\n                    {\n                        if (this.enableRotate === false) return;\n\n                        this.rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                        this.state = STATE.TOUCH_ROTATE;\n                    }\n                    break;\n                // two-fingered touch: dolly\n                case 2:\n                    {\n                        if (this.enableZoom === false) return;\n\n                        const dx = event.touches[0].pageX - event.touches[1].pageX;\n                        const dy = event.touches[0].pageY - event.touches[1].pageY;\n\n                        const distance = Math.sqrt(dx * dx + dy * dy);\n                        this.dollyStart.set(0, distance);\n                        this.state = STATE.TOUCH_DOLLY;\n                    }\n                    break;\n                // -fingered touch: pan\n                case 3:\n                    {\n                        if (this.enablePan === false) return;\n\n                        this.panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                        this.state = STATE.TOUCH_PAN;\n                    }\n                    break;\n                default: {\n                    this.state = STATE.NONE;\n                }\n            }\n\n            if (this.state !== STATE.NONE) {\n                //this.dispatchEvent( START_EVENT );\n            }\n        };\n\n        this.onTouchMove = (event: TouchEvent) => {\n            if (this.enabled === false) return;\n            event.preventDefault();\n            event.stopPropagation();\n\n            switch (event.touches.length) {\n                // one-fingered touch: rotate\n                case 1:\n                    {\n                        if (this.enableRotate === false) return;\n                        if (this.state !== STATE.TOUCH_ROTATE) return; // is this needed?...\n\n                        this.rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                        this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);\n\n                        const element = this.domElement;\n\n                        // rotating across whole screen goes 360 degrees around\n                        this.rotateLeft(\n                            ((2 * Math.PI * this.rotateDelta.x) / (element as any).clientWidth) * this.rotateSpeed\n                        );\n\n                        // rotating up and down along whole screen attempts to go 360, but limited to 180\n                        this.rotateUp(\n                            ((2 * Math.PI * this.rotateDelta.y) / (element as any).clientHeight) * this.rotateSpeed\n                        );\n\n                        this.rotateStart.copy(this.rotateEnd);\n\n                        this.update();\n                    }\n                    break;\n                // two-fingered touch: dolly\n                case 2:\n                    {\n                        if (this.enableZoom === false) return;\n                        if (this.state !== STATE.TOUCH_DOLLY) return; // is this needed?...\n\n                        //console.log( 'handleTouchMoveDolly' );\n                        const dx = event.touches[0].pageX - event.touches[1].pageX;\n                        const dy = event.touches[0].pageY - event.touches[1].pageY;\n\n                        const distance = Math.sqrt(dx * dx + dy * dy);\n\n                        this.dollyEnd.set(0, distance);\n\n                        this.dollyDelta.subVectors(this.dollyEnd, this.dollyStart);\n\n                        if (this.dollyDelta.y > 0) {\n                            this.dollyOut(this.getZoomScale());\n                        } else if (this.dollyDelta.y < 0) {\n                            this.dollyIn(this.getZoomScale());\n                        }\n\n                        this.dollyStart.copy(this.dollyEnd);\n                        this.update();\n                    }\n                    break;\n                // -fingered touch: pan\n                case 3:\n                    {\n                        if (this.enablePan === false) return;\n                        if (this.state !== STATE.TOUCH_PAN) return; // is this needed?...\n                        this.panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                        this.panDelta.subVectors(this.panEnd, this.panStart);\n                        this.pan(this.panDelta.x, this.panDelta.y);\n                        this.panStart.copy(this.panEnd);\n                        this.update();\n                    }\n                    break;\n                default: {\n                    this.state = STATE.NONE;\n                }\n            }\n        };\n\n        this.onTouchEnd = () => {\n            if (this.enabled === false) return;\n\n            this.state = STATE.NONE;\n        };\n\n        this.onContextMenu = (event: MouseEvent) => {\n            event.preventDefault();\n        };\n\n        this.domElement.addEventListener(\"contextmenu\", this.onContextMenu, false);\n\n        this.domElement.addEventListener(\"mousedown\", this.onMouseDown, false);\n        this.domElement.addEventListener(\"wheel\", this.onMouseWheel, false);\n\n        this.domElement.addEventListener(\"touchstart\", this.onTouchStart, false);\n        this.domElement.addEventListener(\"touchend\", this.onTouchEnd, false);\n        this.domElement.addEventListener(\"touchmove\", this.onTouchMove, false);\n\n        this.window.addEventListener(\"keydown\", this.onKeyDown, false);\n\n        // force an update at start\n        this.update();\n    }\n\n    update() {\n        const position = this.camera.position;\n        this.updateOffset.copy(position).sub(this.target);\n\n        // rotate offset to \"y-axis-is-up\" space\n        this.updateOffset.applyQuaternion(this.updateQuat);\n\n        // angle from z-axis around y-axis\n        this.spherical.setFromVector3(this.updateOffset);\n\n        if (this.autoRotate && this.state === STATE.NONE) {\n            this.rotateLeft(this.getAutoRotationAngle());\n        }\n\n        if (this.enableDamping) {\n            this.spherical.theta += this.sphericalDelta.theta * this.dampingFactor;\n            this.spherical.phi += this.sphericalDelta.phi * this.dampingFactor;\n        } else {\n            this.spherical.theta += this.sphericalDelta.theta;\n            this.spherical.phi += this.sphericalDelta.phi;\n        }\n\n        // restrict theta to be between desired limits\n\n        let min = this.minAzimuthAngle;\n        let max = this.maxAzimuthAngle;\n\n        if (isFinite(min) && isFinite(max)) {\n            if (min < -Math.PI) min += twoPI;\n            else if (min > Math.PI) min -= twoPI;\n\n            if (max < -Math.PI) max += twoPI;\n            else if (max > Math.PI) max -= twoPI;\n\n            if (min <= max) {\n                this.spherical.theta = Math.max(min, Math.min(max, this.spherical.theta));\n            } else {\n                this.spherical.theta =\n                    this.spherical.theta > (min + max) / 2\n                        ? Math.max(min, this.spherical.theta)\n                        : Math.min(max, this.spherical.theta);\n            }\n        }\n\n        // restrict phi to be between desired limits\n        this.spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this.spherical.phi));\n\n        this.spherical.makeSafe();\n\n        this.spherical.radius *= this.scale;\n\n        // restrict radius to be between desired limits\n        this.spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.spherical.radius));\n\n        // move target to panned location\n\n        if (this.enableDamping === true) {\n            this.target.addScaledVector(this.panOffset, this.dampingFactor);\n        } else {\n            this.target.add(this.panOffset);\n        }\n\n        this.updateOffset.setFromSpherical(this.spherical);\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        this.updateOffset.applyQuaternion(this.updateQuatInverse);\n\n        position.copy(this.target).add(this.updateOffset);\n\n        this.camera.lookAt(this.target);\n\n        if (this.enableDamping === true) {\n            this.sphericalDelta.theta *= 1 - this.dampingFactor;\n            this.sphericalDelta.phi *= 1 - this.dampingFactor;\n\n            this.panOffset.multiplyScalar(1 - this.dampingFactor);\n        } else {\n            this.sphericalDelta.set(0, 0, 0);\n\n            this.panOffset.set(0, 0, 0);\n        }\n\n        this.scale = 1;\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (\n            this.zoomChanged ||\n            this.updateLastPosition.distanceToSquared(this.camera.position) > EPS ||\n            8 * (1 - this.updateLastQuaternion.dot(this.camera.quaternion)) > EPS ||\n            this.updateLastTargetPosition.distanceToSquared(this.target) > 0\n        ) {\n            this.updateLastPosition.copy(this.camera.position);\n            this.updateLastQuaternion.copy(this.camera.quaternion);\n            this.updateLastTargetPosition.copy(this.target);\n\n            this.zoomChanged = false;\n\n            return true;\n        }\n\n        return false;\n\n        // this.spherical.theta += this.sphericalDelta.theta;\n        // this.spherical.phi += this.sphericalDelta.phi;\n\n        // // restrict theta to be between desired limits\n        // this.spherical.theta = Math.max( this.minAzimuthAngle, Math.min( this.maxAzimuthAngle, this.spherical.theta ) );\n\n        // // restrict phi to be between desired limits\n        // this.spherical.phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, this.spherical.phi ) );\n\n        // this.spherical.makeSafe();\n\n        // this.spherical.radius *= this.scale;\n\n        // // restrict radius to be between desired limits\n        // this.spherical.radius = Math.max( this.minDistance, Math.min( this.maxDistance, this.spherical.radius ) );\n\n        // // move target to panned location\n        // this.target.add( this.panOffset );\n\n        // this.updateOffset.setFromSpherical( this.spherical );\n\n        // // rotate offset back to \"camera-up-vector-is-up\" space\n        // this.updateOffset.applyQuaternion( this.updateQuatInverse );\n\n        // position.copy( this.target ).add( this.updateOffset );\n\n        // this.camera.lookAt( this.target );\n\n        // if ( this.enableDamping === true ) {\n\n        //   this.sphericalDelta.theta *= ( 1 - this.dampingFactor );\n        //   this.sphericalDelta.phi *= ( 1 - this.dampingFactor );\n\n        // } else {\n\n        //   this.sphericalDelta.set( 0, 0, 0 );\n\n        // }\n\n        // this.scale = 1;\n        // this.panOffset.set( 0, 0, 0 );\n\n        // // update condition is:\n        // // min(camera displacement, camera rotation in radians)^2 > EPS\n        // // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        // if ( this.zoomChanged ||\n        //   this.updateLastPosition.distanceToSquared( this.camera.position ) > EPS ||\n        //   8 * ( 1 - this.updateLastQuaternion.dot( this.camera.quaternion ) ) > EPS ) {\n\n        //   //this.dispatchEvent( CHANGE_EVENT );\n        //   this.updateLastPosition.copy( this.camera.position );\n        //   this.updateLastQuaternion.copy( this.camera.quaternion );\n        //   this.zoomChanged = false;\n        //   return true;\n        // }\n        // return false;\n    }\n\n    panLeft(distance: number, objectMatrix: Matrix4) {\n        this.panLeftV.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\n        this.panLeftV.multiplyScalar(-distance);\n        this.panOffset.add(this.panLeftV);\n    }\n\n    panUp(distance: number, objectMatrix: Matrix4) {\n        this.panUpV.setFromMatrixColumn(objectMatrix, 1); // get Y column of objectMatrix\n        this.panUpV.multiplyScalar(distance);\n        this.panOffset.add(this.panUpV);\n    }\n\n    // deltaX and deltaY are in pixels; right and down are positive\n    pan(deltaX: number, deltaY: number) {\n        const element = this.domElement;\n\n        if (this._checkPerspectiveCamera(this.camera)) {\n            // perspective\n            const position = this.camera.position;\n            this.panInternalOffset.copy(position).sub(this.target);\n            let targetDistance = this.panInternalOffset.length();\n\n            // half of the fov is center to top of screen\n            targetDistance *= Math.tan(((this.camera.fov / 2) * Math.PI) / 180.0);\n\n            // we actually don't use screenWidth, since perspective camera is fixed to screen height\n            this.panLeft((2 * deltaX * targetDistance) / (element as any).clientHeight, this.camera.matrix);\n            this.panUp((2 * deltaY * targetDistance) / (element as any).clientHeight, this.camera.matrix);\n        } else if (this._checkOrthographicCamera(this.camera)) {\n            // orthographic\n            this.panLeft(\n                (deltaX * (this.camera.right - this.camera.left)) / this.camera.zoom / (element as any).clientWidth,\n                this.camera.matrix\n            );\n            this.panUp(\n                (deltaY * (this.camera.top - this.camera.bottom)) / this.camera.zoom / (element as any).clientHeight,\n                this.camera.matrix\n            );\n        } else {\n            // camera neither orthographic nor perspective\n            console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\");\n            this.enablePan = false;\n        }\n    }\n\n    dollyIn(dollyScale: number) {\n        if (this._checkPerspectiveCamera(this.camera)) {\n            this.scale /= dollyScale;\n        } else if (this._checkOrthographicCamera(this.camera)) {\n            this.camera.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.camera.zoom * dollyScale));\n            this.camera.updateProjectionMatrix();\n            this.zoomChanged = true;\n        } else {\n            console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n            this.enableZoom = false;\n        }\n    }\n\n    dollyOut(dollyScale: number) {\n        if (this._checkPerspectiveCamera(this.camera)) {\n            this.scale *= dollyScale;\n        } else if (this._checkOrthographicCamera(this.camera)) {\n            this.camera.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.camera.zoom / dollyScale));\n            this.camera.updateProjectionMatrix();\n            this.zoomChanged = true;\n        } else {\n            console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n            this.enableZoom = false;\n        }\n    }\n\n    getAutoRotationAngle() {\n        return ((2 * Math.PI) / 60 / 60) * this.autoRotateSpeed;\n    }\n\n    getZoomScale() {\n        return Math.pow(0.95, this.zoomSpeed);\n    }\n\n    rotateLeft(angle: number) {\n        this.sphericalDelta.theta -= angle;\n    }\n\n    rotateUp(angle: number) {\n        this.sphericalDelta.phi -= angle;\n    }\n\n    getPolarAngle(): number {\n        return this.spherical.phi;\n    }\n\n    getAzimuthalAngle(): number {\n        return this.spherical.theta;\n    }\n\n    dispose(): void {\n        this.domElement.removeEventListener(\"contextmenu\", this.onContextMenu, false);\n        this.domElement.removeEventListener(\"mousedown\", this.onMouseDown, false);\n        this.domElement.removeEventListener(\"wheel\", this.onMouseWheel, false);\n\n        this.domElement.removeEventListener(\"touchstart\", this.onTouchStart, false);\n        this.domElement.removeEventListener(\"touchend\", this.onTouchEnd, false);\n        this.domElement.removeEventListener(\"touchmove\", this.onTouchMove, false);\n\n        document.removeEventListener(\"mousemove\", this.onMouseMove, false);\n        document.removeEventListener(\"mouseup\", this.onMouseUp, false);\n\n        this.window.removeEventListener(\"keydown\", this.onKeyDown, false);\n        //this.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n    }\n\n    reset(): void {\n        this.target.copy(this.target0);\n        this.camera.position.copy(this.position0);\n        (this.camera as any).zoom = this.zoom0;\n\n        (this.camera as any).updateProjectionMatrix();\n        //this.dispatchEvent( CHANGE_EVENT );\n\n        this.update();\n\n        this.state = STATE.NONE;\n    }\n\n    saveState(): void {\n        this.target0.copy(this.target);\n        this.position0.copy(this.camera.position);\n        // Check whether the camera has zoom property\n        if (this._checkOrthographicCamera(this.camera) || this._checkPerspectiveCamera(this.camera)) {\n            this.zoom0 = this.camera.zoom;\n        }\n    }\n\n    // backward compatibility\n    get center(): Vector3 {\n        console.warn(\"OrbitControls: .center has been renamed to .target\");\n        return this.target;\n    }\n    get noZoom(): boolean {\n        console.warn(\"OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.\");\n        return !this.enableZoom;\n    }\n\n    set noZoom(value: boolean) {\n        console.warn(\"OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.\");\n        this.enableZoom = !value;\n    }\n\n    /**\n     * TS typeguard. Checks whether the provided camera is PerspectiveCamera.\n     * If the check passes (returns true) the passed camera will have the type PerspectiveCamera in the if branch where the check was performed.\n     * @param camera Object to be checked.\n     */\n    private _checkPerspectiveCamera(camera: Camera): camera is PerspectiveCamera {\n        return PerspectiveCamera.Is(camera);\n    }\n    /**\n     * TS typeguard. Checks whether the provided camera is OrthographicCamera.\n     * If the check passes (returns true) the passed camera will have the type OrthographicCamera in the if branch where the check was performed.\n     * @param camera Object to be checked.\n     */\n    private _checkOrthographicCamera(camera: Camera): camera is OrthographicCamera {\n        return OrthographicCamera.Is(camera);\n    }\n}\n\ninterface ControlEvent extends Event {\n    clientX: number;\n    clientY: number;\n    deltaY: number;\n    button: MOUSE;\n    touches: Array<any>;\n    keyCode: number;\n}\n","import { NumberArrayType } from \"../Constants\";\nimport { GPUBufferWrapper } from \"./GPUBufferWrapper\";\n\nexport class BufferAttribute {\n    private _array: NumberArrayType;\n    private _count = 0;\n    private _itemSize = 0;\n    private _format: GPUVertexFormat | GPUIndexFormat;\n    private _normalized = false;\n    private _byteLength = 0;\n    private _name = \"\";\n    private _needsUpdate = false;\n    private _gpuBuffer: GPUBufferWrapper;\n    private _usage: GPUFlagsConstant = GPUBufferUsage.VERTEX;\n\n    get buffer() {\n        return this._gpuBuffer;\n    }\n\n    constructor(\n        array: NumberArrayType,\n        format: GPUVertexFormat | GPUIndexFormat,\n        itemSize: number,\n        normalized?: boolean\n    ) {\n        this._array = array;\n        this._format = format;\n        this._itemSize = itemSize;\n        this._parseFormat();\n        this._normalized = normalized ? normalized : this._normalized;\n    }\n\n    public update() {\n        if (this._gpuBuffer === undefined) {\n            this._gpuBuffer = new GPUBufferWrapper(this._usage | GPUBufferUsage.COPY_DST, this._array);\n        } else {\n            if (this.needsUpdate) {\n                this._gpuBuffer.update(this._array);\n                this.needsUpdate = false;\n            }\n        }\n    }\n\n    public getX(index: number) {\n        const x = this.array[index * this.itemSize];\n\n        return x;\n    }\n\n    public getY(index: number) {\n        const y = this.array[index * this.itemSize + 1];\n\n        return y;\n    }\n\n    public getZ(index: number) {\n        const z = this.array[index * this.itemSize + 2];\n\n        return z;\n    }\n\n    public getW(index: number) {\n        const w = this.array[index * this.itemSize + 3];\n\n        return w;\n    }\n\n    private _parseFormat() {\n        this._itemSize = this._itemSize;\n        this._byteLength = this._array.BYTES_PER_ELEMENT;\n        this._count = this._array.length / this._itemSize;\n    }\n\n    get format() {\n        return this._format;\n    }\n\n    get array(): NumberArrayType {\n        return this._array;\n    }\n\n    get count(): number {\n        return this._count;\n    }\n\n    set count(v: number) {\n        this._count = v;\n    }\n\n    get itemSize(): number {\n        return this._itemSize;\n    }\n\n    set itemSize(v: number) {\n        this._itemSize = v;\n    }\n\n    get byteLength() {\n        return this._byteLength;\n    }\n\n    get name(): string {\n        return this._name;\n    }\n\n    set name(v: string) {\n        this._name = v;\n    }\n\n    get needsUpdate(): boolean {\n        return this._needsUpdate;\n    }\n\n    set needsUpdate(v: boolean) {\n        this._needsUpdate = v;\n    }\n\n    set Usage(v: GPUFlagsConstant) {\n        this._usage = v;\n    }\n}\n","import { Box3 } from \"../math/Box3\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { Sphere } from \"../math/Sphere\";\nimport { Vector3 } from \"../math/Vector3\";\nimport { BufferAttribute } from \"./BufferAttribute\";\nimport { AttributeShaderItem } from \"./Defines\";\nimport { GPUBufferWrapper } from \"./GPUBufferWrapper\";\n\nconst _box = /*@__PURE__*/ new Box3();\nconst _vector = /*@__PURE__*/ new Vector3();\n\nexport class BufferGeometry {\n    private _attributes: Map<string, BufferAttribute> = new Map();\n    private _indices: BufferAttribute = null;\n    private _drawBuffer: GPUBufferWrapper = null;\n    private _boundingBox: Box3;\n    private _boundingSphere: Sphere;\n    public readonly uuid = MathUtils.generateUUID();\n\n    constructor() {}\n\n    public update() {\n        this.updateDrawBuffer();\n        for (const attribute of this._attributes.values()) {\n            attribute.update();\n        }\n\n        this._indices && this._indices.update();\n    }\n\n    public createVetexBufferLayouts() {\n        const bufferLayouts: Array<GPUVertexBufferLayout> = [];\n        let index = 0;\n        for (const attr of this.attributes.values()) {\n            const buffer = {\n                // 顶点长度，以字节为单位\n                arrayStride: attr.byteLength * attr.itemSize,\n                attributes: [\n                    {\n                        // 变量索引\n                        shaderLocation: index,\n                        // 偏移\n                        offset: 0,\n                        // 参数格式\n                        format: attr.format as GPUVertexFormat,\n                    },\n                ],\n            };\n            ++index;\n            bufferLayouts.push(buffer);\n        }\n        return bufferLayouts;\n    }\n\n    public setVertexBuffer(passEncoder: GPURenderPassEncoder, locationValues: Map<string, AttributeShaderItem>) {\n        for (const value of locationValues.values()) {\n            const attr = this._attributes.get(value.name);\n            if (attr) passEncoder.setVertexBuffer(value.index, attr.buffer.buffer);\n        }\n    }\n\n    public setIndex(attribute: BufferAttribute): BufferGeometry {\n        if (attribute.count !== this._indices?.count && this._drawBuffer) {\n            this._drawBuffer.destroy();\n            this._drawBuffer = null;\n        }\n\n        this._indices = attribute;\n        attribute.Usage = GPUBufferUsage.INDEX;\n        return this;\n    }\n\n    public setAttribute(name: string, attribute: BufferAttribute): BufferGeometry {\n        this._attributes.set(name, attribute);\n        return this;\n    }\n\n    public getAttribute(name: string): BufferAttribute {\n        return this._attributes.get(name);\n    }\n\n    public updateDrawBuffer() {\n        if (!this._drawBuffer) {\n            const k = this.indices ? 5 : 4;\n            const parameters = new Uint32Array(k);\n            if (this.indices) {\n                parameters[0] = this.indices.count; // The indexCount value\n                parameters[1] = 1; // The instanceCount value\n                parameters[2] = 0; // The firstIndex value\n                parameters[3] = 0; // The baseVertex value\n                parameters[4] = 0; // The firstInstance value\n            } else {\n                parameters[0] = this.getAttribute(\"position\").count; // The vertexCount value\n                parameters[1] = 1; // The instanceCount value\n                parameters[2] = 0; // The firstVertex value\n                parameters[3] = 0; // The firstInstance value\n            }\n            this._drawBuffer = new GPUBufferWrapper(GPUBufferUsage.COPY_DST | GPUBufferUsage.INDIRECT, parameters);\n        }\n    }\n\n    public computeBoundingSphere() {\n        if (this.boundingSphere === null) {\n            this._boundingSphere = new Sphere();\n        }\n\n        const position = this.attributes.get(\"position\");\n\n        if (position) {\n            console.error(\n                'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".',\n                this\n            );\n\n            this.boundingSphere.set(new Vector3(), Infinity);\n\n            return;\n        }\n\n        if (position) {\n            // first, find the center of the bounding sphere\n\n            const center = this.boundingSphere.center;\n\n            _box.setFromBufferAttribute(position);\n\n            _box.getCenter(center);\n\n            // second, try to find a boundingSphere with a radius smaller than the\n            // boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n            let maxRadiusSq = 0;\n\n            for (let i = 0, il = position.count; i < il; i++) {\n                _vector.fromBufferAttribute(position, i);\n\n                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n            }\n\n            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n            if (isNaN(this.boundingSphere.radius)) {\n                console.error(\n                    'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.',\n                    this\n                );\n            }\n        }\n    }\n\n    public computeBoundingBox() {\n        if (this._boundingBox === null) {\n            this._boundingBox = new Box3();\n        }\n\n        const position = this.attributes.get(\"position\");\n\n        if (position) {\n            console.error(\n                'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".',\n                this\n            );\n\n            this._boundingBox.set(\n                new Vector3(-Infinity, -Infinity, -Infinity),\n                new Vector3(+Infinity, +Infinity, +Infinity)\n            );\n\n            return;\n        }\n\n        if (position !== undefined) {\n            this._boundingBox.setFromBufferAttribute(position);\n        } else {\n            this._boundingBox.makeEmpty();\n        }\n\n        if (isNaN(this._boundingBox.min.x) || isNaN(this._boundingBox.min.y) || isNaN(this._boundingBox.min.z)) {\n            console.error(\n                'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.',\n                this\n            );\n        }\n    }\n\n    public get attributes() {\n        return this._attributes;\n    }\n\n    public get indices(): BufferAttribute {\n        return this._indices;\n    }\n\n    get drawBuffer(): GPUBufferWrapper {\n        return this._drawBuffer;\n    }\n\n    get boundingBox() {\n        if (this._boundingBox) {\n            this.computeBoundingBox();\n        }\n        return this._boundingBox;\n    }\n\n    get boundingSphere() {\n        if (this._boundingSphere) {\n            this.computeBoundingSphere();\n        }\n        return this._boundingSphere;\n    }\n}\n","/* eslint-disable no-unused-vars */\n\nimport { GPUBufferBindingType, GPUSamplerBindingType } from \"../Constants\";\n\nexport const BindGroupLayoutIndexInfo = {\n    global: 0,\n    material: 1,\n    object: 2,\n    custom: 3,\n};\n\nexport enum BindType {\n    buffer = 1,\n    storage = 2,\n    sampler = 3,\n    texture = 4,\n}\n\nexport interface ShaderItem {\n    name: string;\n    index: number;\n    shaderItemType: string;\n}\n\nexport interface AttributeShaderItem extends ShaderItem {\n    format: GPUVertexFormat;\n    itemSize: number;\n}\n\nexport interface BindShaderItem extends ShaderItem {\n    bindType: BindType;\n    visibility: GPUShaderStageFlags;\n}\n\nexport const ObjectGroupLayoutInfo = {\n    matrixWorld: {\n        index: 0,\n        bindType: BindType.buffer,\n        visibility: GPUShaderStage.VERTEX,\n    } as BindShaderItem,\n};\n\nexport function getLayoutEntity(item: BindShaderItem) {\n    if (item.bindType === BindType.buffer) {\n        return {\n            binding: item.index,\n            visibility: item.visibility,\n            buffer: {\n                type: GPUBufferBindingType.Uniform,\n            },\n        } as GPUBindGroupLayoutEntry;\n    } else if (item.bindType === BindType.sampler) {\n        return {\n            binding: item.index,\n            visibility: item.visibility,\n            sampler: {\n                type: GPUSamplerBindingType.Filtering,\n            },\n        } as GPUBindGroupLayoutEntry;\n    } else if (item.bindType === BindType.texture) {\n        return {\n            binding: item.index,\n            visibility: item.visibility,\n            texture: {},\n        } as GPUBindGroupLayoutEntry;\n    }\n}\n","import { Context } from \"./ResourceManagers\";\n\nexport class GPUBufferWrapper {\n    private _size: GPUSize64;\n    private _usage: GPUBufferUsageFlags;\n    public buffer: GPUBuffer;\n    constructor(usage: GPUBufferUsageFlags, data: any) {\n        this._size = data.byteLength;\n        this._usage = usage;\n        this.buffer = Context.activeDevice.createBuffer({\n            size: this._size,\n            usage: usage,\n            mappedAtCreation: true,\n        });\n\n        new data.constructor(this.buffer.getMappedRange()).set(data);\n        this.buffer.unmap();\n    }\n\n    public update(data: any) {\n        Context.activeDevice.queue.writeBuffer(this.buffer, 0, data);\n    }\n\n    public destroy() {\n        this.buffer.destroy();\n    }\n\n    public get size() {\n        return this._size;\n    }\n\n    public get usage() {\n        return this._usage;\n    }\n}\n","import { Quaternion } from \"../math/Quaternion\";\nimport { Vector3 } from \"../math/Vector3\";\nimport { Matrix4 } from \"../math/Matrix4\";\nimport { Euler } from \"../math/Euler\";\nimport * as MathUtils from \"../math/MathUtils\";\nimport { Color } from \"../math/Color\";\n\n//import { Scene } from './Scene';\n\nlet _object3DId = 0;\n\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _q1 = /*@__PURE__*/ new Quaternion();\nconst _m1 = /*@__PURE__*/ new Matrix4();\nconst _target = /*@__PURE__*/ new Vector3();\n\nconst _position = /*@__PURE__*/ new Vector3();\nconst _scale = /*@__PURE__*/ new Vector3();\nconst _quaternion = /*@__PURE__*/ new Quaternion();\n\nconst _xAxis = /*@__PURE__*/ new Vector3(1, 0, 0);\nconst _yAxis = /*@__PURE__*/ new Vector3(0, 1, 0);\nconst _zAxis = /*@__PURE__*/ new Vector3(0, 0, 1);\n\nexport class Object3D {\n    static DEFAULT_UP = /*@__PURE__*/ new Vector3(0, 1, 0);\n    static DEFAULT_MATRIX_AUTO_UPDATE = false;\n    static DEFAULT_MATRIX_WORLD_AUTO_UPDATE = false;\n\n    public get type() {\n        return \"Object3D\";\n    }\n\n    public static Is(object: Object3D) {\n        return object instanceof Object3D;\n    }\n\n    public readonly uuid = MathUtils.generateUUID();\n    public name: string;\n    public up: Vector3;\n\n    private _parent: Object3D;\n    private _children: Array<Object3D>;\n\n    private _position = new Vector3();\n    private _rotation = new Euler();\n    private _scale = new Vector3(1, 1, 1);\n    private _quaternion = new Quaternion();\n\n    public matrix = new Matrix4();\n    public matrixWorld = new Matrix4();\n\n    public matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;\n    public matrixWorldNeedsUpdate = false;\n\n    public matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer\n\n    public visible = true;\n\n    public castShadow = false;\n    public receiveShadow = false;\n\n    public frustumCulled = true;\n    public renderOrder = 0;\n\n    public userData: any = {};\n\n    public isInstancedMesh = false;\n    public count = 0;\n    public instanceMatrix: Matrix4;\n    public instanceColor: Color;\n\n    constructor() {\n        Object.defineProperty(this, \"id\", { value: _object3DId++ });\n\n        this.name = \"\";\n\n        this._parent = null;\n        this._children = [];\n\n        this.up = Object3D.DEFAULT_UP.clone();\n\n        const onRotationChange = (e: Euler) => {\n            this.quaternion.setFromEuler(e, false);\n        };\n\n        const onQuaternionChange = (q: Quaternion) => {\n            this.rotation.setFromQuaternion(q, undefined, false);\n        };\n        this._rotation.onChange(onRotationChange);\n        this._quaternion.onChange(onQuaternionChange);\n    }\n\n    onBeforeRender(/* renderer, scene, camera, geometry, material, group */) {}\n\n    onAfterRender(/* renderer, scene, camera, geometry, material, group */) {}\n\n    applyMatrix4(matrix: Matrix4) {\n        if (this.matrixAutoUpdate) this.updateMatrix();\n\n        this.matrix.premultiply(matrix);\n\n        this.matrix.decompose(this._position, this._quaternion, this._scale);\n    }\n\n    applyQuaternion(q: Quaternion) {\n        this._quaternion.premultiply(q);\n\n        return this;\n    }\n\n    setRotationFromAxisAngle(axis: Vector3, angle: number) {\n        // assumes axis is normalized\n\n        this._quaternion.setFromAxisAngle(axis, angle);\n    }\n\n    setRotationFromEuler(euler: Euler) {\n        this._quaternion.setFromEuler(euler);\n    }\n\n    setRotationFromMatrix(m: Matrix4) {\n        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        this._quaternion.setFromRotationMatrix(m);\n    }\n\n    setRotationFromQuaternion(q: Quaternion) {\n        // assumes q is normalized\n\n        this._quaternion.copy(q);\n    }\n\n    rotateOnAxis(axis: Vector3, angle: number) {\n        // rotate object on axis in object space\n        // axis is assumed to be normalized\n\n        _q1.setFromAxisAngle(axis, angle);\n\n        this._quaternion.multiply(_q1);\n\n        return this;\n    }\n\n    rotateOnWorldAxis(axis: Vector3, angle: number) {\n        // rotate object on axis in world space\n        // axis is assumed to be normalized\n        // method assumes no rotated parent\n\n        _q1.setFromAxisAngle(axis, angle);\n\n        this._quaternion.premultiply(_q1);\n\n        return this;\n    }\n\n    rotateX(angle: number) {\n        return this.rotateOnAxis(_xAxis, angle);\n    }\n\n    rotateY(angle: number) {\n        return this.rotateOnAxis(_yAxis, angle);\n    }\n\n    rotateZ(angle: number) {\n        return this.rotateOnAxis(_zAxis, angle);\n    }\n\n    translateOnAxis(axis: Vector3, distance: number) {\n        // translate object by distance along axis in object space\n        // axis is assumed to be normalized\n\n        _v1.copy(axis).applyQuaternion(this._quaternion);\n\n        this._position.add(_v1.multiplyScalar(distance));\n\n        return this;\n    }\n\n    translateX(distance: number) {\n        return this.translateOnAxis(_xAxis, distance);\n    }\n\n    translateY(distance: number) {\n        return this.translateOnAxis(_yAxis, distance);\n    }\n\n    translateZ(distance: number) {\n        return this.translateOnAxis(_zAxis, distance);\n    }\n\n    localToWorld(vector: Vector3) {\n        this.updateWorldMatrix(true, false);\n\n        return vector.applyMatrix4(this.matrixWorld);\n    }\n\n    worldToLocal(vector: Vector3) {\n        this.updateWorldMatrix(true, false);\n\n        return vector.applyMatrix4(_m1.copy(this.matrixWorld).invert());\n    }\n\n    lookAt(target: Vector3) {\n        // This method does not support objects having non-uniformly-scaled parent(s)\n\n        _target.copy(target);\n\n        const parent = this.parent;\n\n        this.updateWorldMatrix(true, false);\n\n        _position.setFromMatrixPosition(this.matrixWorld);\n\n        if ((this as any).isCamera || (this as any).isLight) {\n            _m1.lookAt(_position, _target, this.up);\n        } else {\n            _m1.lookAt(_target, _position, this.up);\n        }\n\n        this._quaternion.setFromRotationMatrix(_m1);\n\n        if (parent) {\n            _m1.extractRotation(parent.matrixWorld);\n            _q1.setFromRotationMatrix(_m1);\n            this._quaternion.premultiply(_q1.invert());\n        }\n    }\n\n    add(object: Object3D) {\n        if (object === this) {\n            console.error(\"THREE.Object3D.add: object can't be added as a child of itself.\", object);\n            return this;\n        }\n\n        if ((object as any).isScene) {\n            console.error(\"THREE.Object3D.add: scene can't be added.\", object);\n            return this;\n        }\n\n        if (object.parent !== null) {\n            object.parent.remove(object);\n        }\n\n        object._parent = this;\n        this.children.push(object);\n\n        object.traverseAncestors((parent) => {\n            if ((parent as any).isScene) (parent as any).handleAdded(object);\n        });\n\n        return this;\n    }\n\n    remove(object: Object3D) {\n        const index = this.children.indexOf(object);\n\n        if (index !== -1) {\n            object._parent = null;\n            this.children.splice(index, 1);\n        }\n\n        object.traverseAncestors((parent) => {\n            if ((parent as any).isScene) (parent as any)._handleRemoved(object);\n        });\n\n        return this;\n    }\n\n    removeFromParent() {\n        const parent = this.parent;\n\n        if (parent !== null) {\n            parent.remove(this);\n        }\n\n        return this;\n    }\n\n    clear() {\n        for (let i = 0; i < this.children.length; i++) {\n            const object = this.children[i];\n\n            object._parent = null;\n        }\n\n        this.children.length = 0;\n\n        return this;\n    }\n\n    attach(object: Object3D) {\n        // adds object as a child of this, while maintaining the object's world transform\n\n        // Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)\n\n        this.updateWorldMatrix(true, false);\n\n        _m1.copy(this.matrixWorld).invert();\n\n        if (object.parent !== null) {\n            object.parent.updateWorldMatrix(true, false);\n\n            _m1.multiply(object.parent.matrixWorld);\n        }\n\n        object.applyMatrix4(_m1);\n\n        this.add(object);\n\n        object.updateWorldMatrix(false, true);\n\n        return this;\n    }\n\n    getWorldPosition(target: Vector3) {\n        this.updateWorldMatrix(true, false);\n\n        return target.setFromMatrixPosition(this.matrixWorld);\n    }\n\n    getWorldQuaternion(target: Quaternion) {\n        this.updateWorldMatrix(true, false);\n\n        this.matrixWorld.decompose(_position, target, _scale);\n\n        return target;\n    }\n\n    getWorldScale(target: Vector3) {\n        this.updateWorldMatrix(true, false);\n\n        this.matrixWorld.decompose(_position, _quaternion, target);\n\n        return target;\n    }\n\n    getWorldDirection(target: Vector3) {\n        this.updateWorldMatrix(true, false);\n\n        const e = this.matrixWorld.elements;\n\n        return target.set(e[8], e[9], e[10]).normalize();\n    }\n\n    raycast(/* raycaster, intersects */) {}\n\n    traverse(callback: (object: Object3D) => void) {\n        callback(this);\n\n        const children = this.children;\n\n        for (let i = 0, l = children.length; i < l; i++) {\n            children[i].traverse(callback);\n        }\n    }\n\n    traverseVisible(callback: (object: Object3D) => void) {\n        if (this.visible === false) return;\n\n        callback(this);\n\n        const children = this.children;\n\n        for (let i = 0, l = children.length; i < l; i++) {\n            children[i].traverseVisible(callback);\n        }\n    }\n\n    traverseAncestors(callback: (object: Object3D) => void) {\n        const parent = this.parent;\n\n        if (parent !== null) {\n            callback(parent);\n\n            parent.traverseAncestors(callback);\n        }\n    }\n\n    updateMatrix() {\n        this.matrix.compose(this._position, this._quaternion, this._scale);\n\n        this.matrixWorldNeedsUpdate = true;\n    }\n\n    updateMatrixWorld() {\n        if (this.matrixAutoUpdate) this.updateMatrix();\n\n        if (this.matrixWorldNeedsUpdate) {\n            if (this.parent === null) {\n                this.matrixWorld.copy(this.matrix);\n            } else {\n                this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n            }\n\n            this.matrixWorldNeedsUpdate = false;\n        }\n\n        // update children\n\n        const children = this.children;\n\n        for (let i = 0, l = children.length; i < l; i++) {\n            const child = children[i];\n\n            if (child.matrixWorldAutoUpdate === true) {\n                child.updateMatrixWorld();\n            }\n        }\n    }\n\n    updateWorldMatrix(updateParents = false, updateChildren = false) {\n        const parent = this.parent;\n\n        if (updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true) {\n            parent.updateWorldMatrix(true, false);\n        }\n\n        if (this.matrixAutoUpdate) this.updateMatrix();\n\n        if (this.parent === null) {\n            this.matrixWorld.copy(this.matrix);\n        } else {\n            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n        }\n\n        // update children\n\n        if (updateChildren === true) {\n            const children = this.children;\n\n            for (let i = 0, l = children.length; i < l; i++) {\n                const child = children[i];\n\n                if (child.matrixWorldAutoUpdate === true) {\n                    child.updateWorldMatrix(false, true);\n                }\n            }\n        }\n    }\n\n    clone(recursive = false) {\n        return new Object3D().copy(this, recursive);\n    }\n\n    copy(source: Object3D, recursive = true) {\n        this.name = source.name;\n\n        this.up.copy(source.up);\n\n        this._position.copy(source._position);\n        this._rotation.order = source._rotation.order;\n        this._quaternion.copy(source._quaternion);\n        this._scale.copy(source._scale);\n\n        this.matrix.copy(source.matrix);\n        this.matrixWorld.copy(source.matrixWorld);\n\n        this.matrixAutoUpdate = source.matrixAutoUpdate;\n        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n        this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;\n\n        this.visible = source.visible;\n\n        this.castShadow = source.castShadow;\n        this.receiveShadow = source.receiveShadow;\n\n        this.frustumCulled = source.frustumCulled;\n        this.renderOrder = source.renderOrder;\n\n        this.userData = JSON.parse(JSON.stringify(source.userData));\n\n        if (recursive === true) {\n            for (let i = 0; i < source.children.length; i++) {\n                const child = source.children[i];\n                this.add(child.clone());\n            }\n        }\n\n        return this;\n    }\n    public get parent() {\n        return this._parent;\n    }\n\n    public get children() {\n        return this._children;\n    }\n\n    public set position(v: Vector3) {\n        this._position.copy(v);\n    }\n\n    public get position() {\n        return this._position;\n    }\n\n    public set scale(v: Vector3) {\n        this._scale.copy(v);\n    }\n\n    public get scale() {\n        return this._scale;\n    }\n\n    public get quaternion() {\n        return this._quaternion;\n    }\n\n    public set quaternion(v: Quaternion) {\n        this._quaternion.copy(v);\n        this._rotation.setFromQuaternion(v, undefined);\n    }\n\n    public get rotation() {\n        return this._rotation;\n    }\n\n    public set rotation(v: Euler) {\n        this._rotation.copy(v);\n        this._quaternion.setFromEuler(v);\n    }\n}\n","import { GPUBlendFactor, GPUCompareFunction, GPUCullMode, GPUPrimitiveTopology, GPUTextureFormat } from \"../Constants\";\nimport { Material } from \"../materials/Material\";\nimport { WebGPURenderer } from \"../renderers/WebGPURenderer\";\nimport { BindGroupLayoutIndexInfo, ObjectGroupLayoutInfo } from \"./Defines\";\nimport { RenderableObject } from \"./RenderableObject\";\nimport { Cache, Context } from \"./ResourceManagers\";\nimport { Scene } from \"./Scene\";\n\nexport class Pipleline {\n    private _material: Material;\n    private _pipeline: GPURenderPipeline;\n\n    private _bindGroupLayouts: Array<GPUBindGroupLayout> = [];\n    private _vertexBufferLayouts: Array<GPUVertexBufferLayout> = [];\n\n    private _globalBindGroups: GPUBindGroup;\n    private _materialBindGroup: GPUBindGroup;\n    private _objectBindGroups: any = {};\n\n    public needsCompile = true;\n    public needsCreateMatBindGroup = true;\n\n    constructor(material: Material) {\n        this._material = material;\n\n        Cache.add(\"pipelineObjectBindGroup\", this._objectBindGroups);\n    }\n\n    public compilePipeline(renderer: WebGPURenderer, scene: Scene) {\n        if (!this.needsCompile) return;\n\n        this.needsCreateMatBindGroup = true;\n\n        this._beforeCompile(scene);\n        this._compile(renderer, scene);\n\n        this.needsCompile = false;\n    }\n\n    public bindCommonUniform(passEncoder: GPURenderPassEncoder) {\n        passEncoder.setBindGroup(0, this._globalBindGroups);\n        passEncoder.setBindGroup(1, this._materialBindGroup);\n    }\n\n    public bindObjectUnform(passEncoder: GPURenderPassEncoder, object: RenderableObject) {\n        passEncoder.setBindGroup(2, this._objectBindGroups[object.uuid]);\n    }\n\n    private _compile(renderer: WebGPURenderer, scene: Scene) {\n        const device = renderer.device;\n        this.material.shader.recreate(scene);\n\n        this._pipeline = device.createRenderPipeline({\n            layout: device.createPipelineLayout({\n                bindGroupLayouts: [...this._bindGroupLayouts],\n            }),\n            vertex: {\n                module: device.createShaderModule({\n                    code: this.material.shader.vertexShaderCode,\n                }),\n                entryPoint: \"main\",\n                buffers: this._vertexBufferLayouts,\n            },\n            fragment: {\n                module: device.createShaderModule({\n                    code: this.material.shader.fragmentShaderCode,\n                }),\n                entryPoint: \"main\",\n                targets: [\n                    {\n                        format: renderer.presentationFormat,\n                        blend: {\n                            color: {\n                                srcFactor: GPUBlendFactor.SrcAlpha,\n                                dstFactor: GPUBlendFactor.OneMinusSrcAlpha,\n                            },\n                            alpha: {\n                                srcFactor: GPUBlendFactor.One,\n                                dstFactor: GPUBlendFactor.OneMinusSrcAlpha,\n                            },\n                        },\n                    },\n                ],\n            },\n            primitive: {\n                topology: GPUPrimitiveTopology.TriangleList,\n                cullMode: GPUCullMode.Back,\n            },\n            multisample: {\n                count: renderer.sampleCount,\n            },\n            depthStencil: {\n                depthWriteEnabled: true,\n                depthCompare: GPUCompareFunction.Less,\n                format: GPUTextureFormat.Depth24Plus,\n            },\n        });\n    }\n\n    /****************************create layout start ***********************************/\n    private _createVertexBufferLayouts() {\n        this._vertexBufferLayouts.length = 0;\n\n        for (const value of this._material.shaderOptions.attributeValues.values()) {\n            this._vertexBufferLayouts.push({\n                arrayStride: value.itemSize,\n                attributes: [\n                    {\n                        shaderLocation: value.index,\n                        offset: 0,\n                        format: value.format,\n                    },\n                ],\n            });\n        }\n    }\n\n    private _createGlobalBindLayout(scene: Scene) {\n        const entries = scene.getBindLayout();\n        this._bindGroupLayouts.push(\n            Context.activeDevice.createBindGroupLayout({\n                entries: entries,\n            })\n        );\n    }\n\n    private _createMaterialBindLayout() {\n        const entries = this.material.getBindLayout();\n        this._bindGroupLayouts.push(\n            Context.activeDevice.createBindGroupLayout({\n                entries: entries,\n            })\n        );\n    }\n\n    private _createObjectBindLayout() {\n        const entries = new Array<GPUBindGroupLayoutEntry>();\n        for (const key in ObjectGroupLayoutInfo) {\n            entries.push({\n                binding: (ObjectGroupLayoutInfo as any)[key].index,\n                visibility: (ObjectGroupLayoutInfo as any)[key].visibility,\n                buffer: {\n                    type: \"uniform\",\n                },\n            });\n        }\n        this._bindGroupLayouts.push(\n            Context.activeDevice.createBindGroupLayout({\n                entries: entries,\n            })\n        );\n    }\n\n    private _createBindLayouts(scene: Scene) {\n        this._bindGroupLayouts.length = 0;\n        this._createGlobalBindLayout(scene); //Layout 0\n        this._createMaterialBindLayout(); //Layout 1\n        this._createObjectBindLayout(); //Layout 2\n    }\n\n    /****************************create layout end ***********************************/\n\n    /****************************create group start ***********************************/\n    private _createGlobalBindGroup(scene: Scene) {\n        if (!this.needsCreateMatBindGroup) return;\n\n        const group = scene.getBindGroup();\n\n        this._globalBindGroups = Context.activeDevice.createBindGroup({\n            layout: this.pipeline.getBindGroupLayout(BindGroupLayoutIndexInfo.global),\n            entries: group,\n        });\n    }\n\n    private _createMaterialBindGroup() {\n        if (!this.needsCreateMatBindGroup) return;\n        const group = this.material.getBindGroup();\n\n        this._materialBindGroup = Context.activeDevice.createBindGroup({\n            layout: this.pipeline.getBindGroupLayout(BindGroupLayoutIndexInfo.material),\n            entries: group,\n        });\n    }\n\n    public createObjectBindGroup(object: RenderableObject) {\n        if (this._objectBindGroups[object.uuid]) {\n            return;\n        }\n\n        const group = new Array<GPUBindGroupEntry>();\n        for (const key in ObjectGroupLayoutInfo) {\n            group.push({\n                binding: (ObjectGroupLayoutInfo as any)[key].index,\n                resource: {\n                    buffer: object.uniforms.get(key).buffer,\n                },\n            });\n        }\n        this._objectBindGroups[object.uuid] = Context.activeDevice.createBindGroup({\n            layout: this.pipeline.getBindGroupLayout(BindGroupLayoutIndexInfo.object),\n            entries: group,\n        });\n    }\n\n    public createCommonBindGroups(scene: Scene) {\n        this._createGlobalBindGroup(scene); //Group 0\n        this._createMaterialBindGroup(); //Group 1\n\n        this.needsCreateMatBindGroup = false;\n    }\n\n    /****************************create group end ***********************************/\n    private _beforeCompile(scene: Scene) {\n        this._createBindLayouts(scene);\n        this._createVertexBufferLayouts();\n    }\n\n    public get pipeline() {\n        return this._pipeline;\n    }\n\n    public get material() {\n        return this._material;\n    }\n}\n","import { BufferGeometry } from \"./BufferGeometry\";\nimport { Material } from \"../materials/Material\";\nimport { Object3D } from \"./Object3D\";\nimport { BindBuffer } from \"./binds/BindBuffer\";\nimport { IdentifyMatrix4 } from \"../utils/TempValues\";\nimport { Box3 } from \"../math/Box3\";\nimport { Sphere } from \"../math/Sphere\";\n\nconst u_modelTranform = \"matrixWorld\";\nexport class RenderableObject extends Object3D {\n    public get type() {\n        return \"RenderableObject\";\n    }\n\n    public static Is(object: Object3D) {\n        return object instanceof RenderableObject;\n    }\n\n    public get isRenderableObject() {\n        return true;\n    }\n\n    protected _geometry: BufferGeometry;\n    protected _material: Material;\n\n    private _pipeline: GPURenderPipeline;\n    private _uniforms: Map<string, BindBuffer> = new Map();\n\n    private _boundingBox: Box3;\n    private _boundingSphere: Sphere;\n\n    constructor(geometry: BufferGeometry, material: Material) {\n        super();\n        this._geometry = geometry;\n        this._material = material;\n\n        this._initInitialUniform();\n    }\n\n    public update() {\n        this.updateMatrixWorld();\n\n        this._updateUniformValue();\n    }\n\n    public override updateMatrixWorld() {\n        const needsUpdate = this.matrixWorldNeedsUpdate;\n        super.updateMatrixWorld();\n\n        if (needsUpdate) {\n            this._uniforms.get(u_modelTranform).data = this.matrixWorld.toArray();\n        }\n    }\n\n    private _initInitialUniform() {\n        const tranformUniform = new BindBuffer(IdentifyMatrix4.toArray());\n        this._uniforms.set(u_modelTranform, tranformUniform);\n    }\n\n    private _updateUniformValue() {\n        for (const uniform of this._uniforms.values()) {\n            uniform.update();\n        }\n    }\n\n    public computeBoundingSphere() {\n        this._boundingSphere.copy(this.geometry.boundingSphere);\n        this._boundingSphere.applyMatrix4(this.matrixWorld);\n    }\n\n    public computeBoundingBox() {\n        this._boundingBox.copy(this.geometry.boundingBox);\n        this._boundingBox.applyMatrix4(this.matrixWorld);\n    }\n\n    public get pipeline() {\n        return this._pipeline;\n    }\n\n    get geometry() {\n        return this._geometry;\n    }\n\n    get material() {\n        return this._material;\n    }\n\n    get uniforms() {\n        return this._uniforms;\n    }\n\n    get boundingBox() {\n        return this._boundingBox;\n    }\n\n    get boundingSphere() {\n        return this._boundingSphere;\n    }\n}\n","import { GPUTextureFormat } from \"../Constants\";\n\nexport class Cache {\n    public static enabled = false;\n\n    static caches: any = {};\n\n    public static add(key: string, obj: any) {\n        if (this.enabled === false) return;\n\n        // console.log( 'THREE.Cache', 'Adding key:', key );\n\n        this.caches[key] = obj;\n    }\n\n    public static get(key: string) {\n        if (this.enabled === false) return;\n\n        // console.log( 'THREE.Cache', 'Checking key:', key );\n\n        return this.caches[key];\n    }\n\n    public static remove(key: string) {\n        delete this.caches[key];\n    }\n\n    public static clear() {\n        this.caches = {};\n    }\n}\n\nexport class Context {\n    private static _activeDevice: GPUDevice;\n    public static get activeDevice(): GPUDevice {\n        return Context._activeDevice;\n    }\n    public static set activeDevice(v: GPUDevice) {\n        Context._activeDevice = v;\n    }\n\n    private static _textureFormat: GPUTextureFormat = GPUTextureFormat.BGRA8Unorm;\n    public static get textureFormat() {\n        return Context._textureFormat;\n    }\n    public static set textureFormat(v: GPUTextureFormat) {\n        Context._textureFormat = v;\n    }\n\n    private static _commandEncoder: GPUCommandEncoder;\n    public static get commandEncoder() {\n        if (!Context._commandEncoder) {\n            Context._commandEncoder = Context._activeDevice.createCommandEncoder();\n        }\n\n        return Context._commandEncoder;\n    }\n}\n\nexport class DelayDestroyer {\n    public static delayTime = 5000;\n\n    public static destroy(garbage: any, destroyFunc: (g: any) => void, time = DelayDestroyer.delayTime) {\n        setTimeout(() => {\n            destroyFunc(garbage);\n        }, time);\n    }\n}\n","import { Camera } from \"../cameras/Camera\";\nimport { DirectionalLight } from \"../lights/DirectionalLight\";\nimport { Material } from \"../materials/Material\";\nimport { CommonUtils } from \"../utils/CommonUtils\";\nimport { BindShaderItem, BindType, getLayoutEntity } from \"./Defines\";\nimport { Object3D } from \"./Object3D\";\nimport { RenderableObject } from \"./RenderableObject\";\nimport { BindBuffer } from \"./binds/BindBuffer\";\n\nconst t_cameraBindValue = [\n    {\n        name: \"projectionMatrix\",\n        index: 0,\n        shaderItemType: \"mat4x4<f32>\",\n        bindType: BindType.buffer,\n        visibility: GPUShaderStage.VERTEX,\n    },\n    {\n        name: \"matrixWorldInverse\",\n        index: 1,\n        shaderItemType: \"mat4x4<f32>\",\n        bindType: BindType.buffer,\n        visibility: GPUShaderStage.VERTEX,\n    },\n];\n\nexport class Scene extends Object3D {\n    public get type() {\n        return \"Scene\";\n    }\n\n    public static Is(object: Object3D) {\n        return object instanceof Scene;\n    }\n\n    public get isScene() {\n        return true;\n    }\n\n    private _renderableObjects = new Map<Material, Array<RenderableObject>>();\n\n    private _directionalLights = new Map<string, DirectionalLight>();\n    private _directionalLightBuffer: BindBuffer;\n    private _bindValues = new Map<string, BindShaderItem>();\n    private _entriesLayout = new Array<GPUBindGroupLayoutEntry>();\n    private _entriesGroup = new Array<GPUBindGroupEntry>();\n    private _lastSetCamera: Camera = null;\n    public needsRecreateBind = true;\n\n    constructor() {\n        super();\n    }\n\n    public update(camrea: Camera): boolean {\n        this._lastSetCamera = camrea;\n\n        if (this.needsRecreateBind) {\n            this._createLayout();\n            this._createBindGroup();\n            this.needsRecreateBind = false;\n            return true;\n        } else {\n            this._updateLightsUniform();\n        }\n        return false;\n    }\n\n    public getBindLayout() {\n        return this._entriesLayout;\n    }\n\n    public getBindGroup() {\n        return this._entriesGroup;\n    }\n\n    public handleAdded(object: Object3D) {\n        object.traverse((child) => {\n            if (RenderableObject.Is(child)) {\n                this._addRenderableObject(child as RenderableObject);\n            } else if (DirectionalLight.Is(child)) {\n                this._addDirectionalLight(child as DirectionalLight);\n            }\n        });\n    }\n\n    public handleRemoved(object: Object3D) {\n        object.traverse((child) => {\n            if (RenderableObject.Is(child)) {\n                this._removeRenderableObject(child as RenderableObject);\n            } else if (DirectionalLight.Is(child)) {\n                this._removeDirectionalLight(child as DirectionalLight);\n            }\n        });\n    }\n\n    private _createBindGroup() {\n        this._entriesGroup.length = 0;\n        this._entriesGroup.push({\n            binding: 0,\n            resource: {\n                buffer: this._lastSetCamera.uniforms.get(\"projectionMatrix\").buffer,\n            },\n        });\n        this._entriesGroup.push({\n            binding: 1,\n            resource: {\n                buffer: this._lastSetCamera.uniforms.get(\"matrixWorldInverse\").buffer,\n            },\n        });\n\n        if (this._directionalLights.size > 0) {\n            this._entriesGroup.push({\n                binding: 2,\n                resource: {\n                    buffer: this._directionalLightBuffer.buffer,\n                },\n            });\n        }\n    }\n\n    private _updateLightsUniform() {\n        const dirLightsBuffer = new Float32Array(8 * this._directionalLights.size);\n        let offset = 0;\n        let needsUpdate = false;\n        for (const dirLight of this._directionalLights.values()) {\n            if (dirLight.needsUpdate) {\n                needsUpdate = true;\n                dirLight.update();\n            }\n\n            dirLightsBuffer.set(dirLight.color.toArray(), offset);\n            offset += 4;\n\n            const normal = dirLight.direction;\n            dirLightsBuffer.set(normal.toArray(), offset);\n            offset += 4;\n        }\n\n        if (needsUpdate) {\n            this._directionalLightBuffer.data = dirLightsBuffer;\n            this._directionalLightBuffer.update();\n        }\n    }\n\n    private _createLayout() {\n        this._bindValues.clear();\n        this._entriesLayout.length = 0;\n        for (const cameraBind of t_cameraBindValue) {\n            this._bindValues.set(cameraBind.name, cameraBind);\n        }\n\n        if (this._directionalLights.size > 0) {\n            this._bindValues.set(\"directionalLights\", {\n                name: \"directionalLights\",\n                index: this._bindValues.size,\n                shaderItemType: `array<DirectionalLight,${this._directionalLights.size}>`,\n                bindType: BindType.buffer,\n                visibility: GPUShaderStage.FRAGMENT,\n            });\n            if (this._directionalLightBuffer) this._directionalLightBuffer.destroy();\n\n            const arrayBuffer = new Float32Array(8 * this._directionalLights.size);\n            let offset = 0;\n            for (const dirLight of this._directionalLights.values()) {\n                arrayBuffer.set(dirLight.color.toArray(), offset);\n                offset += 4;\n\n                const normal = dirLight.direction;\n                arrayBuffer.set(normal.toArray(), offset);\n                offset += 4;\n            }\n            this._directionalLightBuffer = new BindBuffer(arrayBuffer);\n        }\n\n        for (const bindOption of this._bindValues.values()) {\n            const entity = getLayoutEntity(bindOption);\n            this._entriesLayout.push(entity);\n        }\n    }\n\n    private _addRenderableObject(renderableObj: RenderableObject) {\n        const material = renderableObj.material;\n        const objs = this._renderableObjects.get(material);\n        if (objs) {\n            objs.push(renderableObj);\n        } else {\n            this._renderableObjects.set(material, []);\n            this._renderableObjects.get(material).push(renderableObj);\n        }\n    }\n\n    private _removeRenderableObject(renderableObj: RenderableObject) {\n        const material = renderableObj.material;\n        const arr = this._renderableObjects.get(material);\n        if (arr) {\n            CommonUtils.removeArrayItemByValue(arr, renderableObj);\n        }\n    }\n\n    private _addDirectionalLight(light: DirectionalLight) {\n        this._directionalLights.set(light.uuid, light);\n        this.needsRecreateBind = true;\n    }\n\n    private _removeDirectionalLight(light: DirectionalLight) {\n        this._directionalLights.delete(light.uuid);\n        this.needsRecreateBind = true;\n    }\n\n    public get renderableObjs() {\n        return this._renderableObjects;\n    }\n    public get directionalLights() {\n        return this._directionalLights;\n    }\n\n    public get bindValues() {\n        return this._bindValues;\n    }\n}\n","import { NumberArrayType } from \"../../Constants\";\nimport { BindType } from \"../Defines\";\nimport { GPUBufferWrapper } from \"../GPUBufferWrapper\";\nimport { DelayDestroyer } from \"../ResourceManagers\";\nimport { BindValue } from \"./BindValue\";\n\nexport class BindBuffer extends BindValue {\n    private _buffer: GPUBufferWrapper;\n    private _data: NumberArrayType;\n\n    constructor(data: NumberArrayType) {\n        super();\n        this._buffer = new GPUBufferWrapper(GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, data);\n        this._data = data;\n    }\n\n    public override destroy(): void {\n        this._buffer.destroy();\n    }\n\n    public override get type() {\n        return BindType.buffer;\n    }\n\n    public set data(v: NumberArrayType) {\n        this._needsUpdate = true;\n        this._data = v;\n    }\n\n    public override update() {\n        if (this._needsUpdate) {\n            if (this._data.byteLength !== this._buffer.size) {\n                DelayDestroyer.destroy(this._buffer, (data) => {\n                    data.destroy();\n                });\n                this._buffer = new GPUBufferWrapper(GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, this._data);\n            } else {\n                this._buffer.update(this._data);\n            }\n\n            this._needsUpdate = false;\n        }\n    }\n\n    public get buffer() {\n        return this._buffer.buffer;\n    }\n}\n","import { GPUAddressMode, GPUFilterMode, GPUMipmapFilterMode } from \"../../Constants\";\nimport { Texture } from \"../../textures/Texture\";\nimport { BindType } from \"../Defines\";\nimport { Context } from \"../ResourceManagers\";\nimport { BindValue } from \"./BindValue\";\n\nexport class BindSampler extends BindValue {\n    private _sampler: GPUSampler;\n\n    constructor(texture: Texture) {\n        super();\n\n        this._sampler = Context.activeDevice.createSampler({\n            addressModeU: texture.wrapU,\n            addressModeV: texture.wrapV,\n            addressModeW: texture.wrapW,\n            magFilter: texture.magFilter,\n            minFilter: texture.minFilter,\n            mipmapFilter: texture.mipmapFilter,\n            maxAnisotropy: texture.anisotropy,\n        });\n    }\n\n    public override get type() {\n        return BindType.sampler;\n    }\n\n    public get sampler() {\n        return this._sampler;\n    }\n}\n","import { Texture } from \"../../textures/Texture\";\nimport { TextureMipmapGenerator } from \"../../textures/TextureMipmapGenerator\";\nimport { BindType } from \"../Defines\";\nimport { Context, DelayDestroyer } from \"../ResourceManagers\";\nimport { BindValue } from \"./BindValue\";\n\nexport class BindTexture extends BindValue {\n    private _texture: Texture;\n    private _gpuTexture: GPUTexture;\n    private _gpuTexutureView: GPUTextureView;\n\n    private _width: number;\n    private _height: number;\n\n    constructor(texture: Texture, mipmapSize = 0) {\n        super();\n\n        this._texture = texture;\n        createImageBitmap(this._texture.image).then((imageBitmap: ImageBitmap) => {\n            this._width = imageBitmap.width;\n            this._height = imageBitmap.height;\n            this._gpuTexture = Context.activeDevice.createTexture({\n                size: [this._width, this._height, 1],\n                mipLevelCount: mipmapSize,\n                format: \"rgba8unorm\",\n                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n            });\n\n            Context.activeDevice.queue.copyExternalImageToTexture(\n                { source: imageBitmap },\n                { texture: this._gpuTexture },\n                [this._width, this._height]\n            );\n            if (mipmapSize > 1) {\n                TextureMipmapGenerator.webGPUGenerateMipmap(texture);\n            }\n            this._gpuTexutureView = this._gpuTexture.createView();\n        });\n        this._needsUpdate = false;\n    }\n\n    public override update() {\n        if (this._needsUpdate) {\n            createImageBitmap(this._texture.image).then((imageBitmap: ImageBitmap) => {\n                if (imageBitmap.width !== this._width || imageBitmap.height !== this._height) {\n                    console.warn(\"new image size must equal with texture,or you should create new texture!\");\n                }\n                // DelayDestroyer.destroy(this._textureBuffer,(data)=>{\n                //     data.destroy();\n                // });\n\n                // this._textureBuffer = Context.activeDevice.createTexture({\n                //     size: [imageBitmap.width, imageBitmap.height, 1],\n                //     format: \"rgba8unorm\",\n                //     usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n                // });\n                Context.activeDevice.queue.writeTexture(\n                    { texture: this._gpuTexture },\n                    new Uint8Array([0, 0, 0, 0]),\n                    { bytesPerRow: 4 * 4 },\n                    [1, 1]\n                );\n                Context.activeDevice.queue.copyExternalImageToTexture(\n                    { source: imageBitmap },\n                    { texture: this._gpuTexture },\n                    [imageBitmap.width, imageBitmap.height]\n                );\n                //this._texutureView = this._textureBuffer.createView();\n                // this.changed = true;\n            });\n\n            this._needsUpdate = false;\n        }\n    }\n\n    public override destroy(): void {\n        DelayDestroyer.destroy(this._gpuTexture, (data) => {\n            data.destroy();\n        });\n    }\n\n    public set texture(v: Texture) {\n        if (v !== this._texture) {\n            this._needsUpdate = true;\n            this._texture = v;\n        }\n    }\n\n    public get texture() {\n        return this._texture;\n    }\n\n    public override get type() {\n        return BindType.texture;\n    }\n\n    public get gpuTexutureView() {\n        return this._gpuTexutureView;\n    }\n\n    public get gpuTexture() {\n        return this._gpuTexture;\n    }\n\n    public get width() {\n        return this._width;\n    }\n    public get height() {\n        return this._height;\n    }\n}\n","import { BindType } from \"../Defines\";\n\nexport abstract class BindValue {\n    private _name: string;\n\n    protected _needsUpdate = true;\n\n    constructor() {}\n\n    public abstract get type(): BindType;\n\n    public destroy() {}\n\n    public update() {}\n\n    public get name() {\n        return this._name;\n    }\n}\n","import { GPUIndexFormat, GPUVertexFormat } from \"../Constants\";\nimport { BufferAttribute } from \"../core/BufferAttribute\";\nimport { BufferGeometry } from \"../core/BufferGeometry\";\nimport { Vector3 } from \"../math/Vector3\";\n\nexport class BoxGeometry extends BufferGeometry {\n    public width: number;\n    public height: number;\n    public depth: number;\n    public widthSegments: number;\n    public heightSegments: number;\n    public depthSegments: number;\n\n    constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {\n        super();\n\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n        this.widthSegments = widthSegments;\n        this.heightSegments = heightSegments;\n        this.depthSegments = depthSegments;\n\n        // segments\n\n        widthSegments = Math.floor(widthSegments);\n        heightSegments = Math.floor(heightSegments);\n        depthSegments = Math.floor(depthSegments);\n\n        // buffers\n\n        const indices: Array<number> = [];\n        const vertices: Array<number> = [];\n        const normals: Array<number> = [];\n        const uvs: Array<number> = [];\n\n        // helper variables\n\n        let numberOfVertices = 0;\n\n        const buildPlane = (\n            u: string,\n            v: string,\n            w: string,\n            udir: number,\n            vdir: number,\n            width: number,\n            height: number,\n            depth: number,\n            gridX: number,\n            gridY: number\n        ) => {\n            const segmentWidth = width / gridX;\n            const segmentHeight = height / gridY;\n\n            const widthHalf = width / 2;\n            const heightHalf = height / 2;\n            const depthHalf = depth / 2;\n\n            const gridX1 = gridX + 1;\n            const gridY1 = gridY + 1;\n\n            let vertexCounter = 0;\n\n            const vector = new Vector3();\n\n            // generate vertices, normals and uvs\n\n            for (let iy = 0; iy < gridY1; iy++) {\n                const y = iy * segmentHeight - heightHalf;\n\n                for (let ix = 0; ix < gridX1; ix++) {\n                    const obj = vector as any;\n                    const x = ix * segmentWidth - widthHalf;\n\n                    // set values to correct vector component\n\n                    obj[u] = x * udir;\n                    obj[v] = y * vdir;\n                    obj[w] = depthHalf;\n\n                    // now apply vector to vertex buffer\n\n                    vertices.push(vector.x, vector.y, vector.z);\n\n                    // set values to correct vector component\n\n                    obj[u] = 0;\n                    obj[v] = 0;\n                    obj[w] = depth > 0 ? 1 : -1;\n\n                    // now apply vector to normal buffer\n\n                    normals.push(vector.x, vector.y, vector.z);\n\n                    // uvs\n\n                    uvs.push(ix / gridX);\n                    uvs.push(1 - iy / gridY);\n\n                    // counters\n\n                    vertexCounter += 1;\n                }\n            }\n\n            // indices\n\n            // 1. you need three indices to draw a single face\n            // 2. a single segment consists of two faces\n            // 3. so we need to generate six (2*3) indices per segment\n\n            for (let iy = 0; iy < gridY; iy++) {\n                for (let ix = 0; ix < gridX; ix++) {\n                    const a = numberOfVertices + ix + gridX1 * iy;\n                    const b = numberOfVertices + ix + gridX1 * (iy + 1);\n                    const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);\n                    const d = numberOfVertices + (ix + 1) + gridX1 * iy;\n\n                    // faces\n\n                    indices.push(a, b, d);\n                    indices.push(b, c, d);\n                }\n            }\n\n            // add a group to the geometry. this will ensure multi material support\n\n            //this.addGroup( groupStart, groupCount, materialIndex );\n\n            // calculate new start value for groups\n\n            // update total number of vertices\n\n            numberOfVertices += vertexCounter;\n        };\n        // build each side of the box geometry\n\n        buildPlane(\"z\", \"y\", \"x\", -1, -1, depth, height, width, depthSegments, heightSegments); // px\n        buildPlane(\"z\", \"y\", \"x\", 1, -1, depth, height, -width, depthSegments, heightSegments); // nx\n        buildPlane(\"x\", \"z\", \"y\", 1, 1, width, depth, height, widthSegments, depthSegments); // py\n        buildPlane(\"x\", \"z\", \"y\", 1, -1, width, depth, -height, widthSegments, depthSegments); // ny\n        buildPlane(\"x\", \"y\", \"z\", 1, -1, width, height, depth, widthSegments, heightSegments); // pz\n        buildPlane(\"x\", \"y\", \"z\", -1, -1, width, height, -depth, widthSegments, heightSegments); // nz\n\n        // build geometry\n        const indicesAttr = new BufferAttribute(new Uint32Array(indices), GPUIndexFormat.Uint32, 1);\n        this.setIndex(indicesAttr);\n        this.setAttribute(\"position\", new BufferAttribute(new Float32Array(vertices), GPUVertexFormat.Float32x3, 3));\n        this.setAttribute(\"normal\", new BufferAttribute(new Float32Array(normals), GPUVertexFormat.Float32x3, 3));\n        this.setAttribute(\"uv\", new BufferAttribute(new Float32Array(uvs), GPUVertexFormat.Float32x2, 2));\n    }\n}\n","import { BufferGeometry } from \"../core/BufferGeometry\";\nimport { BufferAttribute } from \"../core/BufferAttribute\";\nimport { GPUIndexFormat, GPUVertexFormat } from \"../Constants\";\n\nclass PlaneGeometry extends BufferGeometry {\n    public width: number;\n    public height: number;\n    public widthSegments: number;\n    public heightSegments: number;\n\n    constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {\n        super();\n\n        this.width = width;\n        this.height = height;\n        this.widthSegments = widthSegments;\n        this.heightSegments = heightSegments;\n\n        const width_half = width / 2;\n        const height_half = height / 2;\n\n        const gridX = Math.floor(widthSegments);\n        const gridY = Math.floor(heightSegments);\n\n        const gridX1 = gridX + 1;\n        const gridY1 = gridY + 1;\n\n        const segment_width = width / gridX;\n        const segment_height = height / gridY;\n\n        //\n\n        const indices = [];\n        const vertices = [];\n        const normals = [];\n        const uvs = [];\n\n        for (let iy = 0; iy < gridY1; iy++) {\n            const y = iy * segment_height - height_half;\n\n            for (let ix = 0; ix < gridX1; ix++) {\n                const x = ix * segment_width - width_half;\n\n                vertices.push(x, -y, 0);\n\n                normals.push(0, 0, 1);\n\n                uvs.push(ix / gridX);\n                uvs.push(1 - iy / gridY);\n            }\n        }\n\n        for (let iy = 0; iy < gridY; iy++) {\n            for (let ix = 0; ix < gridX; ix++) {\n                const a = ix + gridX1 * iy;\n                const b = ix + gridX1 * (iy + 1);\n                const c = ix + 1 + gridX1 * (iy + 1);\n                const d = ix + 1 + gridX1 * iy;\n\n                indices.push(a, b, d);\n                indices.push(b, c, d);\n            }\n        }\n\n        const indicesAttr = new BufferAttribute(new Uint32Array(indices), GPUIndexFormat.Uint32, 1);\n        this.setIndex(indicesAttr);\n        this.setAttribute(\"position\", new BufferAttribute(new Float32Array(vertices), GPUVertexFormat.Float32x3, 3));\n        this.setAttribute(\"normal\", new BufferAttribute(new Float32Array(normals), GPUVertexFormat.Float32x3, 3));\n        this.setAttribute(\"uv\", new BufferAttribute(new Float32Array(uvs), GPUVertexFormat.Float32x2, 2));\n    }\n}\n\nexport { PlaneGeometry };\n","import { GPUIndexFormat, GPUVertexFormat } from \"../Constants\";\nimport { BufferAttribute } from \"../core/BufferAttribute\";\nimport { BufferGeometry } from \"../core/BufferGeometry\";\nimport { Vector3 } from \"../math/Vector3\";\n\nexport class SphereGeometry extends BufferGeometry {\n    public radius: number;\n    public widthSegments: number;\n    public heightSegments: number;\n    public phiStart: number;\n    public phiLength: number;\n    public thetaStart: number;\n    public thetaLength: number;\n\n    constructor(\n        radius = 1,\n        widthSegments = 32,\n        heightSegments = 16,\n        phiStart = 0,\n        phiLength = Math.PI * 2,\n        thetaStart = 0,\n        thetaLength = Math.PI\n    ) {\n        super();\n\n        (this.radius = radius),\n            (this.widthSegments = widthSegments),\n            (this.heightSegments = heightSegments),\n            (this.phiStart = phiStart),\n            (this.phiLength = phiLength),\n            (this.thetaStart = thetaStart),\n            (this.thetaLength = thetaLength);\n\n        widthSegments = Math.max(3, Math.floor(widthSegments));\n        heightSegments = Math.max(2, Math.floor(heightSegments));\n\n        const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n\n        let index = 0;\n        const grid = [];\n\n        const vertex = new Vector3();\n        const normal = new Vector3();\n\n        // buffers\n\n        const indices = [];\n        const vertices = [];\n        const normals = [];\n        const uvs = [];\n\n        // generate vertices, normals and uvs\n\n        for (let iy = 0; iy <= heightSegments; iy++) {\n            const verticesRow = [];\n\n            const v = iy / heightSegments;\n\n            // special case for the poles\n\n            let uOffset = 0;\n\n            if (iy === 0 && thetaStart === 0) {\n                uOffset = 0.5 / widthSegments;\n            } else if (iy === heightSegments && thetaEnd === Math.PI) {\n                uOffset = -0.5 / widthSegments;\n            }\n\n            for (let ix = 0; ix <= widthSegments; ix++) {\n                const u = ix / widthSegments;\n\n                // vertex\n\n                vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n                vertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n                vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n\n                vertices.push(vertex.x, vertex.y, vertex.z);\n\n                // normal\n\n                normal.copy(vertex).normalize();\n                normals.push(normal.x, normal.y, normal.z);\n\n                // uv\n\n                uvs.push(u + uOffset, 1 - v);\n\n                verticesRow.push(index++);\n            }\n\n            grid.push(verticesRow);\n        }\n\n        // indices\n\n        for (let iy = 0; iy < heightSegments; iy++) {\n            for (let ix = 0; ix < widthSegments; ix++) {\n                const a = grid[iy][ix + 1];\n                const b = grid[iy][ix];\n                const c = grid[iy + 1][ix];\n                const d = grid[iy + 1][ix + 1];\n\n                if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);\n                if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);\n            }\n        }\n\n        // build geometry\n        const indicesAttr = new BufferAttribute(new Uint32Array(indices), GPUIndexFormat.Uint32, 1);\n        this.setIndex(indicesAttr);\n        this.setAttribute(\"position\", new BufferAttribute(new Float32Array(vertices), GPUVertexFormat.Float32x3, 3));\n        this.setAttribute(\"normal\", new BufferAttribute(new Float32Array(normals), GPUVertexFormat.Float32x3, 3));\n        this.setAttribute(\"uv\", new BufferAttribute(new Float32Array(uvs), GPUVertexFormat.Float32x2, 2));\n    }\n}\n","import { Light } from \"./Light\";\nimport { Color } from \"../math/Color\";\nimport { Object3D } from \"../core/Object3D\";\nimport { DirectionalLightShadow } from \"./DirectionalLightShadow\";\nimport * as TempValues from \"../utils/TempValues\";\nimport { Vector3 } from \"../math/Vector3\";\n\nexport class DirectionalLight extends Light {\n    public get type() {\n        return \"DirectionalLight\";\n    }\n\n    public static Is(object: Object3D) {\n        return object instanceof DirectionalLight;\n    }\n\n    private _target = new Object3D();\n    private _shadow = new DirectionalLightShadow();\n    private _direction = new Vector3();\n    public needsUpdate = true;\n\n    constructor(color: Color, intensity = 1) {\n        super(color, intensity);\n\n        this.matrixAutoUpdate = true;\n\n        this.position.copy(Object3D.DEFAULT_UP);\n        this.updateMatrix();\n\n        this.update();\n    }\n\n    public update() {\n        if (this.needsUpdate) {\n            this.updateMatrixWorld();\n            TempValues.Vector0.setFromMatrixPosition(this._target.matrixWorld);\n            TempValues.Vector1.setFromMatrixPosition(this.matrixWorld);\n            this._direction.subVectors(TempValues.Vector1, TempValues.Vector0);\n        }\n        this.needsUpdate = false;\n    }\n\n    public get direction() {\n        return this._direction;\n    }\n\n    public get target() {\n        return this._target;\n    }\n\n    dispose() {\n        //this.shadow.dispose();\n    }\n\n    copy(source: DirectionalLight) {\n        super.copy(source);\n\n        this._direction.copy(source._direction);\n        //this.shadow = source.shadow.clone();\n\n        return this;\n    }\n}\n","import { OrthographicCamera } from \"../cameras/OrthographicCamera\";\nimport { Matrix4 } from \"../math/Matrix4\";\nimport { Vector3 } from \"../math/Vector3\";\nimport { DirectionalLight } from \"./DirectionalLight\";\nimport { LightShadow } from \"./LightShadow\";\n\nconst _projScreenMatrix = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld = /*@__PURE__*/ new Vector3();\nconst _lookTarget = /*@__PURE__*/ new Vector3();\n\nexport class DirectionalLightShadow extends LightShadow {\n    constructor() {\n        super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));\n    }\n\n    updateMatrices(light: DirectionalLight) {\n        const shadowCamera = this.camera;\n        const shadowMatrix = this.matrix;\n\n        _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);\n        shadowCamera.position.copy(_lightPositionWorld);\n\n        _lookTarget.setFromMatrixPosition(light.target.matrixWorld);\n        shadowCamera.lookAt(_lookTarget);\n        shadowCamera.updateMatrixWorld();\n\n        _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);\n        this._frustum.setFromProjectionMatrix(_projScreenMatrix);\n\n        shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n\n        shadowMatrix.multiply(_projScreenMatrix);\n    }\n}\n","import { Object3D } from \"../core/Object3D\";\nimport { Color } from \"../math/Color\";\n\nexport class Light extends Object3D {\n    public get type() {\n        return \"Light\";\n    }\n\n    public static Is(object: Object3D) {\n        return object instanceof Light;\n    }\n\n    public get isLight() {\n        return true;\n    }\n\n    private _color: Color;\n    private _intensity: number;\n\n    constructor(color: Color, intensity = 1) {\n        super();\n\n        this._color = color;\n        this._intensity = intensity;\n    }\n\n    public update() {}\n\n    public get color() {\n        return this._color;\n    }\n}\n","import { Matrix4 } from \"../math/Matrix4\";\nimport { Vector2 } from \"../math/Vector2\";\nimport { Vector4 } from \"../math/Vector4\";\nimport { Frustum } from \"../math/Frustum\";\nimport { Camera } from \"../cameras/Camera\";\n\nexport class LightShadow {\n    public camera: Camera;\n    public bias = 0;\n    public normalBias = 0;\n    public radius = 0;\n    public blurSamples = 0;\n\n    mapSize = new Vector2(512, 512);\n    matrix = new Matrix4();\n\n    autoUpdate = true;\n    needsUpdate = false;\n\n    _frustum = new Frustum();\n    _frameExtents = new Vector2(1, 1);\n\n    _viewportCount = 1;\n\n    _viewports = [new Vector4(0, 0, 1, 1)];\n\n    constructor(camera?: Camera) {\n        this.camera = camera;\n        // this.map = null;\n        // this.mapPass = null;\n    }\n\n    getViewportCount() {\n        return this._viewportCount;\n    }\n\n    getFrustum() {\n        return this._frustum;\n    }\n\n    getViewport(viewportIndex: number) {\n        return this._viewports[viewportIndex];\n    }\n\n    getFrameExtents() {\n        return this._frameExtents;\n    }\n\n    dispose() {\n        // if (this.map) {\n        //     this.map.dispose();\n        // }\n        // if (this.mapPass) {\n        //     this.mapPass.dispose();\n        // }\n    }\n\n    copy(source: LightShadow) {\n        this.camera = source.camera.clone();\n\n        this.bias = source.bias;\n        this.radius = source.radius;\n\n        this.mapSize.copy(source.mapSize);\n\n        return this;\n    }\n\n    clone() {\n        return new LightShadow().copy(this);\n    }\n}\n","import { Cache } from \"../core/ResourceManagers\";\nimport { Loader } from \"./Loader\";\nimport { LoadingManager } from \"./LoadingManager\";\n\nconst loading: any = {};\n\nclass HttpError extends Error {\n    public response: Response;\n\n    constructor(message: string, response: Response) {\n        super(message);\n        this.response = response;\n    }\n}\n\nclass FileLoader extends Loader {\n    public mimeType: DOMParserSupportedType;\n    public responseType: string;\n\n    constructor(manager: LoadingManager = undefined) {\n        super(manager);\n    }\n\n    load(url: string, onLoad: Function, onProgress: Function, onError: Function) {\n        if (url === undefined) url = \"\";\n\n        if (this.path !== undefined) url = this.path + url;\n\n        url = this.manager.resolveURL(url);\n\n        const cached = Cache.get(url);\n\n        if (cached !== undefined) {\n            this.manager.itemStart(url);\n\n            setTimeout(() => {\n                if (onLoad) onLoad(cached);\n\n                this.manager.itemEnd(url);\n            }, 0);\n\n            return cached;\n        }\n\n        // Check if request is duplicate\n\n        if (loading[url] !== undefined) {\n            loading[url].push({\n                onLoad: onLoad,\n                onProgress: onProgress,\n                onError: onError,\n            });\n\n            return;\n        }\n\n        // Initialise array for duplicate requests\n        loading[url] = [];\n\n        loading[url].push({\n            onLoad: onLoad,\n            onProgress: onProgress,\n            onError: onError,\n        });\n\n        // create request\n        const req = new Request(url, {\n            headers: new Headers(this.requestHeader),\n            credentials: this.withCredentials ? \"include\" : \"same-origin\",\n            // An abort controller could be added within a future PR\n        });\n\n        // record states ( avoid data race )\n        const mimeType = this.mimeType;\n        const responseType = this.responseType;\n\n        // start the fetch\n        fetch(req)\n            .then((response) => {\n                if (response.status === 200 || response.status === 0) {\n                    // Some browsers return HTTP Status 0 when using non-http protocol\n                    // e.g. 'file://' or 'data://'. Handle as success.\n\n                    if (response.status === 0) {\n                        console.warn(\"THREE.FileLoader: HTTP Status 0 received.\");\n                    }\n\n                    // Workaround: Checking if response.body === undefined for Alipay browser #23548\n\n                    if (\n                        typeof ReadableStream === \"undefined\" ||\n                        response.body === undefined ||\n                        response.body.getReader === undefined\n                    ) {\n                        return response;\n                    }\n\n                    const callbacks = loading[url];\n                    const reader = response.body.getReader();\n\n                    // Nginx needs X-File-Size check\n                    // https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content\n                    const contentLength = response.headers.get(\"Content-Length\") || response.headers.get(\"X-File-Size\");\n                    const total = contentLength ? parseInt(contentLength) : 0;\n                    const lengthComputable = total !== 0;\n                    let loaded = 0;\n\n                    // periodically read data into the new stream tracking while download progress\n                    const stream = new ReadableStream({\n                        start(controller) {\n                            readData();\n\n                            function readData() {\n                                reader.read().then(({ done, value }) => {\n                                    if (done) {\n                                        controller.close();\n                                    } else {\n                                        loaded += value.byteLength;\n\n                                        const event = new ProgressEvent(\"progress\", {\n                                            lengthComputable,\n                                            loaded,\n                                            total,\n                                        });\n                                        for (let i = 0, il = callbacks.length; i < il; i++) {\n                                            const callback = callbacks[i];\n                                            if (callback.onProgress) callback.onProgress(event);\n                                        }\n\n                                        controller.enqueue(value);\n                                        readData();\n                                    }\n                                });\n                            }\n                        },\n                    });\n\n                    return new Response(stream);\n                } else {\n                    throw new HttpError(\n                        `fetch for \"${response.url}\" responded with ${response.status}: ${response.statusText}`,\n                        response\n                    );\n                }\n            })\n            .then((response) => {\n                switch (responseType) {\n                    case \"arraybuffer\":\n                        return response.arrayBuffer();\n\n                    case \"blob\":\n                        return response.blob();\n\n                    case \"document\":\n                        return response.text().then((text) => {\n                            const parser = new DOMParser();\n                            return parser.parseFromString(text, mimeType);\n                        });\n\n                    case \"json\":\n                        return response.json();\n\n                    default:\n                        if (mimeType === undefined) {\n                            return response.text();\n                        } else {\n                            // sniff encoding\n                            const re = /charset=\"?([^;\"\\s]*)\"?/i;\n                            const exec = re.exec(mimeType);\n                            const label = exec && exec[1] ? exec[1].toLowerCase() : undefined;\n                            const decoder = new TextDecoder(label);\n                            return response.arrayBuffer().then((ab) => decoder.decode(ab));\n                        }\n                }\n            })\n            .then((data) => {\n                // Add to cache only on HTTP success, so that we do not cache\n                // error response bodies as proper responses to requests.\n                Cache.add(url, data);\n\n                const callbacks = loading[url];\n                delete loading[url];\n\n                for (let i = 0, il = callbacks.length; i < il; i++) {\n                    const callback = callbacks[i];\n                    if (callback.onLoad) callback.onLoad(data);\n                }\n            })\n            .catch((err) => {\n                // Abort errors and other errors are handled the same\n\n                const callbacks = loading[url];\n\n                if (callbacks === undefined) {\n                    // When onLoad was called and url was deleted in `loading`\n                    this.manager.itemError(url);\n                    throw err;\n                }\n\n                delete loading[url];\n\n                for (let i = 0, il = callbacks.length; i < il; i++) {\n                    const callback = callbacks[i];\n                    if (callback.onError) callback.onError(err);\n                }\n\n                this.manager.itemError(url);\n            })\n            .finally(() => {\n                this.manager.itemEnd(url);\n            });\n\n        this.manager.itemStart(url);\n    }\n\n    setResponseType(value: string) {\n        this.responseType = value;\n        return this;\n    }\n\n    setMimeType(value: DOMParserSupportedType) {\n        this.mimeType = value;\n        return this;\n    }\n}\n\nexport { FileLoader };\n","import { Cache } from \"../core/ResourceManagers\";\nimport { Loader } from \"./Loader\";\nimport { LoadingManager } from \"./LoadingManager\";\n\nexport class ImageLoader extends Loader {\n    constructor(manager: LoadingManager = undefined) {\n        super(manager);\n    }\n\n    load(url: string, onLoad: Function, onProgress: Function, onError: Function) {\n        if (this.path !== undefined) url = this.path + url;\n\n        url = this.manager.resolveURL(url);\n\n        const scope = this;\n\n        const cached = Cache.get(url);\n\n        if (cached !== undefined) {\n            scope.manager.itemStart(url);\n\n            setTimeout(function () {\n                if (onLoad) onLoad(cached);\n\n                scope.manager.itemEnd(url);\n            }, 0);\n\n            return cached;\n        }\n\n        const image = document.createElement(\"img\");\n\n        const onImageLoad = () => {\n            removeEventListeners();\n\n            Cache.add(url, image);\n\n            if (onLoad) onLoad(image);\n\n            scope.manager.itemEnd(url);\n        };\n\n        function onImageError(event: any) {\n            removeEventListeners();\n\n            if (onError) onError(event);\n\n            scope.manager.itemError(url);\n            scope.manager.itemEnd(url);\n        }\n\n        function removeEventListeners() {\n            image.removeEventListener(\"load\", onImageLoad, false);\n            image.removeEventListener(\"error\", onImageError, false);\n        }\n\n        image.addEventListener(\"load\", onImageLoad, false);\n        image.addEventListener(\"error\", onImageError, false);\n\n        if (url.slice(0, 5) !== \"data:\") {\n            if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;\n        }\n\n        scope.manager.itemStart(url);\n\n        image.src = url;\n\n        return image;\n    }\n}\n","import { DefaultLoadingManager, LoadingManager } from \"./LoadingManager\";\n\nexport abstract class Loader {\n    public manager: LoadingManager;\n    public crossOrigin = \"anonymous\";\n    public withCredentials = false;\n    public path = \"\";\n    public resourcePath = \"\";\n    public requestHeader = {};\n\n    constructor(manager: LoadingManager = undefined) {\n        this.manager = manager !== undefined ? manager : DefaultLoadingManager;\n    }\n\n    abstract load(url: string, onLoad: Function, onProgress: Function, onError: Function): void;\n\n    loadAsync(url: string, onProgress: Function) {\n        const scope = this;\n\n        return new Promise(function (resolve, reject) {\n            scope.load(url, resolve, onProgress, reject);\n        });\n    }\n\n    parse(/* data */) {}\n\n    setCrossOrigin(crossOrigin: string) {\n        this.crossOrigin = crossOrigin;\n        return this;\n    }\n\n    setWithCredentials(value: boolean) {\n        this.withCredentials = value;\n        return this;\n    }\n\n    setPath(path: string) {\n        this.path = path;\n        return this;\n    }\n\n    setResourcePath(resourcePath: string) {\n        this.resourcePath = resourcePath;\n        return this;\n    }\n\n    setRequestHeader(requestHeader: any) {\n        this.requestHeader = requestHeader;\n        return this;\n    }\n}\n","export class LoadingManager {\n    private isLoading = false;\n    private itemsLoaded = 0;\n    private itemsTotal = 0;\n    private urlModifier: Function = undefined;\n    private handlers: Array<RegExp> = [];\n\n    public onStart: Function;\n    public onLoad: Function;\n    public onProgress: Function;\n    public onError: Function;\n\n    constructor(onLoad: Function = undefined, onProgress: Function = undefined, onError: Function = undefined) {\n        // Refer to #5689 for the reason why we don't set .onStart\n        // in the constructor\n\n        this.onStart = undefined;\n        this.onLoad = onLoad;\n        this.onProgress = onProgress;\n        this.onError = onError;\n    }\n\n    itemStart(url: string) {\n        this.itemsTotal++;\n\n        if (this.isLoading === false) {\n            if (this.onStart !== undefined) {\n                this.onStart(url, this.itemsLoaded, this.itemsTotal);\n            }\n        }\n\n        this.isLoading = true;\n    }\n\n    itemEnd(url: string) {\n        this.itemsLoaded++;\n\n        if (this.onProgress !== undefined) {\n            this.onProgress(url, this.itemsLoaded, this.itemsTotal);\n        }\n\n        if (this.itemsLoaded === this.itemsTotal) {\n            this.isLoading = false;\n\n            if (this.onLoad !== undefined) {\n                this.onLoad();\n            }\n        }\n    }\n\n    itemError(url: string) {\n        if (this.onError !== undefined) {\n            this.onError(url);\n        }\n    }\n\n    resolveURL(url: string) {\n        if (this.urlModifier) {\n            return this.urlModifier(url);\n        }\n\n        return url;\n    }\n\n    setURLModifier(transform: Function) {\n        this.urlModifier = transform;\n\n        return this;\n    }\n\n    addHandler(regex: RegExp, loader: any) {\n        this.handlers.push(regex, loader);\n\n        return this;\n    }\n\n    removeHandler(regex: RegExp) {\n        const index = this.handlers.indexOf(regex);\n\n        if (index !== -1) {\n            this.handlers.splice(index, 2);\n        }\n\n        return this;\n    }\n\n    getHandler(file: string) {\n        for (let i = 0, l = this.handlers.length; i < l; i += 2) {\n            const regex = this.handlers[i];\n            const loader = this.handlers[i + 1];\n\n            if (regex.global) regex.lastIndex = 0; // see #17920\n\n            if (regex.test(file)) {\n                return loader;\n            }\n        }\n\n        return null;\n    }\n}\n\nexport const DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();\n","import { ImageLoader } from \"./ImageLoader\";\nimport { Texture } from \"../textures/Texture\";\nimport { Loader } from \"./Loader\";\nimport { LoadingManager } from \"./LoadingManager\";\n\nclass TextureLoader extends Loader {\n    public image: HTMLImageElement;\n\n    constructor(manager: LoadingManager = undefined) {\n        super(manager);\n    }\n\n    load(url: string, onLoad: Function, onProgress: Function, onError: Function) {\n        const texture = new Texture();\n\n        const loader = new ImageLoader(this.manager);\n        loader.setCrossOrigin(this.crossOrigin);\n        loader.setPath(this.path);\n\n        loader.load(\n            url,\n            function (image: HTMLImageElement) {\n                texture.image = image;\n                texture.needsUpdate = true;\n\n                if (onLoad !== undefined) {\n                    onLoad(texture);\n                }\n            },\n            onProgress,\n            onError\n        );\n\n        return texture;\n    }\n}\n\nexport { TextureLoader };\n","import { BindValue } from \"../core/binds/BindValue\";\nimport { Color } from \"../math/Color\";\nimport { Texture } from \"../textures/Texture\";\nimport { GPUVertexFormat } from \"../Constants\";\nimport { BindBuffer } from \"../core/binds/BindBuffer\";\nimport { BindSampler } from \"../core/binds/BindSampler\";\nimport { BindTexture } from \"../core/binds/BindTexture\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { Pipleline } from \"../core/Pipeline\";\nimport { AttributeShaderItem, BindShaderItem, BindType, getLayoutEntity, ShaderItem } from \"../core/Defines\";\nimport { Shader } from \"../shaders/Shader\";\n\nexport abstract class Material {\n    private _color: Color;\n    private _map: Texture = null;\n    private _parameters = new Uint32Array(4);\n    private _pipeline: Pipleline;\n    private _transparent = false;\n    private _opacity = 1;\n\n    protected _bindMap: Map<string, BindValue> = new Map();\n    protected _shader: Shader;\n    protected _shaderOptions = {\n        attributeValues: new Map<string, AttributeShaderItem>(),\n        bindValues: new Map<string, BindShaderItem>(),\n    };\n\n    public readonly uuid = MathUtils.generateUUID();\n\n    constructor() {\n        this._pipeline = new Pipleline(this);\n\n        this._setAttributeItem(\"position\", \"vec3<f32>\", GPUVertexFormat.Float32x3, 4 * 3);\n\n        this._bindMap.set(\"parameters\", new BindBuffer(this._parameters));\n        this._setBindItem(\"parameters\", \"vec4<u32>\", BindType.buffer, GPUShaderStage.FRAGMENT);\n\n        this.color = new Color(1.0, 1.0, 1.0);\n    }\n\n    public updateBinds() {\n        for (const uniform of this._bindMap.values()) {\n            uniform.update();\n        }\n    }\n\n    public getBindLayout() {\n        const entriesLayout: Array<GPUBindGroupLayoutEntry> = [];\n        for (const bindOption of this._shaderOptions.bindValues.values()) {\n            const entity = getLayoutEntity(bindOption);\n            entriesLayout.push(entity);\n        }\n\n        return entriesLayout;\n    }\n\n    public getBindGroup() {\n        const entriesGroup = new Array<GPUBindGroupEntry>();\n\n        for (const bindOption of this._shaderOptions.bindValues.values()) {\n            if (bindOption.bindType === BindType.buffer) {\n                const bufferUnform = this._bindMap.get(bindOption.name) as BindBuffer;\n                entriesGroup.push({\n                    binding: bindOption.index,\n                    resource: {\n                        buffer: bufferUnform.buffer,\n                    },\n                });\n            } else if (bindOption.bindType === BindType.sampler) {\n                const samplerUnform = this._bindMap.get(bindOption.name) as BindSampler;\n                entriesGroup.push({\n                    binding: bindOption.index,\n                    resource: samplerUnform.sampler,\n                });\n            } else if (bindOption.bindType === BindType.texture) {\n                const textureUnform = this._bindMap.get(bindOption.name) as BindTexture;\n                entriesGroup.push({\n                    binding: bindOption.index,\n                    resource: textureUnform.gpuTexutureView,\n                });\n            }\n        }\n\n        return entriesGroup;\n    }\n\n    protected _setAttributeItem(name: string, itemType: string, format: GPUVertexFormat, itemSize: number) {\n        const values = this.shaderOptions.attributeValues;\n        values.set(name, {\n            name: name,\n            index: this._shaderOptions.bindValues.size,\n            format: format,\n            shaderItemType: itemType,\n            itemSize: itemSize,\n        });\n        let index = 0;\n        for (const value of values.values()) {\n            value.index = index++;\n        }\n    }\n\n    protected _setBindItem(name: string, itemType: string, bindType: BindType, visibility: GPUShaderStageFlags) {\n        const values = this.shaderOptions.bindValues;\n        values.set(name, {\n            name: name,\n            index: this._shaderOptions.bindValues.size,\n            bindType: bindType,\n            shaderItemType: itemType,\n            visibility: visibility,\n        });\n        let index = 0;\n        for (const value of values.values()) {\n            value.index = index++;\n        }\n    }\n\n    protected _deleteValue(values: Map<string, ShaderItem>, name: string) {\n        values.delete(name);\n        let index = 0;\n        for (const value of values.values()) {\n            value.index = index++;\n        }\n    }\n\n    public get applyLight() {\n        return false;\n    }\n\n    public set color(v: Color) {\n        this._color = v;\n\n        let colorBuffer;\n        let itemType;\n        if (this._transparent) {\n            colorBuffer = new Float32Array(4);\n            itemType = \"vec4<f32>\";\n            colorBuffer.set(this._color.toArray());\n            colorBuffer[3] = this._opacity;\n        } else {\n            colorBuffer = this._color.toArray();\n            itemType = \"vec3<f32>\";\n        }\n\n        const colorUniform = this._bindMap.get(\"color\") as BindBuffer;\n        if (!colorUniform) {\n            this._setBindItem(\"color\", itemType, BindType.buffer, GPUShaderStage.FRAGMENT);\n\n            this._bindMap.set(\"color\", new BindBuffer(colorBuffer));\n        } else if (colorBuffer.length * colorBuffer.BYTES_PER_ELEMENT !== colorUniform.buffer.size) {\n            this._shaderOptions.bindValues.get(\"color\").shaderItemType = itemType;\n\n            this._bindMap.set(\"color\", new BindBuffer(colorBuffer));\n        } else {\n            colorUniform.data = colorBuffer;\n        }\n    }\n\n    public get color() {\n        return this._color;\n    }\n\n    public set map(v: Texture | null) {\n        if (v === this._map) return;\n\n        // delete current map\n        if (v === null && this._map !== null) {\n            this._bindMap.delete(\"colorSampler\");\n            this._bindMap.delete(\"colorTexture\");\n\n            this._deleteValue(this._shaderOptions.attributeValues, \"uv\");\n            this._deleteValue(this._shaderOptions.bindValues, \"colorSampler\");\n            this._deleteValue(this._shaderOptions.bindValues, \"colorTexture\");\n\n            this.pipeline.needsCompile = true;\n        } else if (v !== null && this._map === null) {\n            //don't have map before\n            this._setAttributeItem(\"uv\", \"vec2<f32>\", GPUVertexFormat.Float32x2, 4 * 2);\n\n            this._setBindItem(\"colorSampler\", \"sampler\", BindType.sampler, GPUShaderStage.FRAGMENT);\n            this._bindMap.set(\"colorSampler\", v.sampler);\n\n            this._setBindItem(\"colorTexture\", \"texture_2d<f32>\", BindType.texture, GPUShaderStage.FRAGMENT);\n            this._bindMap.set(\"colorTexture\", v.bind);\n\n            this.pipeline.needsCompile = true;\n\n            (this._bindMap.get(\"colorTexture\") as BindTexture).texture = v;\n        }\n\n        this.pipeline.needsCreateMatBindGroup = true;\n        this._map = v;\n    }\n\n    public get map() {\n        return this._map;\n    }\n\n    public set transparent(v: boolean) {\n        if (this._transparent === v) return;\n\n        this.pipeline.needsCompile = true;\n        this.pipeline.needsCreateMatBindGroup = true;\n        this._transparent = v;\n        this.color = this._color;\n    }\n\n    public get transparent() {\n        return this._transparent;\n    }\n\n    public set opacity(v: number) {\n        this._opacity = v;\n        this.color = this._color;\n    }\n\n    public get opacity() {\n        return this._opacity;\n    }\n\n    public get shaderOptions() {\n        return this._shaderOptions;\n    }\n\n    public get shader() {\n        return this._shader;\n    }\n\n    public get pipeline() {\n        return this._pipeline;\n    }\n}\n","import { MeshBasicShader } from \"../shaders/MeshBasicShader\";\nimport { Material } from \"./Material\";\n\nexport class MeshBasicMaterial extends Material {\n    constructor() {\n        super();\n\n        this._shader = new MeshBasicShader(this);\n    }\n}\n","import { GPUVertexFormat } from \"../Constants\";\nimport { BindBuffer } from \"../core/binds/BindBuffer\";\nimport { BindType } from \"../core/Defines\";\nimport { Color } from \"../math/Color\";\nimport { MeshPhongShader } from \"../shaders/MeshPhongShader\";\nimport { Material } from \"./Material\";\n\nexport class MeshPhongMaterial extends Material {\n    private _specular = new Color(0x111111); //高光反射\n    private _emissive = new Color(0x000000); //自发光\n    private _shininess = 30;\n\n    constructor() {\n        super();\n\n        this._shader = new MeshPhongShader(this);\n\n        this._setAttributeItem(\"normal\", \"vec3<f32>\", GPUVertexFormat.Float32x3, 4 * 3);\n\n        this._bindMap.set(\"specular\", new BindBuffer(this._specular.toArray()));\n        this._setBindItem(\"specular\", \"vec3<f32>\", BindType.buffer, GPUShaderStage.FRAGMENT);\n        this._bindMap.set(\"emissive\", new BindBuffer(this._emissive.toArray()));\n        this._setBindItem(\"emissive\", \"vec3<f32>\", BindType.buffer, GPUShaderStage.FRAGMENT);\n        this._bindMap.set(\"shininess\", new BindBuffer(new Float32Array([this._shininess])));\n        this._setBindItem(\"shininess\", \"f32\", BindType.buffer, GPUShaderStage.FRAGMENT);\n    }\n\n    public override get applyLight() {\n        return false;\n    }\n\n    public set specular(v: Color) {\n        this._specular.copy(v);\n        (this._bindMap.get(\"specular\") as BindBuffer).data = v.toArray();\n    }\n\n    public set emissive(v: Color) {\n        this._emissive.copy(v);\n        (this._bindMap.get(\"emissive\") as BindBuffer).data = v.toArray();\n    }\n\n    public set shininess(v: number) {\n        this._shininess = v;\n        (this._bindMap.get(\"specular\") as BindBuffer).data = new Float32Array([v]);\n    }\n}\n","import { RenderableObject } from \"../core/RenderableObject\";\nimport { BufferAttribute } from \"../core/BufferAttribute\";\nimport { Vector3 } from \"./Vector3\";\nimport { Matrix4 } from \"./Matrix4\";\nimport { Sphere } from \"./Sphere\";\nimport { Plane } from \"./Plane\";\nimport { Triangle } from \"./Triangle\";\n\nexport class Box3 {\n    public min: Vector3;\n    public max: Vector3;\n\n    constructor(\n        min = new Vector3(+Infinity, +Infinity, +Infinity),\n        max = new Vector3(-Infinity, -Infinity, -Infinity)\n    ) {\n        this.min = min;\n        this.max = max;\n    }\n\n    set(min: Vector3, max: Vector3) {\n        this.min.copy(min);\n        this.max.copy(max);\n\n        return this;\n    }\n\n    setFromArray(array: Array<number>) {\n        this.makeEmpty();\n\n        for (let i = 0, il = array.length; i < il; i += 3) {\n            this.expandByPoint(_vector.fromArray(array, i));\n        }\n\n        return this;\n    }\n\n    setFromBufferAttribute(attribute: BufferAttribute) {\n        this.makeEmpty();\n\n        for (let i = 0, il = attribute.count; i < il; i++) {\n            this.expandByPoint(_vector.fromBufferAttribute(attribute, i));\n        }\n\n        return this;\n    }\n\n    setFromPoints(points: Array<Vector3>) {\n        this.makeEmpty();\n\n        for (let i = 0, il = points.length; i < il; i++) {\n            this.expandByPoint(points[i]);\n        }\n\n        return this;\n    }\n\n    setFromCenterAndSize(center: Vector3, size: Vector3) {\n        const halfSize = _vector.copy(size).multiplyScalar(0.5);\n\n        this.min.copy(center).sub(halfSize);\n        this.max.copy(center).add(halfSize);\n\n        return this;\n    }\n\n    setFromObject(object: RenderableObject, precise = false) {\n        this.makeEmpty();\n\n        return this.expandByObject(object, precise);\n    }\n\n    clone() {\n        return new Box3().copy(this);\n    }\n\n    copy(box: Box3) {\n        this.min.copy(box.min);\n        this.max.copy(box.max);\n\n        return this;\n    }\n\n    makeEmpty() {\n        this.min.x = this.min.y = this.min.z = +Infinity;\n        this.max.x = this.max.y = this.max.z = -Infinity;\n\n        return this;\n    }\n\n    isEmpty() {\n        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n    }\n\n    getCenter(target: Vector3) {\n        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n    }\n\n    getSize(target: Vector3) {\n        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n    }\n\n    expandByPoint(point: Vector3) {\n        this.min.min(point);\n        this.max.max(point);\n\n        return this;\n    }\n\n    expandByVector(vector: Vector3) {\n        this.min.sub(vector);\n        this.max.add(vector);\n\n        return this;\n    }\n\n    expandByScalar(scalar: number) {\n        this.min.addScalar(-scalar);\n        this.max.addScalar(scalar);\n\n        return this;\n    }\n\n    expandByObject(object: RenderableObject, precise = false) {\n        // Computes the world-axis-aligned bounding box of an object (including its children),\n        // accounting for both the object's, and children's, world transforms\n\n        object.updateWorldMatrix(false, false);\n\n        if (object.boundingBox !== undefined) {\n            if (object.boundingBox === null) {\n                object.computeBoundingBox();\n            }\n\n            _box.copy(object.boundingBox);\n            _box.applyMatrix4(object.matrixWorld);\n\n            this.union(_box);\n        } else {\n            const geometry = object.geometry;\n\n            if (geometry !== undefined) {\n                if (precise && geometry.attributes !== undefined && geometry.attributes.get(\"position\") !== undefined) {\n                    const position = geometry.attributes.get(\"position\");\n                    for (let i = 0, l = position.count; i < l; i++) {\n                        _vector.fromBufferAttribute(position, i).applyMatrix4(object.matrixWorld);\n                        this.expandByPoint(_vector);\n                    }\n                } else {\n                    if (geometry.boundingBox === null) {\n                        geometry.computeBoundingBox();\n                    }\n\n                    _box.copy(geometry.boundingBox);\n                    _box.applyMatrix4(object.matrixWorld);\n\n                    this.union(_box);\n                }\n            }\n        }\n\n        const children = object.children;\n\n        for (let i = 0, l = children.length; i < l; i++) {\n            if (RenderableObject.Is(children[i])) this.expandByObject(children[i] as RenderableObject, precise);\n        }\n\n        return this;\n    }\n\n    containsPoint(point: Vector3) {\n        return point.x < this.min.x ||\n            point.x > this.max.x ||\n            point.y < this.min.y ||\n            point.y > this.max.y ||\n            point.z < this.min.z ||\n            point.z > this.max.z\n            ? false\n            : true;\n    }\n\n    containsBox(box: Box3) {\n        return (\n            this.min.x <= box.min.x &&\n            box.max.x <= this.max.x &&\n            this.min.y <= box.min.y &&\n            box.max.y <= this.max.y &&\n            this.min.z <= box.min.z &&\n            box.max.z <= this.max.z\n        );\n    }\n\n    getParameter(point: Vector3, target: Vector3) {\n        // This can potentially have a divide by zero if the box\n        // has a size dimension of 0.\n\n        return target.set(\n            (point.x - this.min.x) / (this.max.x - this.min.x),\n            (point.y - this.min.y) / (this.max.y - this.min.y),\n            (point.z - this.min.z) / (this.max.z - this.min.z)\n        );\n    }\n\n    intersectsBox(box: Box3) {\n        // using 6 splitting planes to rule out intersections.\n        return box.max.x < this.min.x ||\n            box.min.x > this.max.x ||\n            box.max.y < this.min.y ||\n            box.min.y > this.max.y ||\n            box.max.z < this.min.z ||\n            box.min.z > this.max.z\n            ? false\n            : true;\n    }\n\n    intersectsSphere(sphere: Sphere) {\n        // Find the point on the AABB closest to the sphere center.\n        this.clampPoint(sphere.center, _vector);\n\n        // If that point is inside the sphere, the AABB and sphere intersect.\n        return _vector.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n    }\n\n    intersectsPlane(plane: Plane) {\n        // We compute the minimum and maximum dot product values. If those values\n        // are on the same side (back or front) of the plane, then there is no intersection.\n\n        let min, max;\n\n        if (plane.normal.x > 0) {\n            min = plane.normal.x * this.min.x;\n            max = plane.normal.x * this.max.x;\n        } else {\n            min = plane.normal.x * this.max.x;\n            max = plane.normal.x * this.min.x;\n        }\n\n        if (plane.normal.y > 0) {\n            min += plane.normal.y * this.min.y;\n            max += plane.normal.y * this.max.y;\n        } else {\n            min += plane.normal.y * this.max.y;\n            max += plane.normal.y * this.min.y;\n        }\n\n        if (plane.normal.z > 0) {\n            min += plane.normal.z * this.min.z;\n            max += plane.normal.z * this.max.z;\n        } else {\n            min += plane.normal.z * this.max.z;\n            max += plane.normal.z * this.min.z;\n        }\n\n        return min <= -plane.constant && max >= -plane.constant;\n    }\n\n    intersectsTriangle(triangle: Triangle) {\n        if (this.isEmpty()) {\n            return false;\n        }\n\n        // compute box center and extents\n        this.getCenter(_center);\n        _extents.subVectors(this.max, _center);\n\n        // translate triangle to aabb origin\n        _v0.subVectors(triangle.a, _center);\n        _v1.subVectors(triangle.b, _center);\n        _v2.subVectors(triangle.c, _center);\n\n        // compute edge vectors for triangle\n        _f0.subVectors(_v1, _v0);\n        _f1.subVectors(_v2, _v1);\n        _f2.subVectors(_v0, _v2);\n\n        // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n        // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n        // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n        let axes = [\n            0,\n            -_f0.z,\n            _f0.y,\n            0,\n            -_f1.z,\n            _f1.y,\n            0,\n            -_f2.z,\n            _f2.y,\n            _f0.z,\n            0,\n            -_f0.x,\n            _f1.z,\n            0,\n            -_f1.x,\n            _f2.z,\n            0,\n            -_f2.x,\n            -_f0.y,\n            _f0.x,\n            0,\n            -_f1.y,\n            _f1.x,\n            0,\n            -_f2.y,\n            _f2.x,\n            0,\n        ];\n        if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {\n            return false;\n        }\n\n        // test 3 face normals from the aabb\n        axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n        if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {\n            return false;\n        }\n\n        // finally testing the face normal of the triangle\n        // use already existing triangle edge vectors here\n        _triangleNormal.crossVectors(_f0, _f1);\n        axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n\n        return satForAxes(axes, _v0, _v1, _v2, _extents);\n    }\n\n    clampPoint(point: Vector3, target: Vector3) {\n        return target.copy(point).clamp(this.min, this.max);\n    }\n\n    distanceToPoint(point: Vector3) {\n        return this.clampPoint(point, _vector).distanceTo(point);\n    }\n\n    getBoundingSphere(target: Sphere) {\n        if (this.isEmpty()) {\n            target.makeEmpty();\n        } else {\n            this.getCenter(target.center);\n\n            target.radius = this.getSize(_vector).length() * 0.5;\n        }\n\n        return target;\n    }\n\n    intersect(box: Box3) {\n        this.min.max(box.min);\n        this.max.min(box.max);\n\n        // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n        if (this.isEmpty()) this.makeEmpty();\n\n        return this;\n    }\n\n    union(box: Box3) {\n        this.min.min(box.min);\n        this.max.max(box.max);\n\n        return this;\n    }\n\n    applyMatrix4(matrix: Matrix4) {\n        // transform of empty box is an empty box.\n        if (this.isEmpty()) return this;\n\n        // NOTE: I am using a binary pattern to specify all 2^3 combinations below\n        _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000\n        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001\n        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010\n        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011\n        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100\n        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101\n        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110\n        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111\n\n        this.setFromPoints(_points);\n\n        return this;\n    }\n\n    translate(offset: Vector3) {\n        this.min.add(offset);\n        this.max.add(offset);\n\n        return this;\n    }\n\n    equals(box: Box3) {\n        return box.min.equals(this.min) && box.max.equals(this.max);\n    }\n}\n\nconst _points = [\n    /*@__PURE__*/ new Vector3(),\n    /*@__PURE__*/ new Vector3(),\n    /*@__PURE__*/ new Vector3(),\n    /*@__PURE__*/ new Vector3(),\n    /*@__PURE__*/ new Vector3(),\n    /*@__PURE__*/ new Vector3(),\n    /*@__PURE__*/ new Vector3(),\n    /*@__PURE__*/ new Vector3(),\n];\n\nconst _vector = /*@__PURE__*/ new Vector3();\n\nconst _box = /*@__PURE__*/ new Box3();\n\n// triangle centered vertices\n\nconst _v0 = /*@__PURE__*/ new Vector3();\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _v2 = /*@__PURE__*/ new Vector3();\n\n// triangle edge vectors\n\nconst _f0 = /*@__PURE__*/ new Vector3();\nconst _f1 = /*@__PURE__*/ new Vector3();\nconst _f2 = /*@__PURE__*/ new Vector3();\n\nconst _center = /*@__PURE__*/ new Vector3();\nconst _extents = /*@__PURE__*/ new Vector3();\nconst _triangleNormal = /*@__PURE__*/ new Vector3();\nconst _testAxis = /*@__PURE__*/ new Vector3();\n\nfunction satForAxes(axes: Array<number>, v0: Vector3, v1: Vector3, v2: Vector3, extents: Vector3) {\n    for (let i = 0, j = axes.length - 3; i <= j; i += 3) {\n        _testAxis.fromArray(axes, i);\n        // project the aabb onto the separating axis\n        const r =\n            extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);\n        // project all 3 vertices of the triangle onto the separating axis\n        const p0 = v0.dot(_testAxis);\n        const p1 = v1.dot(_testAxis);\n        const p2 = v2.dot(_testAxis);\n        // actual test, basically see if either of the most extreme of the triangle points intersects r\n        if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n            // points of the projected triangle are outside the projected half-length of the aabb\n            // the axis is separating and we can exit\n            return false;\n        }\n    }\n\n    return true;\n}\n","import { clamp, euclideanModulo, lerp } from \"./MathUtils\";\nimport { ColorManagement, SRGBToLinear, LinearToSRGB } from \"./ColorManagement\";\nimport { Vector3 } from \"./Vector3\";\nimport { Matrix3 } from \"./Matrix3\";\n\nexport const SRGBColorSpace = \"srgb\";\nconst _colorKeywords: any = {\n    aliceblue: 0xf0f8ff,\n    antiquewhite: 0xfaebd7,\n    aqua: 0x00ffff,\n    aquamarine: 0x7fffd4,\n    azure: 0xf0ffff,\n    beige: 0xf5f5dc,\n    bisque: 0xffe4c4,\n    black: 0x000000,\n    blanchedalmond: 0xffebcd,\n    blue: 0x0000ff,\n    blueviolet: 0x8a2be2,\n    brown: 0xa52a2a,\n    burlywood: 0xdeb887,\n    cadetblue: 0x5f9ea0,\n    chartreuse: 0x7fff00,\n    chocolate: 0xd2691e,\n    coral: 0xff7f50,\n    cornflowerblue: 0x6495ed,\n    cornsilk: 0xfff8dc,\n    crimson: 0xdc143c,\n    cyan: 0x00ffff,\n    darkblue: 0x00008b,\n    darkcyan: 0x008b8b,\n    darkgoldenrod: 0xb8860b,\n    darkgray: 0xa9a9a9,\n    darkgreen: 0x006400,\n    darkgrey: 0xa9a9a9,\n    darkkhaki: 0xbdb76b,\n    darkmagenta: 0x8b008b,\n    darkolivegreen: 0x556b2f,\n    darkorange: 0xff8c00,\n    darkorchid: 0x9932cc,\n    darkred: 0x8b0000,\n    darksalmon: 0xe9967a,\n    darkseagreen: 0x8fbc8f,\n    darkslateblue: 0x483d8b,\n    darkslategray: 0x2f4f4f,\n    darkslategrey: 0x2f4f4f,\n    darkturquoise: 0x00ced1,\n    darkviolet: 0x9400d3,\n    deeppink: 0xff1493,\n    deepskyblue: 0x00bfff,\n    dimgray: 0x696969,\n    dimgrey: 0x696969,\n    dodgerblue: 0x1e90ff,\n    firebrick: 0xb22222,\n    floralwhite: 0xfffaf0,\n    forestgreen: 0x228b22,\n    fuchsia: 0xff00ff,\n    gainsboro: 0xdcdcdc,\n    ghostwhite: 0xf8f8ff,\n    gold: 0xffd700,\n    goldenrod: 0xdaa520,\n    gray: 0x808080,\n    green: 0x008000,\n    greenyellow: 0xadff2f,\n    grey: 0x808080,\n    honeydew: 0xf0fff0,\n    hotpink: 0xff69b4,\n    indianred: 0xcd5c5c,\n    indigo: 0x4b0082,\n    ivory: 0xfffff0,\n    khaki: 0xf0e68c,\n    lavender: 0xe6e6fa,\n    lavenderblush: 0xfff0f5,\n    lawngreen: 0x7cfc00,\n    lemonchiffon: 0xfffacd,\n    lightblue: 0xadd8e6,\n    lightcoral: 0xf08080,\n    lightcyan: 0xe0ffff,\n    lightgoldenrodyellow: 0xfafad2,\n    lightgray: 0xd3d3d3,\n    lightgreen: 0x90ee90,\n    lightgrey: 0xd3d3d3,\n    lightpink: 0xffb6c1,\n    lightsalmon: 0xffa07a,\n    lightseagreen: 0x20b2aa,\n    lightskyblue: 0x87cefa,\n    lightslategray: 0x778899,\n    lightslategrey: 0x778899,\n    lightsteelblue: 0xb0c4de,\n    lightyellow: 0xffffe0,\n    lime: 0x00ff00,\n    limegreen: 0x32cd32,\n    linen: 0xfaf0e6,\n    magenta: 0xff00ff,\n    maroon: 0x800000,\n    mediumaquamarine: 0x66cdaa,\n    mediumblue: 0x0000cd,\n    mediumorchid: 0xba55d3,\n    mediumpurple: 0x9370db,\n    mediumseagreen: 0x3cb371,\n    mediumslateblue: 0x7b68ee,\n    mediumspringgreen: 0x00fa9a,\n    mediumturquoise: 0x48d1cc,\n    mediumvioletred: 0xc71585,\n    midnightblue: 0x191970,\n    mintcream: 0xf5fffa,\n    mistyrose: 0xffe4e1,\n    moccasin: 0xffe4b5,\n    navajowhite: 0xffdead,\n    navy: 0x000080,\n    oldlace: 0xfdf5e6,\n    olive: 0x808000,\n    olivedrab: 0x6b8e23,\n    orange: 0xffa500,\n    orangered: 0xff4500,\n    orchid: 0xda70d6,\n    palegoldenrod: 0xeee8aa,\n    palegreen: 0x98fb98,\n    paleturquoise: 0xafeeee,\n    palevioletred: 0xdb7093,\n    papayawhip: 0xffefd5,\n    peachpuff: 0xffdab9,\n    peru: 0xcd853f,\n    pink: 0xffc0cb,\n    plum: 0xdda0dd,\n    powderblue: 0xb0e0e6,\n    purple: 0x800080,\n    rebeccapurple: 0x663399,\n    red: 0xff0000,\n    rosybrown: 0xbc8f8f,\n    royalblue: 0x4169e1,\n    saddlebrown: 0x8b4513,\n    salmon: 0xfa8072,\n    sandybrown: 0xf4a460,\n    seagreen: 0x2e8b57,\n    seashell: 0xfff5ee,\n    sienna: 0xa0522d,\n    silver: 0xc0c0c0,\n    skyblue: 0x87ceeb,\n    slateblue: 0x6a5acd,\n    slategray: 0x708090,\n    slategrey: 0x708090,\n    snow: 0xfffafa,\n    springgreen: 0x00ff7f,\n    steelblue: 0x4682b4,\n    tan: 0xd2b48c,\n    teal: 0x008080,\n    thistle: 0xd8bfd8,\n    tomato: 0xff6347,\n    turquoise: 0x40e0d0,\n    violet: 0xee82ee,\n    wheat: 0xf5deb3,\n    white: 0xffffff,\n    whitesmoke: 0xf5f5f5,\n    yellow: 0xffff00,\n    yellowgreen: 0x9acd32,\n};\n\ninterface HSL {\n    h: number;\n    l: number;\n    s: number;\n}\n\nconst _hslA: HSL = { h: 0, s: 0, l: 0 };\nconst _hslB: HSL = { h: 0, s: 0, l: 0 };\n\nfunction hue2rgb(p: number, q: number, t: number) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\n    return p;\n}\n\nclass Color {\n    static NAMES = _colorKeywords;\n    public r: number;\n    public g: number;\n    public b: number;\n\n    constructor(r: number | string = 0, g?: number, b?: number) {\n        return this.set(r, g, b);\n    }\n\n    set(r: number | string, g: number, b: number) {\n        if (g === undefined && b === undefined) {\n            const value = r;\n\n            if (typeof value === \"number\") {\n                this.setHex(value);\n            } else if (typeof value === \"string\") {\n                this.setStyle(value);\n            }\n        } else if (typeof r === \"number\") {\n            this.setRGB(r, g, b);\n        } else {\n            throw \"Color parameter error!\";\n        }\n\n        return this;\n    }\n\n    setScalar(scalar: number) {\n        this.r = scalar;\n        this.g = scalar;\n        this.b = scalar;\n\n        return this;\n    }\n\n    setHex(hex: number, colorSpace = SRGBColorSpace) {\n        hex = Math.floor(hex);\n\n        this.r = ((hex >> 16) & 255) / 255;\n        this.g = ((hex >> 8) & 255) / 255;\n        this.b = (hex & 255) / 255;\n\n        ColorManagement.toWorkingColorSpace(this, colorSpace);\n\n        return this;\n    }\n\n    setRGB(r: number, g: number, b: number, colorSpace = ColorManagement.workingColorSpace) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n\n        ColorManagement.toWorkingColorSpace(this, colorSpace);\n\n        return this;\n    }\n\n    setHSL(h: number, s: number, l: number, colorSpace = ColorManagement.workingColorSpace) {\n        // h,s,l ranges are in 0.0 - 1.0\n        h = euclideanModulo(h, 1);\n        s = clamp(s, 0, 1);\n        l = clamp(l, 0, 1);\n\n        if (s === 0) {\n            this.r = this.g = this.b = l;\n        } else {\n            const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n            const q = 2 * l - p;\n\n            this.r = hue2rgb(q, p, h + 1 / 3);\n            this.g = hue2rgb(q, p, h);\n            this.b = hue2rgb(q, p, h - 1 / 3);\n        }\n\n        ColorManagement.toWorkingColorSpace(this, colorSpace);\n\n        return this;\n    }\n\n    setStyle(style: string, colorSpace = SRGBColorSpace) {\n        function handleAlpha(string: string) {\n            if (string === undefined) return;\n\n            if (parseFloat(string) < 1) {\n                console.warn(\"THREE.Color: Alpha component of \" + style + \" will be ignored.\");\n            }\n        }\n\n        let m;\n\n        if ((m = /^(\\w+)\\(([^\\)]*)\\)/.exec(style))) {\n            // rgb / hsl\n\n            let color;\n            const name = m[1];\n            const components = m[2];\n\n            switch (name) {\n                case \"rgb\":\n                case \"rgba\":\n                    if ((color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components))) {\n                        // rgb(255,0,0) rgba(255,0,0,0.5)\n\n                        handleAlpha(color[4]);\n\n                        return this.setRGB(\n                            Math.min(255, parseInt(color[1], 10)) / 255,\n                            Math.min(255, parseInt(color[2], 10)) / 255,\n                            Math.min(255, parseInt(color[3], 10)) / 255,\n                            colorSpace\n                        );\n                    }\n\n                    if (\n                        (color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components))\n                    ) {\n                        // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\n                        handleAlpha(color[4]);\n\n                        return this.setRGB(\n                            Math.min(100, parseInt(color[1], 10)) / 100,\n                            Math.min(100, parseInt(color[2], 10)) / 100,\n                            Math.min(100, parseInt(color[3], 10)) / 100,\n                            colorSpace\n                        );\n                    }\n\n                    break;\n\n                case \"hsl\":\n                case \"hsla\":\n                    if (\n                        (color =\n                            /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(\n                                components\n                            ))\n                    ) {\n                        // hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\n                        handleAlpha(color[4]);\n\n                        return this.setHSL(\n                            parseFloat(color[1]) / 360,\n                            parseFloat(color[2]) / 100,\n                            parseFloat(color[3]) / 100,\n                            colorSpace\n                        );\n                    }\n\n                    break;\n\n                default:\n                    console.warn(\"THREE.Color: Unknown color model \" + style);\n            }\n        } else if ((m = /^\\#([A-Fa-f\\d]+)$/.exec(style))) {\n            // hex color\n\n            const hex = m[1];\n            const size = hex.length;\n\n            if (size === 3) {\n                // #ff0\n                return this.setRGB(\n                    parseInt(hex.charAt(0), 16) / 15,\n                    parseInt(hex.charAt(1), 16) / 15,\n                    parseInt(hex.charAt(2), 16) / 15,\n                    colorSpace\n                );\n            } else if (size === 6) {\n                // #ff0000\n                return this.setHex(parseInt(hex, 16), colorSpace);\n            } else {\n                console.warn(\"THREE.Color: Invalid hex color \" + style);\n            }\n        } else if (style && style.length > 0) {\n            return this.setColorName(style, colorSpace);\n        }\n\n        return this;\n    }\n\n    setColorName(style: string, colorSpace = SRGBColorSpace) {\n        // color keywords\n        const hex = _colorKeywords[style.toLowerCase()];\n\n        if (hex !== undefined) {\n            // red\n            this.setHex(hex, colorSpace);\n        } else {\n            // unknown color\n            console.warn(\"THREE.Color: Unknown color \" + style);\n        }\n\n        return this;\n    }\n\n    clone() {\n        return new Color(this.r, this.g, this.b);\n    }\n\n    copy(color: Color) {\n        this.r = color.r;\n        this.g = color.g;\n        this.b = color.b;\n\n        return this;\n    }\n\n    copySRGBToLinear(color: Color) {\n        this.r = SRGBToLinear(color.r);\n        this.g = SRGBToLinear(color.g);\n        this.b = SRGBToLinear(color.b);\n\n        return this;\n    }\n\n    copyLinearToSRGB(color: Color) {\n        this.r = LinearToSRGB(color.r);\n        this.g = LinearToSRGB(color.g);\n        this.b = LinearToSRGB(color.b);\n\n        return this;\n    }\n\n    convertSRGBToLinear() {\n        this.copySRGBToLinear(this);\n\n        return this;\n    }\n\n    convertLinearToSRGB() {\n        this.copyLinearToSRGB(this);\n\n        return this;\n    }\n\n    getHex(colorSpace = SRGBColorSpace) {\n        ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n\n        return (\n            Math.round(clamp(_color.r * 255, 0, 255)) * 65536 +\n            Math.round(clamp(_color.g * 255, 0, 255)) * 256 +\n            Math.round(clamp(_color.b * 255, 0, 255))\n        );\n    }\n\n    getHexString(colorSpace = SRGBColorSpace) {\n        return (\"000000\" + this.getHex(colorSpace).toString(16)).slice(-6);\n    }\n\n    getHSL(target: HSL, colorSpace = ColorManagement.workingColorSpace) {\n        // h,s,l ranges are in 0.0 - 1.0\n\n        ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n\n        const r = _color.r,\n            g = _color.g,\n            b = _color.b;\n\n        const max = Math.max(r, g, b);\n        const min = Math.min(r, g, b);\n\n        let hue, saturation;\n        const lightness = (min + max) / 2.0;\n\n        if (min === max) {\n            hue = 0;\n            saturation = 0;\n        } else {\n            const delta = max - min;\n\n            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);\n\n            switch (max) {\n                case r:\n                    hue = (g - b) / delta + (g < b ? 6 : 0);\n                    break;\n                case g:\n                    hue = (b - r) / delta + 2;\n                    break;\n                case b:\n                    hue = (r - g) / delta + 4;\n                    break;\n            }\n\n            hue /= 6;\n        }\n\n        target.h = hue;\n        target.s = saturation;\n        target.l = lightness;\n\n        return target;\n    }\n\n    getRGB(target: Color, colorSpace = ColorManagement.workingColorSpace) {\n        ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n\n        target.r = _color.r;\n        target.g = _color.g;\n        target.b = _color.b;\n\n        return target;\n    }\n\n    getStyle(colorSpace = SRGBColorSpace) {\n        ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n\n        const r = _color.r,\n            g = _color.g,\n            b = _color.b;\n\n        if (colorSpace !== SRGBColorSpace) {\n            // Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).\n            return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;\n        }\n\n        return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;\n    }\n\n    offsetHSL(h: number, s: number, l: number) {\n        this.getHSL(_hslA);\n\n        _hslA.h += h;\n        _hslA.s += s;\n        _hslA.l += l;\n\n        this.setHSL(_hslA.h, _hslA.s, _hslA.l);\n\n        return this;\n    }\n\n    add(color: Color) {\n        this.r += color.r;\n        this.g += color.g;\n        this.b += color.b;\n\n        return this;\n    }\n\n    addColors(color1: Color, color2: Color) {\n        this.r = color1.r + color2.r;\n        this.g = color1.g + color2.g;\n        this.b = color1.b + color2.b;\n\n        return this;\n    }\n\n    addScalar(s: number) {\n        this.r += s;\n        this.g += s;\n        this.b += s;\n\n        return this;\n    }\n\n    sub(color: Color) {\n        this.r = Math.max(0, this.r - color.r);\n        this.g = Math.max(0, this.g - color.g);\n        this.b = Math.max(0, this.b - color.b);\n\n        return this;\n    }\n\n    multiply(color: Color) {\n        this.r *= color.r;\n        this.g *= color.g;\n        this.b *= color.b;\n\n        return this;\n    }\n\n    multiplyScalar(s: number) {\n        this.r *= s;\n        this.g *= s;\n        this.b *= s;\n\n        return this;\n    }\n\n    lerp(color: Color, alpha: number) {\n        this.r += (color.r - this.r) * alpha;\n        this.g += (color.g - this.g) * alpha;\n        this.b += (color.b - this.b) * alpha;\n\n        return this;\n    }\n\n    lerpColors(color1: Color, color2: Color, alpha: number) {\n        this.r = color1.r + (color2.r - color1.r) * alpha;\n        this.g = color1.g + (color2.g - color1.g) * alpha;\n        this.b = color1.b + (color2.b - color1.b) * alpha;\n\n        return this;\n    }\n\n    lerpHSL(color: Color, alpha: number) {\n        this.getHSL(_hslA);\n        color.getHSL(_hslB);\n\n        const h = lerp(_hslA.h, _hslB.h, alpha);\n        const s = lerp(_hslA.s, _hslB.s, alpha);\n        const l = lerp(_hslA.l, _hslB.l, alpha);\n\n        this.setHSL(h, s, l);\n\n        return this;\n    }\n\n    setFromVector3(v: Vector3) {\n        this.r = v.x;\n        this.g = v.y;\n        this.b = v.z;\n\n        return this;\n    }\n\n    applyMatrix3(m: Matrix3) {\n        const r = this.r,\n            g = this.g,\n            b = this.b;\n        const e = m.elements;\n\n        this.r = e[0] * r + e[3] * g + e[6] * b;\n        this.g = e[1] * r + e[4] * g + e[7] * b;\n        this.b = e[2] * r + e[5] * g + e[8] * b;\n\n        return this;\n    }\n\n    equals(c: Color) {\n        return c.r === this.r && c.g === this.g && c.b === this.b;\n    }\n\n    fromArray(array: ArrayLike<number>, offset = 0) {\n        this.r = array[offset];\n        this.g = array[offset + 1];\n        this.b = array[offset + 2];\n\n        return this;\n    }\n\n    toArray(array: Float32Array = new Float32Array(3), offset = 0) {\n        array[offset] = this.r;\n        array[offset + 1] = this.g;\n        array[offset + 2] = this.b;\n\n        return array;\n    }\n\n    // fromBufferAttribute( attribute, index ) {\n\n    // \tthis.r = attribute.getX( index );\n    // \tthis.g = attribute.getY( index );\n    // \tthis.b = attribute.getZ( index );\n\n    // \treturn this;\n\n    // }\n\n    toJSON() {\n        return this.getHex();\n    }\n\n    *[Symbol.iterator]() {\n        yield this.r;\n        yield this.g;\n        yield this.b;\n    }\n}\n\nconst _color = /*@__PURE__*/ new Color();\n\nexport { Color };\n","import { Color } from \"./Color\";\nimport { Matrix3 } from \"./Matrix3\";\n\nexport const SRGBColorSpace = \"srgb\";\nexport const LinearSRGBColorSpace = \"srgb-linear\";\nexport const DisplayP3ColorSpace = \"display-p3\";\n\nexport function SRGBToLinear(c: number) {\n    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n}\n\nexport function LinearToSRGB(c: number) {\n    return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\n}\n\n/**\n * Matrices converting P3 <-> Rec. 709 primaries, without gamut mapping\n * or clipping. Based on W3C specifications for sRGB and Display P3,\n * and ICC specifications for the D50 connection space. Values in/out\n * are _linear_ sRGB and _linear_ Display P3.\n *\n * Note that both sRGB and Display P3 use the sRGB transfer functions.\n *\n * Reference:\n * - http://www.russellcottrell.com/photo/matrixCalculator.htm\n */\n\nconst LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /*@__PURE__*/ new Matrix3().fromArray([\n    0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974, -0.0000001, 0.0000001, 0.9105199,\n]);\n\nconst LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /*@__PURE__*/ new Matrix3().fromArray([\n    1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361, 0.0000001, 0.0, 1.0982735,\n]);\n\nfunction DisplayP3ToLinearSRGB(color: Color) {\n    // Display P3 uses the sRGB transfer functions\n    return color.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB);\n}\n\nfunction LinearSRGBToDisplayP3(color: Color) {\n    // Display P3 uses the sRGB transfer functions\n    return color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB();\n}\n\n// Conversions from <source> to Linear-sRGB reference space.\nconst TO_LINEAR: any = {\n    [LinearSRGBColorSpace]: (color: Color) => color,\n    [SRGBColorSpace]: (color: Color) => color.convertSRGBToLinear(),\n    [DisplayP3ColorSpace]: DisplayP3ToLinearSRGB,\n};\n\n// Conversions to <target> from Linear-sRGB reference space.\nconst FROM_LINEAR: any = {\n    [LinearSRGBColorSpace]: (color: Color) => color,\n    [SRGBColorSpace]: (color: Color) => color.convertLinearToSRGB(),\n    [DisplayP3ColorSpace]: LinearSRGBToDisplayP3,\n};\n\nexport const ColorManagement = {\n    enabled: true,\n\n    get legacyMode() {\n        console.warn(\"THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.\");\n\n        return !this.enabled;\n    },\n\n    set legacyMode(legacyMode) {\n        console.warn(\"THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.\");\n\n        this.enabled = !legacyMode;\n    },\n\n    get workingColorSpace() {\n        return LinearSRGBColorSpace;\n    },\n\n    set workingColorSpace(colorSpace) {\n        console.warn(\"THREE.ColorManagement: .workingColorSpace is readonly.\");\n    },\n\n    convert: function (color: Color, sourceColorSpace: string, targetColorSpace: string) {\n        if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {\n            return color;\n        }\n\n        const sourceToLinear = TO_LINEAR[sourceColorSpace];\n        const targetFromLinear = FROM_LINEAR[targetColorSpace];\n\n        if (sourceToLinear === undefined || targetFromLinear === undefined) {\n            throw new Error(`Unsupported color space conversion, \"${sourceColorSpace}\" to \"${targetColorSpace}\".`);\n        }\n\n        return targetFromLinear(sourceToLinear(color));\n    },\n\n    fromWorkingColorSpace: function (color: Color, targetColorSpace: string) {\n        return this.convert(color, this.workingColorSpace, targetColorSpace);\n    },\n\n    toWorkingColorSpace: function (color: Color, sourceColorSpace: string) {\n        return this.convert(color, sourceColorSpace, this.workingColorSpace);\n    },\n};\n","import { Quaternion } from \"./Quaternion\";\nimport { Matrix4 } from \"./Matrix4\";\nimport { clamp } from \"./MathUtils\";\nimport { Vector3 } from \"./Vector3\";\n\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _quaternion = /*@__PURE__*/ new Quaternion();\n\nclass Euler {\n    private static DEFAULT_ORDER = \"XYZ\";\n\n    private _x = 0;\n    private _y = 0;\n    private _z = 0;\n    private _order = Euler.DEFAULT_ORDER;\n\n    private _onChangeCallback = (e: Euler) => {};\n\n    public set x(v: number) {\n        this._x = v;\n        this._onChangeCallback(this);\n    }\n    public get x() {\n        return this._x;\n    }\n    public set y(v: number) {\n        this._y = v;\n        this._onChangeCallback(this);\n    }\n    public get y() {\n        return this._y;\n    }\n    public set z(v: number) {\n        this._z = v;\n        this._onChangeCallback(this);\n    }\n    public get z() {\n        return this._z;\n    }\n    public set order(v: string) {\n        this._order = v;\n        this._onChangeCallback(this);\n    }\n    public get order() {\n        return this._order;\n    }\n\n    constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {\n        this._x = x;\n        this._y = y;\n        this._z = z;\n        this.order = order;\n    }\n\n    set(x: number, y: number, z: number, order = this.order) {\n        this._x = x;\n        this._y = y;\n        this._z = z;\n        this._order = order;\n\n        this._onChangeCallback(this);\n\n        return this;\n    }\n\n    clone() {\n        return new Euler(this.x, this.y, this.z, this.order);\n    }\n\n    copy(euler: Euler) {\n        this._x = euler.x;\n        this._y = euler.y;\n        this._z = euler.z;\n        this._order = euler.order;\n\n        this._onChangeCallback(this);\n\n        return this;\n    }\n\n    setFromRotationMatrix(m: Matrix4, order = this.order, update = true) {\n        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        const te = m.elements;\n        const m11 = te[0],\n            m12 = te[4],\n            m13 = te[8];\n        const m21 = te[1],\n            m22 = te[5],\n            m23 = te[9];\n        const m31 = te[2],\n            m32 = te[6],\n            m33 = te[10];\n\n        switch (order) {\n            case \"XYZ\":\n                this._y = Math.asin(clamp(m13, -1, 1));\n\n                if (Math.abs(m13) < 0.9999999) {\n                    this._x = Math.atan2(-m23, m33);\n                    this._z = Math.atan2(-m12, m11);\n                } else {\n                    this._x = Math.atan2(m32, m22);\n                    this._z = 0;\n                }\n\n                break;\n\n            case \"YXZ\":\n                this._x = Math.asin(-clamp(m23, -1, 1));\n\n                if (Math.abs(m23) < 0.9999999) {\n                    this._y = Math.atan2(m13, m33);\n                    this._z = Math.atan2(m21, m22);\n                } else {\n                    this._y = Math.atan2(-m31, m11);\n                    this._z = 0;\n                }\n\n                break;\n\n            case \"ZXY\":\n                this._x = Math.asin(clamp(m32, -1, 1));\n\n                if (Math.abs(m32) < 0.9999999) {\n                    this._y = Math.atan2(-m31, m33);\n                    this._z = Math.atan2(-m12, m22);\n                } else {\n                    this._y = 0;\n                    this._z = Math.atan2(m21, m11);\n                }\n\n                break;\n\n            case \"ZYX\":\n                this._y = Math.asin(-clamp(m31, -1, 1));\n\n                if (Math.abs(m31) < 0.9999999) {\n                    this._x = Math.atan2(m32, m33);\n                    this._z = Math.atan2(m21, m11);\n                } else {\n                    this._x = 0;\n                    this._z = Math.atan2(-m12, m22);\n                }\n\n                break;\n\n            case \"YZX\":\n                this._z = Math.asin(clamp(m21, -1, 1));\n\n                if (Math.abs(m21) < 0.9999999) {\n                    this._x = Math.atan2(-m23, m22);\n                    this._y = Math.atan2(-m31, m11);\n                } else {\n                    this._x = 0;\n                    this._y = Math.atan2(m13, m33);\n                }\n\n                break;\n\n            case \"XZY\":\n                this._z = Math.asin(-clamp(m12, -1, 1));\n\n                if (Math.abs(m12) < 0.9999999) {\n                    this._x = Math.atan2(m32, m22);\n                    this._y = Math.atan2(m13, m11);\n                } else {\n                    this._x = Math.atan2(-m23, m33);\n                    this._y = 0;\n                }\n\n                break;\n\n            default:\n                console.warn(\"THREE.Euler: .setFromRotationMatrix() encountered an unknown order: \" + order);\n        }\n\n        this._order = order;\n\n        if (update) this._onChangeCallback(this);\n\n        return this;\n    }\n\n    setFromQuaternion(q: Quaternion, order: string, update = true) {\n        _matrix.makeRotationFromQuaternion(q);\n\n        return this.setFromRotationMatrix(_matrix, order, update);\n    }\n\n    setFromVector3(v: Vector3, order = this.order) {\n        return this.set(v.x, v.y, v.z, order);\n    }\n\n    reorder(newOrder: string) {\n        // WARNING: this discards revolution information -bhouston\n\n        _quaternion.setFromEuler(this);\n\n        return this.setFromQuaternion(_quaternion, newOrder);\n    }\n\n    equals(euler: Euler) {\n        return euler.x === this.x && euler.y === this.y && euler.z === this.z && euler.order === this.order;\n    }\n\n    fromArray(array: Array<any>) {\n        this._x = array[0];\n        this._y = array[1];\n        this._z = array[2];\n        if (array[3] !== undefined) this._order = array[3];\n\n        this._onChangeCallback(this);\n\n        return this;\n    }\n\n    toArray(array: Array<number | string> = [], offset = 0) {\n        array[offset] = this.x;\n        array[offset + 1] = this.y;\n        array[offset + 2] = this.z;\n        array[offset + 3] = this.order;\n\n        return array;\n    }\n\n    public onChange(callback: (q: Euler) => void) {\n        this._onChangeCallback = callback;\n    }\n\n    *[Symbol.iterator]() {\n        yield this.x;\n        yield this.y;\n        yield this.z;\n        yield this.order;\n    }\n}\n\nexport { Euler };\n","import { RenderableObject } from \"../core/RenderableObject\";\nimport { Box3 } from \"./Box3\";\nimport { Matrix4 } from \"./Matrix4\";\nimport { Plane } from \"./Plane\";\nimport { Sphere } from \"./Sphere\";\nimport { Vector3 } from \"./Vector3\";\n\nconst _sphere = /*@__PURE__*/ new Sphere();\nconst _vector = /*@__PURE__*/ new Vector3();\n\nclass Frustum {\n    public planes: Array<Plane>;\n\n    constructor(\n        p0 = new Plane(),\n        p1 = new Plane(),\n        p2 = new Plane(),\n        p3 = new Plane(),\n        p4 = new Plane(),\n        p5 = new Plane()\n    ) {\n        this.planes = [p0, p1, p2, p3, p4, p5];\n    }\n\n    set(p0: Plane, p1: Plane, p2: Plane, p3: Plane, p4: Plane, p5: Plane) {\n        const planes = this.planes;\n\n        planes[0].copy(p0);\n        planes[1].copy(p1);\n        planes[2].copy(p2);\n        planes[3].copy(p3);\n        planes[4].copy(p4);\n        planes[5].copy(p5);\n\n        return this;\n    }\n\n    copy(frustum: Frustum) {\n        const planes = this.planes;\n\n        for (let i = 0; i < 6; i++) {\n            planes[i].copy(frustum.planes[i]);\n        }\n\n        return this;\n    }\n\n    setFromProjectionMatrix(m: Matrix4) {\n        const planes = this.planes;\n        const me = m.elements;\n        const me0 = me[0],\n            me1 = me[1],\n            me2 = me[2],\n            me3 = me[3];\n        const me4 = me[4],\n            me5 = me[5],\n            me6 = me[6],\n            me7 = me[7];\n        const me8 = me[8],\n            me9 = me[9],\n            me10 = me[10],\n            me11 = me[11];\n        const me12 = me[12],\n            me13 = me[13],\n            me14 = me[14],\n            me15 = me[15];\n\n        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();\n        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();\n        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();\n        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();\n        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();\n        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();\n\n        return this;\n    }\n\n    intersectsObject(object: RenderableObject) {\n        if (object.boundingSphere !== undefined) {\n            if (object.boundingSphere === null) object.computeBoundingSphere();\n\n            _sphere.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);\n        } else {\n            const geometry = object.geometry;\n\n            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n            _sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);\n        }\n\n        return this.intersectsSphere(_sphere);\n    }\n\n    // intersectsSprite( sprite ) {\n\n    // \t_sphere.center.set( 0, 0, 0 );\n    // \t_sphere.radius = 0.7071067811865476;\n    // \t_sphere.applyMatrix4( sprite.matrixWorld );\n\n    // \treturn this.intersectsSphere( _sphere );\n\n    // }\n\n    intersectsSphere(sphere: Sphere) {\n        const planes = this.planes;\n        const center = sphere.center;\n        const negRadius = -sphere.radius;\n\n        for (let i = 0; i < 6; i++) {\n            const distance = planes[i].distanceToPoint(center);\n\n            if (distance < negRadius) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    intersectsBox(box: Box3) {\n        const planes = this.planes;\n\n        for (let i = 0; i < 6; i++) {\n            const plane = planes[i];\n\n            // corner at max distance\n\n            _vector.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n            _vector.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n            _vector.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n            if (plane.distanceToPoint(_vector) < 0) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    containsPoint(point: Vector3) {\n        const planes = this.planes;\n\n        for (let i = 0; i < 6; i++) {\n            if (planes[i].distanceToPoint(point) < 0) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    clone() {\n        return new Frustum().copy(this);\n    }\n}\n\nexport { Frustum };\n","import { NumberArrayType } from \"../Constants\";\n\nconst _lut = [\n    \"00\",\n    \"01\",\n    \"02\",\n    \"03\",\n    \"04\",\n    \"05\",\n    \"06\",\n    \"07\",\n    \"08\",\n    \"09\",\n    \"0a\",\n    \"0b\",\n    \"0c\",\n    \"0d\",\n    \"0e\",\n    \"0f\",\n    \"10\",\n    \"11\",\n    \"12\",\n    \"13\",\n    \"14\",\n    \"15\",\n    \"16\",\n    \"17\",\n    \"18\",\n    \"19\",\n    \"1a\",\n    \"1b\",\n    \"1c\",\n    \"1d\",\n    \"1e\",\n    \"1f\",\n    \"20\",\n    \"21\",\n    \"22\",\n    \"23\",\n    \"24\",\n    \"25\",\n    \"26\",\n    \"27\",\n    \"28\",\n    \"29\",\n    \"2a\",\n    \"2b\",\n    \"2c\",\n    \"2d\",\n    \"2e\",\n    \"2f\",\n    \"30\",\n    \"31\",\n    \"32\",\n    \"33\",\n    \"34\",\n    \"35\",\n    \"36\",\n    \"37\",\n    \"38\",\n    \"39\",\n    \"3a\",\n    \"3b\",\n    \"3c\",\n    \"3d\",\n    \"3e\",\n    \"3f\",\n    \"40\",\n    \"41\",\n    \"42\",\n    \"43\",\n    \"44\",\n    \"45\",\n    \"46\",\n    \"47\",\n    \"48\",\n    \"49\",\n    \"4a\",\n    \"4b\",\n    \"4c\",\n    \"4d\",\n    \"4e\",\n    \"4f\",\n    \"50\",\n    \"51\",\n    \"52\",\n    \"53\",\n    \"54\",\n    \"55\",\n    \"56\",\n    \"57\",\n    \"58\",\n    \"59\",\n    \"5a\",\n    \"5b\",\n    \"5c\",\n    \"5d\",\n    \"5e\",\n    \"5f\",\n    \"60\",\n    \"61\",\n    \"62\",\n    \"63\",\n    \"64\",\n    \"65\",\n    \"66\",\n    \"67\",\n    \"68\",\n    \"69\",\n    \"6a\",\n    \"6b\",\n    \"6c\",\n    \"6d\",\n    \"6e\",\n    \"6f\",\n    \"70\",\n    \"71\",\n    \"72\",\n    \"73\",\n    \"74\",\n    \"75\",\n    \"76\",\n    \"77\",\n    \"78\",\n    \"79\",\n    \"7a\",\n    \"7b\",\n    \"7c\",\n    \"7d\",\n    \"7e\",\n    \"7f\",\n    \"80\",\n    \"81\",\n    \"82\",\n    \"83\",\n    \"84\",\n    \"85\",\n    \"86\",\n    \"87\",\n    \"88\",\n    \"89\",\n    \"8a\",\n    \"8b\",\n    \"8c\",\n    \"8d\",\n    \"8e\",\n    \"8f\",\n    \"90\",\n    \"91\",\n    \"92\",\n    \"93\",\n    \"94\",\n    \"95\",\n    \"96\",\n    \"97\",\n    \"98\",\n    \"99\",\n    \"9a\",\n    \"9b\",\n    \"9c\",\n    \"9d\",\n    \"9e\",\n    \"9f\",\n    \"a0\",\n    \"a1\",\n    \"a2\",\n    \"a3\",\n    \"a4\",\n    \"a5\",\n    \"a6\",\n    \"a7\",\n    \"a8\",\n    \"a9\",\n    \"aa\",\n    \"ab\",\n    \"ac\",\n    \"ad\",\n    \"ae\",\n    \"af\",\n    \"b0\",\n    \"b1\",\n    \"b2\",\n    \"b3\",\n    \"b4\",\n    \"b5\",\n    \"b6\",\n    \"b7\",\n    \"b8\",\n    \"b9\",\n    \"ba\",\n    \"bb\",\n    \"bc\",\n    \"bd\",\n    \"be\",\n    \"bf\",\n    \"c0\",\n    \"c1\",\n    \"c2\",\n    \"c3\",\n    \"c4\",\n    \"c5\",\n    \"c6\",\n    \"c7\",\n    \"c8\",\n    \"c9\",\n    \"ca\",\n    \"cb\",\n    \"cc\",\n    \"cd\",\n    \"ce\",\n    \"cf\",\n    \"d0\",\n    \"d1\",\n    \"d2\",\n    \"d3\",\n    \"d4\",\n    \"d5\",\n    \"d6\",\n    \"d7\",\n    \"d8\",\n    \"d9\",\n    \"da\",\n    \"db\",\n    \"dc\",\n    \"dd\",\n    \"de\",\n    \"df\",\n    \"e0\",\n    \"e1\",\n    \"e2\",\n    \"e3\",\n    \"e4\",\n    \"e5\",\n    \"e6\",\n    \"e7\",\n    \"e8\",\n    \"e9\",\n    \"ea\",\n    \"eb\",\n    \"ec\",\n    \"ed\",\n    \"ee\",\n    \"ef\",\n    \"f0\",\n    \"f1\",\n    \"f2\",\n    \"f3\",\n    \"f4\",\n    \"f5\",\n    \"f6\",\n    \"f7\",\n    \"f8\",\n    \"f9\",\n    \"fa\",\n    \"fb\",\n    \"fc\",\n    \"fd\",\n    \"fe\",\n    \"ff\",\n];\n\nlet _seed = 1234567;\n\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nfunction generateUUID() {\n    const d0 = (Math.random() * 0xffffffff) | 0;\n    const d1 = (Math.random() * 0xffffffff) | 0;\n    const d2 = (Math.random() * 0xffffffff) | 0;\n    const d3 = (Math.random() * 0xffffffff) | 0;\n    const uuid =\n        _lut[d0 & 0xff] +\n        _lut[(d0 >> 8) & 0xff] +\n        _lut[(d0 >> 16) & 0xff] +\n        _lut[(d0 >> 24) & 0xff] +\n        \"-\" +\n        _lut[d1 & 0xff] +\n        _lut[(d1 >> 8) & 0xff] +\n        \"-\" +\n        _lut[((d1 >> 16) & 0x0f) | 0x40] +\n        _lut[(d1 >> 24) & 0xff] +\n        \"-\" +\n        _lut[(d2 & 0x3f) | 0x80] +\n        _lut[(d2 >> 8) & 0xff] +\n        \"-\" +\n        _lut[(d2 >> 16) & 0xff] +\n        _lut[(d2 >> 24) & 0xff] +\n        _lut[d3 & 0xff] +\n        _lut[(d3 >> 8) & 0xff] +\n        _lut[(d3 >> 16) & 0xff] +\n        _lut[(d3 >> 24) & 0xff];\n\n    // .toLowerCase() here flattens concatenated strings to save heap memory space.\n    return uuid.toLowerCase();\n}\n\nfunction clamp(value: number, min: number, max: number) {\n    return Math.max(min, Math.min(max, value));\n}\n\n// compute euclidean modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo(n: number, m: number) {\n    return ((n % m) + m) % m;\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear(x: number, a1: number, a2: number, b1: number, b2: number) {\n    return b1 + ((x - a1) * (b2 - b1)) / (a2 - a1);\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp(x: number, y: number, value: number) {\n    if (x !== y) {\n        return (value - x) / (y - x);\n    } else {\n        return 0;\n    }\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp(x: number, y: number, t: number) {\n    return (1 - t) * x + t * y;\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp(x: number, y: number, lambda: number, dt: number) {\n    return lerp(x, y, 1 - Math.exp(-lambda * dt));\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong(x: number, length = 1) {\n    return length - Math.abs(euclideanModulo(x, length * 2) - length);\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep(x: number, min: number, max: number) {\n    if (x <= min) return 0;\n    if (x >= max) return 1;\n\n    x = (x - min) / (max - min);\n\n    return x * x * (3 - 2 * x);\n}\n\nfunction smootherstep(x: number, min: number, max: number) {\n    if (x <= min) return 0;\n    if (x >= max) return 1;\n\n    x = (x - min) / (max - min);\n\n    return x * x * x * (x * (x * 6 - 15) + 10);\n}\n\n// Random integer from <low, high> interval\nfunction randInt(low: number, high: number) {\n    return low + Math.floor(Math.random() * (high - low + 1));\n}\n\n// Random float from <low, high> interval\nfunction randFloat(low: number, high: number) {\n    return low + Math.random() * (high - low);\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread(range: number) {\n    return range * (0.5 - Math.random());\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom(s: number) {\n    if (s !== undefined) _seed = s;\n\n    // Mulberry32 generator\n\n    let t = (_seed += 0x6d2b79f5);\n\n    t = Math.imul(t ^ (t >>> 15), t | 1);\n\n    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);\n\n    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\n}\n\nfunction degToRad(degrees: number) {\n    return degrees * DEG2RAD;\n}\n\nfunction radToDeg(radians: number) {\n    return radians * RAD2DEG;\n}\n\nfunction isPowerOfTwo(value: number) {\n    return (value & (value - 1)) === 0 && value !== 0;\n}\n\nfunction ceilPowerOfTwo(value: number) {\n    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n}\n\nfunction floorPowerOfTwo(value: number) {\n    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));\n}\n\nfunction denormalize(value: number, array: NumberArrayType) {\n    switch (array.constructor) {\n        case Float32Array:\n            return value;\n\n        case Uint32Array:\n            return value / 4294967295.0;\n\n        case Uint16Array:\n            return value / 65535.0;\n\n        case Uint8Array:\n            return value / 255.0;\n\n        case Int32Array:\n            return Math.max(value / 2147483647.0, -1.0);\n\n        case Int16Array:\n            return Math.max(value / 32767.0, -1.0);\n\n        case Int8Array:\n            return Math.max(value / 127.0, -1.0);\n\n        default:\n            throw new Error(\"Invalid component type.\");\n    }\n}\n\nfunction normalize(value: number, array: NumberArrayType) {\n    switch (array.constructor) {\n        case Float32Array:\n            return value;\n\n        case Uint32Array:\n            return Math.round(value * 4294967295.0);\n\n        case Uint16Array:\n            return Math.round(value * 65535.0);\n\n        case Uint8Array:\n            return Math.round(value * 255.0);\n\n        case Int32Array:\n            return Math.round(value * 2147483647.0);\n\n        case Int16Array:\n            return Math.round(value * 32767.0);\n\n        case Int8Array:\n            return Math.round(value * 127.0);\n\n        default:\n            throw new Error(\"Invalid component type.\");\n    }\n}\n\nconst MathUtils = {\n    DEG2RAD: DEG2RAD,\n    RAD2DEG: RAD2DEG,\n    generateUUID: generateUUID,\n    clamp: clamp,\n    euclideanModulo: euclideanModulo,\n    mapLinear: mapLinear,\n    inverseLerp: inverseLerp,\n    lerp: lerp,\n    damp: damp,\n    pingpong: pingpong,\n    smoothstep: smoothstep,\n    smootherstep: smootherstep,\n    randInt: randInt,\n    randFloat: randFloat,\n    randFloatSpread: randFloatSpread,\n    seededRandom: seededRandom,\n    degToRad: degToRad,\n    radToDeg: radToDeg,\n    isPowerOfTwo: isPowerOfTwo,\n    ceilPowerOfTwo: ceilPowerOfTwo,\n    floorPowerOfTwo: floorPowerOfTwo,\n    normalize: normalize,\n    denormalize: denormalize,\n};\n\nexport {\n    DEG2RAD,\n    RAD2DEG,\n    generateUUID,\n    clamp,\n    euclideanModulo,\n    mapLinear,\n    inverseLerp,\n    lerp,\n    damp,\n    pingpong,\n    smoothstep,\n    smootherstep,\n    randInt,\n    randFloat,\n    randFloatSpread,\n    seededRandom,\n    degToRad,\n    radToDeg,\n    isPowerOfTwo,\n    ceilPowerOfTwo,\n    floorPowerOfTwo,\n    normalize,\n    denormalize,\n    MathUtils,\n};\n","import { Matrix4 } from \"./Matrix4\";\nimport { Vector2 } from \"./Vector2\";\nimport { Vector3 } from \"./Vector3\";\n\nclass Matrix3 {\n    public elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    constructor(n11 = 1, n12 = 0, n13 = 0, n21 = 0, n22 = 1, n23 = 0, n31 = 0, n32 = 0, n33 = 1) {\n        if (n11 !== undefined) {\n            this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);\n        }\n    }\n\n    set(n11 = 1, n12 = 0, n13 = 0, n21 = 0, n22 = 1, n23 = 0, n31 = 0, n32 = 0, n33 = 1) {\n        const te = this.elements;\n\n        te[0] = n11;\n        te[1] = n21;\n        te[2] = n31;\n        te[3] = n12;\n        te[4] = n22;\n        te[5] = n32;\n        te[6] = n13;\n        te[7] = n23;\n        te[8] = n33;\n\n        return this;\n    }\n\n    identity() {\n        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\n\n        return this;\n    }\n\n    copy(m: Matrix3) {\n        const te = this.elements;\n        const me = m.elements;\n\n        te[0] = me[0];\n        te[1] = me[1];\n        te[2] = me[2];\n        te[3] = me[3];\n        te[4] = me[4];\n        te[5] = me[5];\n        te[6] = me[6];\n        te[7] = me[7];\n        te[8] = me[8];\n\n        return this;\n    }\n\n    extractBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) {\n        xAxis.setFromMatrix3Column(this, 0);\n        yAxis.setFromMatrix3Column(this, 1);\n        zAxis.setFromMatrix3Column(this, 2);\n\n        return this;\n    }\n\n    setFromMatrix4(m: Matrix4) {\n        const me = m.elements;\n\n        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);\n\n        return this;\n    }\n\n    multiply(m: Matrix3) {\n        return this.multiplyMatrices(this, m);\n    }\n\n    premultiply(m: Matrix3) {\n        return this.multiplyMatrices(m, this);\n    }\n\n    multiplyMatrices(a: Matrix3, b: Matrix3) {\n        const ae = a.elements;\n        const be = b.elements;\n        const te = this.elements;\n\n        const a11 = ae[0],\n            a12 = ae[3],\n            a13 = ae[6];\n        const a21 = ae[1],\n            a22 = ae[4],\n            a23 = ae[7];\n        const a31 = ae[2],\n            a32 = ae[5],\n            a33 = ae[8];\n\n        const b11 = be[0],\n            b12 = be[3],\n            b13 = be[6];\n        const b21 = be[1],\n            b22 = be[4],\n            b23 = be[7];\n        const b31 = be[2],\n            b32 = be[5],\n            b33 = be[8];\n\n        te[0] = a11 * b11 + a12 * b21 + a13 * b31;\n        te[3] = a11 * b12 + a12 * b22 + a13 * b32;\n        te[6] = a11 * b13 + a12 * b23 + a13 * b33;\n\n        te[1] = a21 * b11 + a22 * b21 + a23 * b31;\n        te[4] = a21 * b12 + a22 * b22 + a23 * b32;\n        te[7] = a21 * b13 + a22 * b23 + a23 * b33;\n\n        te[2] = a31 * b11 + a32 * b21 + a33 * b31;\n        te[5] = a31 * b12 + a32 * b22 + a33 * b32;\n        te[8] = a31 * b13 + a32 * b23 + a33 * b33;\n\n        return this;\n    }\n\n    multiplyScalar(s: number) {\n        const te = this.elements;\n\n        te[0] *= s;\n        te[3] *= s;\n        te[6] *= s;\n        te[1] *= s;\n        te[4] *= s;\n        te[7] *= s;\n        te[2] *= s;\n        te[5] *= s;\n        te[8] *= s;\n\n        return this;\n    }\n\n    determinant() {\n        const te = this.elements;\n\n        const a = te[0],\n            b = te[1],\n            c = te[2],\n            d = te[3],\n            e = te[4],\n            f = te[5],\n            g = te[6],\n            h = te[7],\n            i = te[8];\n\n        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n    }\n\n    invert() {\n        const te = this.elements,\n            n11 = te[0],\n            n21 = te[1],\n            n31 = te[2],\n            n12 = te[3],\n            n22 = te[4],\n            n32 = te[5],\n            n13 = te[6],\n            n23 = te[7],\n            n33 = te[8],\n            t11 = n33 * n22 - n32 * n23,\n            t12 = n32 * n13 - n33 * n12,\n            t13 = n23 * n12 - n22 * n13,\n            det = n11 * t11 + n21 * t12 + n31 * t13;\n\n        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n\n        const detInv = 1 / det;\n\n        te[0] = t11 * detInv;\n        te[1] = (n31 * n23 - n33 * n21) * detInv;\n        te[2] = (n32 * n21 - n31 * n22) * detInv;\n\n        te[3] = t12 * detInv;\n        te[4] = (n33 * n11 - n31 * n13) * detInv;\n        te[5] = (n31 * n12 - n32 * n11) * detInv;\n\n        te[6] = t13 * detInv;\n        te[7] = (n21 * n13 - n23 * n11) * detInv;\n        te[8] = (n22 * n11 - n21 * n12) * detInv;\n\n        return this;\n    }\n\n    transpose() {\n        let tmp;\n        const m = this.elements;\n\n        tmp = m[1];\n        m[1] = m[3];\n        m[3] = tmp;\n        tmp = m[2];\n        m[2] = m[6];\n        m[6] = tmp;\n        tmp = m[5];\n        m[5] = m[7];\n        m[7] = tmp;\n\n        return this;\n    }\n\n    getNormalMatrix(matrix4: Matrix4) {\n        return this.setFromMatrix4(matrix4).invert().transpose();\n    }\n\n    transposeIntoArray(r: Array<number>) {\n        const m = this.elements;\n\n        r[0] = m[0];\n        r[1] = m[3];\n        r[2] = m[6];\n        r[3] = m[1];\n        r[4] = m[4];\n        r[5] = m[7];\n        r[6] = m[2];\n        r[7] = m[5];\n        r[8] = m[8];\n\n        return this;\n    }\n\n    setUvTransform(tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) {\n        const c = Math.cos(rotation);\n        const s = Math.sin(rotation);\n\n        this.set(\n            sx * c,\n            sx * s,\n            -sx * (c * cx + s * cy) + cx + tx,\n            -sy * s,\n            sy * c,\n            -sy * (-s * cx + c * cy) + cy + ty,\n            0,\n            0,\n            1\n        );\n\n        return this;\n    }\n\n    //\n\n    scale(sx: number, sy: number) {\n        this.premultiply(_m3.makeScale(sx, sy));\n\n        return this;\n    }\n\n    rotate(theta: number) {\n        this.premultiply(_m3.makeRotation(-theta));\n\n        return this;\n    }\n\n    translate(tx: Vector2) {\n        this.premultiply(_m3.makeTranslation(tx));\n\n        return this;\n    }\n\n    // for 2D Transforms\n\n    makeTranslation(x: Vector2) {\n        this.set(1, 0, x.x, 0, 1, x.y, 0, 0, 1);\n\n        return this;\n    }\n\n    makeRotation(theta: number) {\n        // counterclockwise\n\n        const c = Math.cos(theta);\n        const s = Math.sin(theta);\n\n        this.set(c, -s, 0, s, c, 0, 0, 0, 1);\n\n        return this;\n    }\n\n    makeScale(x: number, y: number) {\n        this.set(x, 0, 0, 0, y, 0, 0, 0, 1);\n\n        return this;\n    }\n\n    //\n\n    equals(matrix: Matrix3) {\n        const te = this.elements;\n        const me = matrix.elements;\n\n        for (let i = 0; i < 9; i++) {\n            if (te[i] !== me[i]) return false;\n        }\n\n        return true;\n    }\n\n    fromArray(array: Array<number>, offset = 0) {\n        for (let i = 0; i < 9; i++) {\n            this.elements[i] = array[i + offset];\n        }\n\n        return this;\n    }\n\n    toArray(array: Array<number> = [], offset = 0) {\n        const te = this.elements;\n\n        array[offset] = te[0];\n        array[offset + 1] = te[1];\n        array[offset + 2] = te[2];\n\n        array[offset + 3] = te[3];\n        array[offset + 4] = te[4];\n        array[offset + 5] = te[5];\n\n        array[offset + 6] = te[6];\n        array[offset + 7] = te[7];\n        array[offset + 8] = te[8];\n\n        return array;\n    }\n\n    clone() {\n        return new Matrix3().fromArray(this.elements);\n    }\n}\n\nconst _m3 = /*@__PURE__*/ new Matrix3();\n\nexport { Matrix3 };\n","import { Euler } from \"./Euler\";\nimport { Matrix3 } from \"./Matrix3\";\nimport { Quaternion } from \"./Quaternion\";\nimport { Vector3 } from \"./Vector3\";\n\nexport class Matrix4 {\n    public elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\n    constructor(\n        n11 = 1,\n        n12 = 0,\n        n13 = 0,\n        n14 = 0,\n        n21 = 0,\n        n22 = 1,\n        n23 = 0,\n        n24 = 0,\n        n31 = 0,\n        n32 = 0,\n        n33 = 1,\n        n34 = 0,\n        n41 = 0,\n        n42 = 0,\n        n43 = 0,\n        n44 = 1\n    ) {\n        if (n11 !== undefined) {\n            this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);\n        }\n    }\n\n    set(\n        n11: number,\n        n12: number,\n        n13: number,\n        n14: number,\n        n21: number,\n        n22: number,\n        n23: number,\n        n24: number,\n        n31: number,\n        n32: number,\n        n33: number,\n        n34: number,\n        n41: number,\n        n42: number,\n        n43: number,\n        n44: number\n    ) {\n        const te = this.elements;\n\n        te[0] = n11;\n        te[4] = n12;\n        te[8] = n13;\n        te[12] = n14;\n        te[1] = n21;\n        te[5] = n22;\n        te[9] = n23;\n        te[13] = n24;\n        te[2] = n31;\n        te[6] = n32;\n        te[10] = n33;\n        te[14] = n34;\n        te[3] = n41;\n        te[7] = n42;\n        te[11] = n43;\n        te[15] = n44;\n\n        return this;\n    }\n\n    identity() {\n        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\n        return this;\n    }\n\n    clone() {\n        return new Matrix4().fromArray(this.elements);\n    }\n\n    copy(m: Matrix4) {\n        const te = this.elements;\n        const me = m.elements;\n\n        te[0] = me[0];\n        te[1] = me[1];\n        te[2] = me[2];\n        te[3] = me[3];\n        te[4] = me[4];\n        te[5] = me[5];\n        te[6] = me[6];\n        te[7] = me[7];\n        te[8] = me[8];\n        te[9] = me[9];\n        te[10] = me[10];\n        te[11] = me[11];\n        te[12] = me[12];\n        te[13] = me[13];\n        te[14] = me[14];\n        te[15] = me[15];\n\n        return this;\n    }\n\n    copyPosition(m: Matrix4) {\n        const te = this.elements,\n            me = m.elements;\n\n        te[12] = me[12];\n        te[13] = me[13];\n        te[14] = me[14];\n\n        return this;\n    }\n\n    setFromMatrix3(m: Matrix3) {\n        const me = m.elements;\n\n        this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);\n\n        return this;\n    }\n\n    extractBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) {\n        xAxis.setFromMatrixColumn(this, 0);\n        yAxis.setFromMatrixColumn(this, 1);\n        zAxis.setFromMatrixColumn(this, 2);\n\n        return this;\n    }\n\n    makeBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) {\n        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);\n\n        return this;\n    }\n\n    extractRotation(m: Matrix4) {\n        // this method does not support reflection matrices\n\n        const te = this.elements;\n        const me = m.elements;\n\n        const scaleX = 1 / _v1.setFromMatrixColumn(m, 0).length();\n        const scaleY = 1 / _v1.setFromMatrixColumn(m, 1).length();\n        const scaleZ = 1 / _v1.setFromMatrixColumn(m, 2).length();\n\n        te[0] = me[0] * scaleX;\n        te[1] = me[1] * scaleX;\n        te[2] = me[2] * scaleX;\n        te[3] = 0;\n\n        te[4] = me[4] * scaleY;\n        te[5] = me[5] * scaleY;\n        te[6] = me[6] * scaleY;\n        te[7] = 0;\n\n        te[8] = me[8] * scaleZ;\n        te[9] = me[9] * scaleZ;\n        te[10] = me[10] * scaleZ;\n        te[11] = 0;\n\n        te[12] = 0;\n        te[13] = 0;\n        te[14] = 0;\n        te[15] = 1;\n\n        return this;\n    }\n\n    makeRotationFromEuler(euler: Euler) {\n        const te = this.elements;\n\n        const x = euler.x,\n            y = euler.y,\n            z = euler.z;\n        const a = Math.cos(x),\n            b = Math.sin(x);\n        const c = Math.cos(y),\n            d = Math.sin(y);\n        const e = Math.cos(z),\n            f = Math.sin(z);\n\n        if (euler.order === \"XYZ\") {\n            const ae = a * e,\n                af = a * f,\n                be = b * e,\n                bf = b * f;\n\n            te[0] = c * e;\n            te[4] = -c * f;\n            te[8] = d;\n\n            te[1] = af + be * d;\n            te[5] = ae - bf * d;\n            te[9] = -b * c;\n\n            te[2] = bf - ae * d;\n            te[6] = be + af * d;\n            te[10] = a * c;\n        } else if (euler.order === \"YXZ\") {\n            const ce = c * e,\n                cf = c * f,\n                de = d * e,\n                df = d * f;\n\n            te[0] = ce + df * b;\n            te[4] = de * b - cf;\n            te[8] = a * d;\n\n            te[1] = a * f;\n            te[5] = a * e;\n            te[9] = -b;\n\n            te[2] = cf * b - de;\n            te[6] = df + ce * b;\n            te[10] = a * c;\n        } else if (euler.order === \"ZXY\") {\n            const ce = c * e,\n                cf = c * f,\n                de = d * e,\n                df = d * f;\n\n            te[0] = ce - df * b;\n            te[4] = -a * f;\n            te[8] = de + cf * b;\n\n            te[1] = cf + de * b;\n            te[5] = a * e;\n            te[9] = df - ce * b;\n\n            te[2] = -a * d;\n            te[6] = b;\n            te[10] = a * c;\n        } else if (euler.order === \"ZYX\") {\n            const ae = a * e,\n                af = a * f,\n                be = b * e,\n                bf = b * f;\n\n            te[0] = c * e;\n            te[4] = be * d - af;\n            te[8] = ae * d + bf;\n\n            te[1] = c * f;\n            te[5] = bf * d + ae;\n            te[9] = af * d - be;\n\n            te[2] = -d;\n            te[6] = b * c;\n            te[10] = a * c;\n        } else if (euler.order === \"YZX\") {\n            const ac = a * c,\n                ad = a * d,\n                bc = b * c,\n                bd = b * d;\n\n            te[0] = c * e;\n            te[4] = bd - ac * f;\n            te[8] = bc * f + ad;\n\n            te[1] = f;\n            te[5] = a * e;\n            te[9] = -b * e;\n\n            te[2] = -d * e;\n            te[6] = ad * f + bc;\n            te[10] = ac - bd * f;\n        } else if (euler.order === \"XZY\") {\n            const ac = a * c,\n                ad = a * d,\n                bc = b * c,\n                bd = b * d;\n\n            te[0] = c * e;\n            te[4] = -f;\n            te[8] = d * e;\n\n            te[1] = ac * f + bd;\n            te[5] = a * e;\n            te[9] = ad * f - bc;\n\n            te[2] = bc * f - ad;\n            te[6] = b * e;\n            te[10] = bd * f + ac;\n        }\n\n        // bottom row\n        te[3] = 0;\n        te[7] = 0;\n        te[11] = 0;\n\n        // last column\n        te[12] = 0;\n        te[13] = 0;\n        te[14] = 0;\n        te[15] = 1;\n\n        return this;\n    }\n\n    makeRotationFromQuaternion(q: Quaternion) {\n        return this.compose(_zero, q, _one);\n    }\n\n    lookAt(eye: Vector3, target: Vector3, up: Vector3) {\n        const te = this.elements;\n\n        _z.subVectors(eye, target);\n\n        if (_z.lengthSq() === 0) {\n            // eye and target are in the same position\n\n            _z.z = 1;\n        }\n\n        _z.normalize();\n        _x.crossVectors(up, _z);\n\n        if (_x.lengthSq() === 0) {\n            // up and z are parallel\n\n            if (Math.abs(up.z) === 1) {\n                _z.x += 0.0001;\n            } else {\n                _z.z += 0.0001;\n            }\n\n            _z.normalize();\n            _x.crossVectors(up, _z);\n        }\n\n        _x.normalize();\n        _y.crossVectors(_z, _x);\n\n        te[0] = _x.x;\n        te[4] = _y.x;\n        te[8] = _z.x;\n        te[1] = _x.y;\n        te[5] = _y.y;\n        te[9] = _z.y;\n        te[2] = _x.z;\n        te[6] = _y.z;\n        te[10] = _z.z;\n\n        return this;\n    }\n\n    multiply(m: Matrix4) {\n        return this.multiplyMatrices(this, m);\n    }\n\n    premultiply(m: Matrix4) {\n        return this.multiplyMatrices(m, this);\n    }\n\n    multiplyMatrices(a: Matrix4, b: Matrix4) {\n        const ae = a.elements;\n        const be = b.elements;\n        const te = this.elements;\n\n        const a11 = ae[0],\n            a12 = ae[4],\n            a13 = ae[8],\n            a14 = ae[12];\n        const a21 = ae[1],\n            a22 = ae[5],\n            a23 = ae[9],\n            a24 = ae[13];\n        const a31 = ae[2],\n            a32 = ae[6],\n            a33 = ae[10],\n            a34 = ae[14];\n        const a41 = ae[3],\n            a42 = ae[7],\n            a43 = ae[11],\n            a44 = ae[15];\n\n        const b11 = be[0],\n            b12 = be[4],\n            b13 = be[8],\n            b14 = be[12];\n        const b21 = be[1],\n            b22 = be[5],\n            b23 = be[9],\n            b24 = be[13];\n        const b31 = be[2],\n            b32 = be[6],\n            b33 = be[10],\n            b34 = be[14];\n        const b41 = be[3],\n            b42 = be[7],\n            b43 = be[11],\n            b44 = be[15];\n\n        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n        return this;\n    }\n\n    multiplyScalar(s: number) {\n        const te = this.elements;\n\n        te[0] *= s;\n        te[4] *= s;\n        te[8] *= s;\n        te[12] *= s;\n        te[1] *= s;\n        te[5] *= s;\n        te[9] *= s;\n        te[13] *= s;\n        te[2] *= s;\n        te[6] *= s;\n        te[10] *= s;\n        te[14] *= s;\n        te[3] *= s;\n        te[7] *= s;\n        te[11] *= s;\n        te[15] *= s;\n\n        return this;\n    }\n\n    determinant() {\n        const te = this.elements;\n\n        const n11 = te[0],\n            n12 = te[4],\n            n13 = te[8],\n            n14 = te[12];\n        const n21 = te[1],\n            n22 = te[5],\n            n23 = te[9],\n            n24 = te[13];\n        const n31 = te[2],\n            n32 = te[6],\n            n33 = te[10],\n            n34 = te[14];\n        const n41 = te[3],\n            n42 = te[7],\n            n43 = te[11],\n            n44 = te[15];\n\n        //TODO: make this more efficient\n        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n        return (\n            n41 *\n                (+n14 * n23 * n32 -\n                    n13 * n24 * n32 -\n                    n14 * n22 * n33 +\n                    n12 * n24 * n33 +\n                    n13 * n22 * n34 -\n                    n12 * n23 * n34) +\n            n42 *\n                (+n11 * n23 * n34 -\n                    n11 * n24 * n33 +\n                    n14 * n21 * n33 -\n                    n13 * n21 * n34 +\n                    n13 * n24 * n31 -\n                    n14 * n23 * n31) +\n            n43 *\n                (+n11 * n24 * n32 -\n                    n11 * n22 * n34 -\n                    n14 * n21 * n32 +\n                    n12 * n21 * n34 +\n                    n14 * n22 * n31 -\n                    n12 * n24 * n31) +\n            n44 *\n                (-n13 * n22 * n31 -\n                    n11 * n23 * n32 +\n                    n11 * n22 * n33 +\n                    n13 * n21 * n32 -\n                    n12 * n21 * n33 +\n                    n12 * n23 * n31)\n        );\n    }\n\n    transpose() {\n        const te = this.elements;\n        let tmp;\n\n        tmp = te[1];\n        te[1] = te[4];\n        te[4] = tmp;\n        tmp = te[2];\n        te[2] = te[8];\n        te[8] = tmp;\n        tmp = te[6];\n        te[6] = te[9];\n        te[9] = tmp;\n\n        tmp = te[3];\n        te[3] = te[12];\n        te[12] = tmp;\n        tmp = te[7];\n        te[7] = te[13];\n        te[13] = tmp;\n        tmp = te[11];\n        te[11] = te[14];\n        te[14] = tmp;\n\n        return this;\n    }\n\n    setPosition(x: Vector3) {\n        const te = this.elements;\n\n        te[12] = x.x;\n        te[13] = x.y;\n        te[14] = x.z;\n\n        return this;\n    }\n\n    invert() {\n        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n        const te = this.elements,\n            n11 = te[0],\n            n21 = te[1],\n            n31 = te[2],\n            n41 = te[3],\n            n12 = te[4],\n            n22 = te[5],\n            n32 = te[6],\n            n42 = te[7],\n            n13 = te[8],\n            n23 = te[9],\n            n33 = te[10],\n            n43 = te[11],\n            n14 = te[12],\n            n24 = te[13],\n            n34 = te[14],\n            n44 = te[15],\n            t11 =\n                n23 * n34 * n42 -\n                n24 * n33 * n42 +\n                n24 * n32 * n43 -\n                n22 * n34 * n43 -\n                n23 * n32 * n44 +\n                n22 * n33 * n44,\n            t12 =\n                n14 * n33 * n42 -\n                n13 * n34 * n42 -\n                n14 * n32 * n43 +\n                n12 * n34 * n43 +\n                n13 * n32 * n44 -\n                n12 * n33 * n44,\n            t13 =\n                n13 * n24 * n42 -\n                n14 * n23 * n42 +\n                n14 * n22 * n43 -\n                n12 * n24 * n43 -\n                n13 * n22 * n44 +\n                n12 * n23 * n44,\n            t14 =\n                n14 * n23 * n32 -\n                n13 * n24 * n32 -\n                n14 * n22 * n33 +\n                n12 * n24 * n33 +\n                n13 * n22 * n34 -\n                n12 * n23 * n34;\n\n        const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\n        const detInv = 1 / det;\n\n        te[0] = t11 * detInv;\n        te[1] =\n            (n24 * n33 * n41 -\n                n23 * n34 * n41 -\n                n24 * n31 * n43 +\n                n21 * n34 * n43 +\n                n23 * n31 * n44 -\n                n21 * n33 * n44) *\n            detInv;\n        te[2] =\n            (n22 * n34 * n41 -\n                n24 * n32 * n41 +\n                n24 * n31 * n42 -\n                n21 * n34 * n42 -\n                n22 * n31 * n44 +\n                n21 * n32 * n44) *\n            detInv;\n        te[3] =\n            (n23 * n32 * n41 -\n                n22 * n33 * n41 -\n                n23 * n31 * n42 +\n                n21 * n33 * n42 +\n                n22 * n31 * n43 -\n                n21 * n32 * n43) *\n            detInv;\n\n        te[4] = t12 * detInv;\n        te[5] =\n            (n13 * n34 * n41 -\n                n14 * n33 * n41 +\n                n14 * n31 * n43 -\n                n11 * n34 * n43 -\n                n13 * n31 * n44 +\n                n11 * n33 * n44) *\n            detInv;\n        te[6] =\n            (n14 * n32 * n41 -\n                n12 * n34 * n41 -\n                n14 * n31 * n42 +\n                n11 * n34 * n42 +\n                n12 * n31 * n44 -\n                n11 * n32 * n44) *\n            detInv;\n        te[7] =\n            (n12 * n33 * n41 -\n                n13 * n32 * n41 +\n                n13 * n31 * n42 -\n                n11 * n33 * n42 -\n                n12 * n31 * n43 +\n                n11 * n32 * n43) *\n            detInv;\n\n        te[8] = t13 * detInv;\n        te[9] =\n            (n14 * n23 * n41 -\n                n13 * n24 * n41 -\n                n14 * n21 * n43 +\n                n11 * n24 * n43 +\n                n13 * n21 * n44 -\n                n11 * n23 * n44) *\n            detInv;\n        te[10] =\n            (n12 * n24 * n41 -\n                n14 * n22 * n41 +\n                n14 * n21 * n42 -\n                n11 * n24 * n42 -\n                n12 * n21 * n44 +\n                n11 * n22 * n44) *\n            detInv;\n        te[11] =\n            (n13 * n22 * n41 -\n                n12 * n23 * n41 -\n                n13 * n21 * n42 +\n                n11 * n23 * n42 +\n                n12 * n21 * n43 -\n                n11 * n22 * n43) *\n            detInv;\n\n        te[12] = t14 * detInv;\n        te[13] =\n            (n13 * n24 * n31 -\n                n14 * n23 * n31 +\n                n14 * n21 * n33 -\n                n11 * n24 * n33 -\n                n13 * n21 * n34 +\n                n11 * n23 * n34) *\n            detInv;\n        te[14] =\n            (n14 * n22 * n31 -\n                n12 * n24 * n31 -\n                n14 * n21 * n32 +\n                n11 * n24 * n32 +\n                n12 * n21 * n34 -\n                n11 * n22 * n34) *\n            detInv;\n        te[15] =\n            (n12 * n23 * n31 -\n                n13 * n22 * n31 +\n                n13 * n21 * n32 -\n                n11 * n23 * n32 -\n                n12 * n21 * n33 +\n                n11 * n22 * n33) *\n            detInv;\n\n        return this;\n    }\n\n    scale(v: Vector3) {\n        const te = this.elements;\n        const x = v.x,\n            y = v.y,\n            z = v.z;\n\n        te[0] *= x;\n        te[4] *= y;\n        te[8] *= z;\n        te[1] *= x;\n        te[5] *= y;\n        te[9] *= z;\n        te[2] *= x;\n        te[6] *= y;\n        te[10] *= z;\n        te[3] *= x;\n        te[7] *= y;\n        te[11] *= z;\n\n        return this;\n    }\n\n    getMaxScaleOnAxis() {\n        const te = this.elements;\n\n        const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n        const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n        const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n\n        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n    }\n\n    makeTranslation(x: Vector3) {\n        this.set(1, 0, 0, x.x, 0, 1, 0, x.y, 0, 0, 1, x.z, 0, 0, 0, 1);\n\n        return this;\n    }\n\n    makeRotationX(theta: number) {\n        const c = Math.cos(theta),\n            s = Math.sin(theta);\n\n        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);\n\n        return this;\n    }\n\n    makeRotationY(theta: number) {\n        const c = Math.cos(theta),\n            s = Math.sin(theta);\n\n        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);\n\n        return this;\n    }\n\n    makeRotationZ(theta: number) {\n        const c = Math.cos(theta),\n            s = Math.sin(theta);\n\n        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\n        return this;\n    }\n\n    makeRotationAxis(axis: Vector3, angle: number) {\n        // Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n        const c = Math.cos(angle);\n        const s = Math.sin(angle);\n        const t = 1 - c;\n        const x = axis.x,\n            y = axis.y,\n            z = axis.z;\n        const tx = t * x,\n            ty = t * y;\n\n        this.set(\n            tx * x + c,\n            tx * y - s * z,\n            tx * z + s * y,\n            0,\n            tx * y + s * z,\n            ty * y + c,\n            ty * z - s * x,\n            0,\n            tx * z - s * y,\n            ty * z + s * x,\n            t * z * z + c,\n            0,\n            0,\n            0,\n            0,\n            1\n        );\n\n        return this;\n    }\n\n    makeScale(x: number, y: number, z: number) {\n        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);\n\n        return this;\n    }\n\n    makeShear(xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) {\n        this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);\n\n        return this;\n    }\n\n    compose(position: Vector3, quaternion: Quaternion, scale: Vector3) {\n        const te = this.elements;\n\n        const x = quaternion.x,\n            y = quaternion.y,\n            z = quaternion.z,\n            w = quaternion.w;\n        const x2 = x + x,\n            y2 = y + y,\n            z2 = z + z;\n        const xx = x * x2,\n            xy = x * y2,\n            xz = x * z2;\n        const yy = y * y2,\n            yz = y * z2,\n            zz = z * z2;\n        const wx = w * x2,\n            wy = w * y2,\n            wz = w * z2;\n\n        const sx = scale.x,\n            sy = scale.y,\n            sz = scale.z;\n\n        te[0] = (1 - (yy + zz)) * sx;\n        te[1] = (xy + wz) * sx;\n        te[2] = (xz - wy) * sx;\n        te[3] = 0;\n\n        te[4] = (xy - wz) * sy;\n        te[5] = (1 - (xx + zz)) * sy;\n        te[6] = (yz + wx) * sy;\n        te[7] = 0;\n\n        te[8] = (xz + wy) * sz;\n        te[9] = (yz - wx) * sz;\n        te[10] = (1 - (xx + yy)) * sz;\n        te[11] = 0;\n\n        te[12] = position.x;\n        te[13] = position.y;\n        te[14] = position.z;\n        te[15] = 1;\n\n        return this;\n    }\n\n    decompose(position: Vector3, quaternion: Quaternion, scale: Vector3) {\n        const te = this.elements;\n\n        let sx = _v1.set(te[0], te[1], te[2]).length();\n        const sy = _v1.set(te[4], te[5], te[6]).length();\n        const sz = _v1.set(te[8], te[9], te[10]).length();\n\n        // if determine is negative, we need to invert one scale\n        const det = this.determinant();\n        if (det < 0) sx = -sx;\n\n        position.x = te[12];\n        position.y = te[13];\n        position.z = te[14];\n\n        // scale the rotation part\n        _m1.copy(this);\n\n        const invSX = 1 / sx;\n        const invSY = 1 / sy;\n        const invSZ = 1 / sz;\n\n        _m1.elements[0] *= invSX;\n        _m1.elements[1] *= invSX;\n        _m1.elements[2] *= invSX;\n\n        _m1.elements[4] *= invSY;\n        _m1.elements[5] *= invSY;\n        _m1.elements[6] *= invSY;\n\n        _m1.elements[8] *= invSZ;\n        _m1.elements[9] *= invSZ;\n        _m1.elements[10] *= invSZ;\n\n        quaternion.setFromRotationMatrix(_m1);\n\n        scale.x = sx;\n        scale.y = sy;\n        scale.z = sz;\n\n        return this;\n    }\n\n    makePerspective(left: number, right: number, top: number, bottom: number, near: number, far: number) {\n        const te = this.elements;\n        const x = (2 * near) / (right - left);\n        const y = (2 * near) / (top - bottom);\n\n        const a = (right + left) / (right - left);\n        const b = (top + bottom) / (top - bottom);\n        const c = -(far + near) / (far - near);\n        const d = (-2 * far * near) / (far - near);\n\n        te[0] = x;\n        te[4] = 0;\n        te[8] = a;\n        te[12] = 0;\n        te[1] = 0;\n        te[5] = y;\n        te[9] = b;\n        te[13] = 0;\n        te[2] = 0;\n        te[6] = 0;\n        te[10] = c;\n        te[14] = d;\n        te[3] = 0;\n        te[7] = 0;\n        te[11] = -1;\n        te[15] = 0;\n\n        return this;\n    }\n\n    makeOrthographic(left: number, right: number, top: number, bottom: number, near: number, far: number) {\n        const te = this.elements;\n        const w = 1.0 / (right - left);\n        const h = 1.0 / (top - bottom);\n        const p = 1.0 / (far - near);\n\n        const x = (right + left) * w;\n        const y = (top + bottom) * h;\n        const z = (far + near) * p;\n\n        te[0] = 2 * w;\n        te[4] = 0;\n        te[8] = 0;\n        te[12] = -x;\n        te[1] = 0;\n        te[5] = 2 * h;\n        te[9] = 0;\n        te[13] = -y;\n        te[2] = 0;\n        te[6] = 0;\n        te[10] = -2 * p;\n        te[14] = -z;\n        te[3] = 0;\n        te[7] = 0;\n        te[11] = 0;\n        te[15] = 1;\n\n        return this;\n    }\n\n    equals(matrix: Matrix4) {\n        const te = this.elements;\n        const me = matrix.elements;\n\n        for (let i = 0; i < 16; i++) {\n            if (te[i] !== me[i]) return false;\n        }\n\n        return true;\n    }\n\n    fromArray(array: Array<number>, offset = 0) {\n        for (let i = 0; i < 16; i++) {\n            this.elements[i] = array[i + offset];\n        }\n\n        return this;\n    }\n\n    toArray(array: Float32Array = new Float32Array(16), offset = 0) {\n        const te = this.elements;\n\n        array[offset] = te[0];\n        array[offset + 1] = te[1];\n        array[offset + 2] = te[2];\n        array[offset + 3] = te[3];\n\n        array[offset + 4] = te[4];\n        array[offset + 5] = te[5];\n        array[offset + 6] = te[6];\n        array[offset + 7] = te[7];\n\n        array[offset + 8] = te[8];\n        array[offset + 9] = te[9];\n        array[offset + 10] = te[10];\n        array[offset + 11] = te[11];\n\n        array[offset + 12] = te[12];\n        array[offset + 13] = te[13];\n        array[offset + 14] = te[14];\n        array[offset + 15] = te[15];\n\n        return array;\n    }\n}\n\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _m1 = /*@__PURE__*/ new Matrix4();\nconst _zero = /*@__PURE__*/ new Vector3(0, 0, 0);\nconst _one = /*@__PURE__*/ new Vector3(1, 1, 1);\nconst _x = /*@__PURE__*/ new Vector3();\nconst _y = /*@__PURE__*/ new Vector3();\nconst _z = /*@__PURE__*/ new Vector3();\n","import { Box3 } from \"./Box3\";\nimport { Line3 } from \"./Line3\";\nimport { Matrix3 } from \"./Matrix3\";\nimport { Matrix4 } from \"./Matrix4\";\nimport { Sphere } from \"./Sphere\";\nimport { Vector3 } from \"./Vector3\";\n\nconst _vector1 = /*@__PURE__*/ new Vector3();\nconst _vector2 = /*@__PURE__*/ new Vector3();\nconst _normalMatrix = /*@__PURE__*/ new Matrix3();\n\nexport class Plane {\n    public normal: Vector3;\n    public constant: number;\n\n    constructor(normal = new Vector3(1, 0, 0), constant = 0) {\n        // normal is assumed to be normalized\n\n        this.normal = normal;\n        this.constant = constant;\n    }\n\n    set(normal: Vector3, constant: number) {\n        this.normal.copy(normal);\n        this.constant = constant;\n\n        return this;\n    }\n\n    setComponents(x: number, y: number, z: number, w: number) {\n        this.normal.set(x, y, z);\n        this.constant = w;\n\n        return this;\n    }\n\n    setFromNormalAndCoplanarPoint(normal: Vector3, point: Vector3) {\n        this.normal.copy(normal);\n        this.constant = -point.dot(this.normal);\n\n        return this;\n    }\n\n    setFromCoplanarPoints(a: Vector3, b: Vector3, c: Vector3) {\n        const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();\n\n        // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n        this.setFromNormalAndCoplanarPoint(normal, a);\n\n        return this;\n    }\n\n    copy(plane: Plane) {\n        this.normal.copy(plane.normal);\n        this.constant = plane.constant;\n\n        return this;\n    }\n\n    normalize() {\n        // Note: will lead to a divide by zero if the plane is invalid.\n\n        const inverseNormalLength = 1.0 / this.normal.length();\n        this.normal.multiplyScalar(inverseNormalLength);\n        this.constant *= inverseNormalLength;\n\n        return this;\n    }\n\n    negate() {\n        this.constant *= -1;\n        this.normal.negate();\n\n        return this;\n    }\n\n    distanceToPoint(point: Vector3) {\n        return this.normal.dot(point) + this.constant;\n    }\n\n    distanceToSphere(sphere: Sphere) {\n        return this.distanceToPoint(sphere.center) - sphere.radius;\n    }\n\n    projectPoint(point: Vector3, target: Vector3) {\n        return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));\n    }\n\n    intersectLine(line: Line3, target: Vector3) {\n        const direction = line.delta(_vector1);\n\n        const denominator = this.normal.dot(direction);\n\n        if (denominator === 0) {\n            // line is coplanar, return origin\n            if (this.distanceToPoint(line.start) === 0) {\n                return target.copy(line.start);\n            }\n\n            // Unsure if this is the correct method to handle this case.\n            return null;\n        }\n\n        const t = -(line.start.dot(this.normal) + this.constant) / denominator;\n\n        if (t < 0 || t > 1) {\n            return null;\n        }\n\n        return target.copy(line.start).addScaledVector(direction, t);\n    }\n\n    intersectsLine(line: Line3) {\n        // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n        const startSign = this.distanceToPoint(line.start);\n        const endSign = this.distanceToPoint(line.end);\n\n        return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);\n    }\n\n    intersectsBox(box: Box3) {\n        return box.intersectsPlane(this);\n    }\n\n    intersectsSphere(sphere: Sphere) {\n        return sphere.intersectsPlane(this);\n    }\n\n    coplanarPoint(target: Vector3) {\n        return target.copy(this.normal).multiplyScalar(-this.constant);\n    }\n\n    applyMatrix4(matrix: Matrix4, optionalNormalMatrix: Matrix3) {\n        const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);\n\n        const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);\n\n        const normal = this.normal.applyMatrix3(normalMatrix).normalize();\n\n        this.constant = -referencePoint.dot(normal);\n\n        return this;\n    }\n\n    translate(offset: Vector3) {\n        this.constant -= offset.dot(this.normal);\n\n        return this;\n    }\n\n    equals(plane: Plane) {\n        return plane.normal.equals(this.normal) && plane.constant === this.constant;\n    }\n\n    clone() {\n        return new Plane().copy(this);\n    }\n}\n","import { BufferAttribute } from \"../core/BufferAttribute\";\nimport { Euler } from \"./Euler\";\nimport * as MathUtils from \"./MathUtils\";\nimport { Matrix4 } from \"./Matrix4\";\nimport { Vector3 } from \"./Vector3\";\n\nclass Quaternion {\n    private _x = 0;\n    private _y = 0;\n    private _z = 0;\n    private _w = 0;\n\n    private _onChangeCallback = (q: Quaternion) => {};\n\n    constructor(x = 0, y = 0, z = 0, w = 1) {\n        this._x = x;\n        this._y = y;\n        this._z = z;\n        this._w = w;\n    }\n\n    public set x(v: number) {\n        this._x = v;\n        this._onChangeCallback(this);\n    }\n    public get x() {\n        return this._x;\n    }\n    public set y(v: number) {\n        this._y = v;\n        this._onChangeCallback(this);\n    }\n    public get y() {\n        return this._y;\n    }\n    public set z(v: number) {\n        this._z = v;\n        this._onChangeCallback(this);\n    }\n    public get z() {\n        return this._z;\n    }\n    public set w(v: number) {\n        this._w = v;\n        this._onChangeCallback(this);\n    }\n    public get w() {\n        return this._w;\n    }\n\n    static slerpFlat(\n        dst: Array<number>,\n        dstOffset: number,\n        src0: Array<number>,\n        srcOffset0: number,\n        src1: Array<number>,\n        srcOffset1: number,\n        t: number\n    ) {\n        // fuzz-free, array-based Quaternion SLERP operation\n\n        let x0 = src0[srcOffset0 + 0],\n            y0 = src0[srcOffset0 + 1],\n            z0 = src0[srcOffset0 + 2],\n            w0 = src0[srcOffset0 + 3];\n\n        const x1 = src1[srcOffset1 + 0],\n            y1 = src1[srcOffset1 + 1],\n            z1 = src1[srcOffset1 + 2],\n            w1 = src1[srcOffset1 + 3];\n\n        if (t === 0) {\n            dst[dstOffset + 0] = x0;\n            dst[dstOffset + 1] = y0;\n            dst[dstOffset + 2] = z0;\n            dst[dstOffset + 3] = w0;\n            return;\n        }\n\n        if (t === 1) {\n            dst[dstOffset + 0] = x1;\n            dst[dstOffset + 1] = y1;\n            dst[dstOffset + 2] = z1;\n            dst[dstOffset + 3] = w1;\n            return;\n        }\n\n        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n            let s = 1 - t;\n            const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n                dir = cos >= 0 ? 1 : -1,\n                sqrSin = 1 - cos * cos;\n\n            // Skip the Slerp for tiny steps to avoid numeric problems:\n            if (sqrSin > Number.EPSILON) {\n                const sin = Math.sqrt(sqrSin),\n                    len = Math.atan2(sin, cos * dir);\n\n                s = Math.sin(s * len) / sin;\n                t = Math.sin(t * len) / sin;\n            }\n\n            const tDir = t * dir;\n\n            x0 = x0 * s + x1 * tDir;\n            y0 = y0 * s + y1 * tDir;\n            z0 = z0 * s + z1 * tDir;\n            w0 = w0 * s + w1 * tDir;\n\n            // Normalize in case we just did a lerp:\n            if (s === 1 - t) {\n                const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n\n                x0 *= f;\n                y0 *= f;\n                z0 *= f;\n                w0 *= f;\n            }\n        }\n\n        dst[dstOffset] = x0;\n        dst[dstOffset + 1] = y0;\n        dst[dstOffset + 2] = z0;\n        dst[dstOffset + 3] = w0;\n    }\n\n    static multiplyQuaternionsFlat(\n        dst: Array<number>,\n        dstOffset: number,\n        src0: Array<number>,\n        srcOffset0: number,\n        src1: Array<number>,\n        srcOffset1: number\n    ) {\n        const x0 = src0[srcOffset0];\n        const y0 = src0[srcOffset0 + 1];\n        const z0 = src0[srcOffset0 + 2];\n        const w0 = src0[srcOffset0 + 3];\n\n        const x1 = src1[srcOffset1];\n        const y1 = src1[srcOffset1 + 1];\n        const z1 = src1[srcOffset1 + 2];\n        const w1 = src1[srcOffset1 + 3];\n\n        dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n        dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n        dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n        dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n\n        return dst;\n    }\n\n    set(x: number, y: number, z: number, w: number) {\n        this._x = x;\n        this._y = y;\n        this._z = z;\n        this._w = w;\n\n        this._onChangeCallback(this);\n\n        return this;\n    }\n\n    clone() {\n        return new Quaternion(this.x, this.y, this.z, this.w);\n    }\n\n    copy(quaternion: Quaternion) {\n        this._x = quaternion.x;\n        this._y = quaternion.y;\n        this._z = quaternion.z;\n        this._w = quaternion.w;\n\n        this._onChangeCallback(this);\n\n        return this;\n    }\n\n    setFromEuler(euler: Euler, update = true) {\n        const x = euler.x,\n            y = euler.y,\n            z = euler.z,\n            order = euler.order;\n\n        // http://www.mathworks.com/matlabcentral/fileexchange/\n        // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n        //\tcontent/SpinCalc.m\n\n        const cos = Math.cos;\n        const sin = Math.sin;\n\n        const c1 = cos(x / 2);\n        const c2 = cos(y / 2);\n        const c3 = cos(z / 2);\n\n        const s1 = sin(x / 2);\n        const s2 = sin(y / 2);\n        const s3 = sin(z / 2);\n\n        switch (order) {\n            case \"XYZ\":\n                this._x = s1 * c2 * c3 + c1 * s2 * s3;\n                this._y = c1 * s2 * c3 - s1 * c2 * s3;\n                this._z = c1 * c2 * s3 + s1 * s2 * c3;\n                this._w = c1 * c2 * c3 - s1 * s2 * s3;\n                break;\n\n            case \"YXZ\":\n                this._x = s1 * c2 * c3 + c1 * s2 * s3;\n                this._y = c1 * s2 * c3 - s1 * c2 * s3;\n                this._z = c1 * c2 * s3 - s1 * s2 * c3;\n                this._w = c1 * c2 * c3 + s1 * s2 * s3;\n                break;\n\n            case \"ZXY\":\n                this._x = s1 * c2 * c3 - c1 * s2 * s3;\n                this._y = c1 * s2 * c3 + s1 * c2 * s3;\n                this._z = c1 * c2 * s3 + s1 * s2 * c3;\n                this._w = c1 * c2 * c3 - s1 * s2 * s3;\n                break;\n\n            case \"ZYX\":\n                this._x = s1 * c2 * c3 - c1 * s2 * s3;\n                this._y = c1 * s2 * c3 + s1 * c2 * s3;\n                this._z = c1 * c2 * s3 - s1 * s2 * c3;\n                this._w = c1 * c2 * c3 + s1 * s2 * s3;\n                break;\n\n            case \"YZX\":\n                this.x = s1 * c2 * c3 + c1 * s2 * s3;\n                this.y = c1 * s2 * c3 + s1 * c2 * s3;\n                this.z = c1 * c2 * s3 - s1 * s2 * c3;\n                this.w = c1 * c2 * c3 - s1 * s2 * s3;\n                break;\n\n            case \"XZY\":\n                this.x = s1 * c2 * c3 - c1 * s2 * s3;\n                this.y = c1 * s2 * c3 - s1 * c2 * s3;\n                this.z = c1 * c2 * s3 + s1 * s2 * c3;\n                this.w = c1 * c2 * c3 + s1 * s2 * s3;\n                break;\n\n            default:\n                console.warn(\"THREE.Quaternion: .setFromEuler() encountered an unknown order: \" + order);\n        }\n\n        if (update) this._onChangeCallback(this);\n\n        return this;\n    }\n\n    setFromAxisAngle(axis: Vector3, angle: number) {\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n        // assumes axis is normalized\n\n        const halfAngle = angle / 2,\n            s = Math.sin(halfAngle);\n\n        this._x = axis.x * s;\n        this._y = axis.y * s;\n        this._z = axis.z * s;\n        this._w = Math.cos(halfAngle);\n\n        this._onChangeCallback(this);\n\n        return this;\n    }\n\n    setFromRotationMatrix(m: Matrix4) {\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        const te = m.elements,\n            m11 = te[0],\n            m12 = te[4],\n            m13 = te[8],\n            m21 = te[1],\n            m22 = te[5],\n            m23 = te[9],\n            m31 = te[2],\n            m32 = te[6],\n            m33 = te[10],\n            trace = m11 + m22 + m33;\n\n        if (trace > 0) {\n            const s = 0.5 / Math.sqrt(trace + 1.0);\n\n            this._w = 0.25 / s;\n            this._x = (m32 - m23) * s;\n            this._y = (m13 - m31) * s;\n            this._z = (m21 - m12) * s;\n        } else if (m11 > m22 && m11 > m33) {\n            const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n\n            this._w = (m32 - m23) / s;\n            this._x = 0.25 * s;\n            this._y = (m12 + m21) / s;\n            this._z = (m13 + m31) / s;\n        } else if (m22 > m33) {\n            const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n\n            this._w = (m13 - m31) / s;\n            this._x = (m12 + m21) / s;\n            this._y = 0.25 * s;\n            this._z = (m23 + m32) / s;\n        } else {\n            const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n\n            this._w = (m21 - m12) / s;\n            this._x = (m13 + m31) / s;\n            this._y = (m23 + m32) / s;\n            this._z = 0.25 * s;\n        }\n\n        this._onChangeCallback(this);\n\n        return this;\n    }\n\n    setFromUnitVectors(vFrom: Vector3, vTo: Vector3) {\n        // assumes direction vectors vFrom and vTo are normalized\n\n        let r = vFrom.dot(vTo) + 1;\n\n        if (r < Number.EPSILON) {\n            // vFrom and vTo point in opposite directions\n\n            r = 0;\n\n            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n                this._x = -vFrom.y;\n                this._y = vFrom.x;\n                this._z = 0;\n                this._w = r;\n            } else {\n                this._x = 0;\n                this._y = -vFrom.z;\n                this._z = vFrom.y;\n                this._w = r;\n            }\n        } else {\n            // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\n            this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n            this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n            this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n            this._w = r;\n        }\n\n        return this.normalize();\n    }\n\n    angleTo(q: Quaternion) {\n        return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));\n    }\n\n    rotateTowards(q: Quaternion, step: number) {\n        const angle = this.angleTo(q);\n\n        if (angle === 0) return this;\n\n        const t = Math.min(1, step / angle);\n\n        this.slerp(q, t);\n\n        return this;\n    }\n\n    identity() {\n        return this.set(0, 0, 0, 1);\n    }\n\n    invert() {\n        // quaternion is assumed to have unit length\n\n        return this.conjugate();\n    }\n\n    conjugate() {\n        this.x *= -1;\n        this.y *= -1;\n        this.z *= -1;\n\n        this._onChangeCallback(this);\n\n        return this;\n    }\n\n    dot(v: Quaternion) {\n        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n    }\n\n    lengthSq() {\n        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n    }\n\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n    }\n\n    normalize() {\n        let l = this.length();\n\n        if (l === 0) {\n            this._x = 0;\n            this._y = 0;\n            this._z = 0;\n            this._w = 1;\n        } else {\n            l = 1 / l;\n\n            this._x = this.x * l;\n            this._y = this.y * l;\n            this._z = this.z * l;\n            this._w = this.w * l;\n        }\n\n        this._onChangeCallback(this);\n\n        return this;\n    }\n\n    multiply(q: Quaternion) {\n        return this.multiplyQuaternions(this, q);\n    }\n\n    premultiply(q: Quaternion) {\n        return this.multiplyQuaternions(q, this);\n    }\n\n    multiplyQuaternions(a: Quaternion, b: Quaternion) {\n        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n        const qax = a.x,\n            qay = a.y,\n            qaz = a.z,\n            qaw = a.w;\n        const qbx = b.x,\n            qby = b.y,\n            qbz = b.z,\n            qbw = b.w;\n\n        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n        this._onChangeCallback(this);\n\n        return this;\n    }\n\n    slerp(qb: Quaternion, t: number) {\n        if (t === 0) return this;\n        if (t === 1) return this.copy(qb);\n\n        const x = this.x,\n            y = this.y,\n            z = this.z,\n            w = this.w;\n\n        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n        let cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;\n\n        if (cosHalfTheta < 0) {\n            this.w = -qb.w;\n            this.x = -qb.x;\n            this.y = -qb.y;\n            this.z = -qb.z;\n\n            cosHalfTheta = -cosHalfTheta;\n        } else {\n            this.copy(qb);\n        }\n\n        if (cosHalfTheta >= 1.0) {\n            this.w = w;\n            this.x = x;\n            this.y = y;\n            this.z = z;\n\n            return this;\n        }\n\n        const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n        if (sqrSinHalfTheta <= Number.EPSILON) {\n            const s = 1 - t;\n            this.w = s * w + t * this.w;\n            this.x = s * x + t * this.x;\n            this.y = s * y + t * this.y;\n            this.z = s * z + t * this.z;\n\n            this.normalize();\n            return this;\n        }\n\n        const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n        const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n        const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,\n            ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n\n        this.w = w * ratioA + this.w * ratioB;\n        this.x = x * ratioA + this.x * ratioB;\n        this.y = y * ratioA + this.y * ratioB;\n        this.z = z * ratioA + this.z * ratioB;\n\n        this._onChangeCallback(this);\n\n        return this;\n    }\n\n    slerpQuaternions(qa: Quaternion, qb: Quaternion, t: number) {\n        return this.copy(qa).slerp(qb, t);\n    }\n\n    random() {\n        // Derived from http://planning.cs.uiuc.edu/node198.html\n        // Note, this source uses w, x, y, z ordering,\n        // so we swap the order below.\n\n        const u1 = Math.random();\n        const sqrt1u1 = Math.sqrt(1 - u1);\n        const sqrtu1 = Math.sqrt(u1);\n\n        const u2 = 2 * Math.PI * Math.random();\n\n        const u3 = 2 * Math.PI * Math.random();\n\n        return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));\n    }\n\n    equals(quaternion: Quaternion) {\n        return quaternion.x === this.x && quaternion.y === this.y && quaternion.z === this.z && quaternion.w === this.w;\n    }\n\n    fromArray(array: Array<number>, offset = 0) {\n        this.x = array[offset];\n        this.y = array[offset + 1];\n        this.z = array[offset + 2];\n        this.w = array[offset + 3];\n\n        this._onChangeCallback(this);\n\n        return this;\n    }\n\n    toArray(array: Array<number> = [], offset = 0) {\n        array[offset] = this.x;\n        array[offset + 1] = this.y;\n        array[offset + 2] = this.z;\n        array[offset + 3] = this.w;\n\n        return array;\n    }\n\n    fromBufferAttribute(attribute: BufferAttribute, index: number) {\n        this.x = attribute.getX(index);\n        this.y = attribute.getY(index);\n        this.z = attribute.getZ(index);\n        this.w = attribute.getW(index);\n\n        return this;\n    }\n\n    toJSON() {\n        return this.toArray();\n    }\n\n    public onChange(callback: (q: Quaternion) => void) {\n        this._onChangeCallback = callback;\n    }\n\n    *[Symbol.iterator]() {\n        yield this.x;\n        yield this.y;\n        yield this.z;\n        yield this.w;\n    }\n}\n\nexport { Quaternion };\n","import { Box3 } from \"./Box3\";\nimport { Matrix4 } from \"./Matrix4\";\nimport { Plane } from \"./Plane\";\nimport { Vector3 } from \"./Vector3\";\n\nconst _box = /*@__PURE__*/ new Box3();\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _v2 = /*@__PURE__*/ new Vector3();\n\nexport class Sphere {\n    public center: Vector3;\n    public radius: number;\n\n    constructor(center = new Vector3(), radius = -1) {\n        this.center = center;\n        this.radius = radius;\n    }\n\n    set(center: Vector3, radius: number) {\n        this.center.copy(center);\n        this.radius = radius;\n\n        return this;\n    }\n\n    setFromPoints(points: Array<Vector3>, optionalCenter: Vector3) {\n        const center = this.center;\n\n        if (optionalCenter !== undefined) {\n            center.copy(optionalCenter);\n        } else {\n            _box.setFromPoints(points).getCenter(center);\n        }\n\n        let maxRadiusSq = 0;\n\n        for (let i = 0, il = points.length; i < il; i++) {\n            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\n        }\n\n        this.radius = Math.sqrt(maxRadiusSq);\n\n        return this;\n    }\n\n    copy(sphere: Sphere) {\n        this.center.copy(sphere.center);\n        this.radius = sphere.radius;\n\n        return this;\n    }\n\n    isEmpty() {\n        return this.radius < 0;\n    }\n\n    makeEmpty() {\n        this.center.set(0, 0, 0);\n        this.radius = -1;\n\n        return this;\n    }\n\n    containsPoint(point: Vector3) {\n        return point.distanceToSquared(this.center) <= this.radius * this.radius;\n    }\n\n    distanceToPoint(point: Vector3) {\n        return point.distanceTo(this.center) - this.radius;\n    }\n\n    intersectsSphere(sphere: Sphere) {\n        const radiusSum = this.radius + sphere.radius;\n\n        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n    }\n\n    intersectsBox(box: Box3) {\n        return box.intersectsSphere(this);\n    }\n\n    intersectsPlane(plane: Plane) {\n        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n    }\n\n    clampPoint(point: Vector3, target: Vector3) {\n        const deltaLengthSq = this.center.distanceToSquared(point);\n\n        target.copy(point);\n\n        if (deltaLengthSq > this.radius * this.radius) {\n            target.sub(this.center).normalize();\n            target.multiplyScalar(this.radius).add(this.center);\n        }\n\n        return target;\n    }\n\n    getBoundingBox(target: Box3) {\n        if (this.isEmpty()) {\n            // Empty sphere produces empty bounding box\n            target.makeEmpty();\n            return target;\n        }\n\n        target.set(this.center, this.center);\n        target.expandByScalar(this.radius);\n\n        return target;\n    }\n\n    applyMatrix4(matrix: Matrix4) {\n        this.center.applyMatrix4(matrix);\n        this.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n        return this;\n    }\n\n    translate(offset: Vector3) {\n        this.center.add(offset);\n\n        return this;\n    }\n\n    expandByPoint(point: Vector3) {\n        if (this.isEmpty()) {\n            this.center.copy(point);\n\n            this.radius = 0;\n\n            return this;\n        }\n\n        _v1.subVectors(point, this.center);\n\n        const lengthSq = _v1.lengthSq();\n\n        if (lengthSq > this.radius * this.radius) {\n            // calculate the minimal sphere\n\n            const length = Math.sqrt(lengthSq);\n\n            const delta = (length - this.radius) * 0.5;\n\n            this.center.addScaledVector(_v1, delta / length);\n\n            this.radius += delta;\n        }\n\n        return this;\n    }\n\n    union(sphere: Sphere) {\n        if (sphere.isEmpty()) {\n            return this;\n        }\n\n        if (this.isEmpty()) {\n            this.copy(sphere);\n\n            return this;\n        }\n\n        if (this.center.equals(sphere.center) === true) {\n            this.radius = Math.max(this.radius, sphere.radius);\n        } else {\n            _v2.subVectors(sphere.center, this.center).setLength(sphere.radius);\n\n            this.expandByPoint(_v1.copy(sphere.center).add(_v2));\n\n            this.expandByPoint(_v1.copy(sphere.center).sub(_v2));\n        }\n\n        return this;\n    }\n\n    equals(sphere: Sphere) {\n        return sphere.center.equals(this.center) && sphere.radius === this.radius;\n    }\n\n    clone() {\n        return new Sphere().copy(this);\n    }\n}\n","/**\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.\n * The azimuthal angle (theta) is measured from the positive z-axis.\n */\n\nimport { MathUtils } from \"./MathUtils\";\nimport { Vector3 } from \"./Vector3\";\n\nexport class Spherical {\n    public radius = 1;\n    public phi = 0;\n    public theta = 0;\n    constructor(radius = 1, phi = 0, theta = 0) {\n        this.radius = radius;\n        this.phi = phi; // polar angle\n        this.theta = theta; // azimuthal angle\n\n        return this;\n    }\n\n    set(radius: number, phi: number, theta: number) {\n        this.radius = radius;\n        this.phi = phi;\n        this.theta = theta;\n\n        return this;\n    }\n\n    copy(other: Spherical) {\n        this.radius = other.radius;\n        this.phi = other.phi;\n        this.theta = other.theta;\n\n        return this;\n    }\n\n    // restrict phi to be between EPS and PI-EPS\n    makeSafe() {\n        const EPS = 0.000001;\n        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));\n\n        return this;\n    }\n\n    setFromVector3(v: Vector3) {\n        return this.setFromCartesianCoords(v.x, v.y, v.z);\n    }\n\n    setFromCartesianCoords(x: number, y: number, z: number) {\n        this.radius = Math.sqrt(x * x + y * y + z * z);\n\n        if (this.radius === 0) {\n            this.theta = 0;\n            this.phi = 0;\n        } else {\n            this.theta = Math.atan2(x, z);\n            this.phi = Math.acos(MathUtils.clamp(y / this.radius, -1, 1));\n        }\n\n        return this;\n    }\n\n    clone() {\n        return new Spherical().copy(this);\n    }\n}\n","import * as MathUtils from \"./MathUtils\";\nimport { Matrix3 } from \"./Matrix3\";\n\nclass Vector2 {\n    public x = 0;\n    public y = 0;\n\n    constructor(x = 0, y = 0) {\n        this.x = x;\n        this.y = y;\n    }\n\n    get width() {\n        return this.x;\n    }\n\n    set width(value) {\n        this.x = value;\n    }\n\n    get height() {\n        return this.y;\n    }\n\n    set height(value) {\n        this.y = value;\n    }\n\n    set(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n\n        return this;\n    }\n\n    setScalar(scalar: number) {\n        this.x = scalar;\n        this.y = scalar;\n\n        return this;\n    }\n\n    setX(x: number) {\n        this.x = x;\n\n        return this;\n    }\n\n    setY(y: number) {\n        this.y = y;\n\n        return this;\n    }\n\n    setComponent(index: number, value: number) {\n        switch (index) {\n            case 0:\n                this.x = value;\n                break;\n            case 1:\n                this.y = value;\n                break;\n            default:\n                throw new Error(\"index is out of range: \" + index);\n        }\n\n        return this;\n    }\n\n    getComponent(index: number) {\n        switch (index) {\n            case 0:\n                return this.x;\n            case 1:\n                return this.y;\n            default:\n                throw new Error(\"index is out of range: \" + index);\n        }\n    }\n\n    clone() {\n        return new Vector2(this.x, this.y);\n    }\n\n    copy(v: Vector2) {\n        this.x = v.x;\n        this.y = v.y;\n\n        return this;\n    }\n\n    add(v: Vector2) {\n        this.x += v.x;\n        this.y += v.y;\n\n        return this;\n    }\n\n    addScalar(s: number) {\n        this.x += s;\n        this.y += s;\n\n        return this;\n    }\n\n    addVectors(a: Vector2, b: Vector2) {\n        this.x = a.x + b.x;\n        this.y = a.y + b.y;\n\n        return this;\n    }\n\n    addScaledVector(v: Vector2, s: number) {\n        this.x += v.x * s;\n        this.y += v.y * s;\n\n        return this;\n    }\n\n    sub(v: Vector2) {\n        this.x -= v.x;\n        this.y -= v.y;\n\n        return this;\n    }\n\n    subScalar(s: number) {\n        this.x -= s;\n        this.y -= s;\n\n        return this;\n    }\n\n    subVectors(a: Vector2, b: Vector2) {\n        this.x = a.x - b.x;\n        this.y = a.y - b.y;\n\n        return this;\n    }\n\n    multiply(v: Vector2) {\n        this.x *= v.x;\n        this.y *= v.y;\n\n        return this;\n    }\n\n    multiplyScalar(scalar: number) {\n        this.x *= scalar;\n        this.y *= scalar;\n\n        return this;\n    }\n\n    divide(v: Vector2) {\n        this.x /= v.x;\n        this.y /= v.y;\n\n        return this;\n    }\n\n    divideScalar(scalar: number) {\n        return this.multiplyScalar(1 / scalar);\n    }\n\n    applyMatrix3(m: Matrix3) {\n        const x = this.x,\n            y = this.y;\n        const e = m.elements;\n\n        this.x = e[0] * x + e[3] * y + e[6];\n        this.y = e[1] * x + e[4] * y + e[7];\n\n        return this;\n    }\n\n    min(v: Vector2) {\n        this.x = Math.min(this.x, v.x);\n        this.y = Math.min(this.y, v.y);\n\n        return this;\n    }\n\n    max(v: Vector2) {\n        this.x = Math.max(this.x, v.x);\n        this.y = Math.max(this.y, v.y);\n\n        return this;\n    }\n\n    clamp(min: Vector2, max: Vector2) {\n        // assumes min < max, componentwise\n\n        this.x = Math.max(min.x, Math.min(max.x, this.x));\n        this.y = Math.max(min.y, Math.min(max.y, this.y));\n\n        return this;\n    }\n\n    clampScalar(minVal: number, maxVal: number) {\n        this.x = Math.max(minVal, Math.min(maxVal, this.x));\n        this.y = Math.max(minVal, Math.min(maxVal, this.y));\n\n        return this;\n    }\n\n    clampLength(min: number, max: number) {\n        const length = this.length();\n\n        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n    }\n\n    floor() {\n        this.x = Math.floor(this.x);\n        this.y = Math.floor(this.y);\n\n        return this;\n    }\n\n    ceil() {\n        this.x = Math.ceil(this.x);\n        this.y = Math.ceil(this.y);\n\n        return this;\n    }\n\n    round() {\n        this.x = Math.round(this.x);\n        this.y = Math.round(this.y);\n\n        return this;\n    }\n\n    roundToZero() {\n        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n\n        return this;\n    }\n\n    negate() {\n        this.x = -this.x;\n        this.y = -this.y;\n\n        return this;\n    }\n\n    dot(v: Vector2) {\n        return this.x * v.x + this.y * v.y;\n    }\n\n    cross(v: Vector2) {\n        return this.x * v.y - this.y * v.x;\n    }\n\n    lengthSq() {\n        return this.x * this.x + this.y * this.y;\n    }\n\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n\n    manhattanLength() {\n        return Math.abs(this.x) + Math.abs(this.y);\n    }\n\n    normalize() {\n        return this.divideScalar(this.length() || 1);\n    }\n\n    angle() {\n        // computes the angle in radians with respect to the positive x-axis\n\n        const angle = Math.atan2(-this.y, -this.x) + Math.PI;\n\n        return angle;\n    }\n\n    angleTo(v: Vector2) {\n        const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n\n        if (denominator === 0) return Math.PI / 2;\n\n        const theta = this.dot(v) / denominator;\n\n        // clamp, to handle numerical problems\n\n        return Math.acos(MathUtils.clamp(theta, -1, 1));\n    }\n\n    distanceTo(v: Vector2) {\n        return Math.sqrt(this.distanceToSquared(v));\n    }\n\n    distanceToSquared(v: Vector2) {\n        const dx = this.x - v.x,\n            dy = this.y - v.y;\n        return dx * dx + dy * dy;\n    }\n\n    manhattanDistanceTo(v: Vector2) {\n        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\n    }\n\n    setLength(length: number) {\n        return this.normalize().multiplyScalar(length);\n    }\n\n    lerp(v: Vector2, alpha: number) {\n        this.x += (v.x - this.x) * alpha;\n        this.y += (v.y - this.y) * alpha;\n\n        return this;\n    }\n\n    lerpVectors(v1: Vector2, v2: Vector2, alpha: number) {\n        this.x = v1.x + (v2.x - v1.x) * alpha;\n        this.y = v1.y + (v2.y - v1.y) * alpha;\n\n        return this;\n    }\n\n    equals(v: Vector2) {\n        return v.x === this.x && v.y === this.y;\n    }\n\n    fromArray(array: Array<number>, offset = 0) {\n        this.x = array[offset];\n        this.y = array[offset + 1];\n\n        return this;\n    }\n\n    toArray(array: Array<number> = [], offset = 0) {\n        array[offset] = this.x;\n        array[offset + 1] = this.y;\n\n        return array;\n    }\n\n    // fromBufferAttribute( attribute, index ) {\n\n    // \tthis.x = attribute.getX( index );\n    // \tthis.y = attribute.getY( index );\n\n    // \treturn this;\n\n    // }\n\n    rotateAround(center: Vector2, angle: number) {\n        const c = Math.cos(angle),\n            s = Math.sin(angle);\n\n        const x = this.x - center.x;\n        const y = this.y - center.y;\n\n        this.x = x * c - y * s + center.x;\n        this.y = x * s + y * c + center.y;\n\n        return this;\n    }\n\n    random() {\n        this.x = Math.random();\n        this.y = Math.random();\n\n        return this;\n    }\n\n    *[Symbol.iterator]() {\n        yield this.x;\n        yield this.y;\n    }\n}\n\nexport { Vector2 };\n","import { BufferAttribute } from \"../core/BufferAttribute\";\nimport { Color } from \"./Color\";\nimport { Euler } from \"./Euler\";\nimport * as MathUtils from \"./MathUtils\";\nimport { Matrix3 } from \"./Matrix3\";\nimport { Matrix4 } from \"./Matrix4\";\nimport { Quaternion } from \"./Quaternion\";\nimport { Spherical } from \"./Spherical\";\n\nclass Vector3 {\n    public x = 0;\n    public y = 0;\n    public z = 0;\n\n    constructor(x = 0, y = 0, z = 0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    set(x: number, y: number, z: number) {\n        if (z === undefined) z = this.z; // sprite.scale.set(x,y)\n\n        this.x = x;\n        this.y = y;\n        this.z = z;\n\n        return this;\n    }\n\n    setScalar(scalar: number) {\n        this.x = scalar;\n        this.y = scalar;\n        this.z = scalar;\n\n        return this;\n    }\n\n    setX(x: number) {\n        this.x = x;\n\n        return this;\n    }\n\n    setY(y: number) {\n        this.y = y;\n\n        return this;\n    }\n\n    setZ(z: number) {\n        this.z = z;\n\n        return this;\n    }\n\n    setComponent(index: number, value: number) {\n        switch (index) {\n            case 0:\n                this.x = value;\n                break;\n            case 1:\n                this.y = value;\n                break;\n            case 2:\n                this.z = value;\n                break;\n            default:\n                throw new Error(\"index is out of range: \" + index);\n        }\n\n        return this;\n    }\n\n    getComponent(index: number) {\n        switch (index) {\n            case 0:\n                return this.x;\n            case 1:\n                return this.y;\n            case 2:\n                return this.z;\n            default:\n                throw new Error(\"index is out of range: \" + index);\n        }\n    }\n\n    clone() {\n        return new Vector3(this.x, this.y, this.z);\n    }\n\n    copy(v: Vector3) {\n        this.x = v.x;\n        this.y = v.y;\n        this.z = v.z;\n\n        return this;\n    }\n\n    add(v: Vector3) {\n        this.x += v.x;\n        this.y += v.y;\n        this.z += v.z;\n\n        return this;\n    }\n\n    addScalar(s: number) {\n        this.x += s;\n        this.y += s;\n        this.z += s;\n\n        return this;\n    }\n\n    addVectors(a: Vector3, b: Vector3) {\n        this.x = a.x + b.x;\n        this.y = a.y + b.y;\n        this.z = a.z + b.z;\n\n        return this;\n    }\n\n    addScaledVector(v: Vector3, s: number) {\n        this.x += v.x * s;\n        this.y += v.y * s;\n        this.z += v.z * s;\n\n        return this;\n    }\n\n    sub(v: Vector3) {\n        this.x -= v.x;\n        this.y -= v.y;\n        this.z -= v.z;\n\n        return this;\n    }\n\n    subScalar(s: number) {\n        this.x -= s;\n        this.y -= s;\n        this.z -= s;\n\n        return this;\n    }\n\n    subVectors(a: Vector3, b: Vector3) {\n        this.x = a.x - b.x;\n        this.y = a.y - b.y;\n        this.z = a.z - b.z;\n\n        return this;\n    }\n\n    multiply(v: Vector3) {\n        this.x *= v.x;\n        this.y *= v.y;\n        this.z *= v.z;\n\n        return this;\n    }\n\n    multiplyScalar(scalar: number) {\n        this.x *= scalar;\n        this.y *= scalar;\n        this.z *= scalar;\n\n        return this;\n    }\n\n    multiplyVectors(a: Vector3, b: Vector3) {\n        this.x = a.x * b.x;\n        this.y = a.y * b.y;\n        this.z = a.z * b.z;\n\n        return this;\n    }\n\n    applyEuler(euler: Euler) {\n        return this.applyQuaternion(_quaternion.setFromEuler(euler));\n    }\n\n    applyAxisAngle(axis: Vector3, angle: number) {\n        return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));\n    }\n\n    applyMatrix3(m: Matrix3) {\n        const x = this.x,\n            y = this.y,\n            z = this.z;\n        const e = m.elements;\n\n        this.x = e[0] * x + e[3] * y + e[6] * z;\n        this.y = e[1] * x + e[4] * y + e[7] * z;\n        this.z = e[2] * x + e[5] * y + e[8] * z;\n\n        return this;\n    }\n\n    applyNormalMatrix(m: Matrix3) {\n        return this.applyMatrix3(m).normalize();\n    }\n\n    applyMatrix4(m: Matrix4) {\n        const x = this.x,\n            y = this.y,\n            z = this.z;\n        const e = m.elements;\n\n        const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);\n\n        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;\n        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;\n        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;\n\n        return this;\n    }\n\n    applyQuaternion(q: Quaternion) {\n        const x = this.x,\n            y = this.y,\n            z = this.z;\n        const qx = q.x,\n            qy = q.y,\n            qz = q.z,\n            qw = q.w;\n\n        // calculate quat * vector\n\n        const ix = qw * x + qy * z - qz * y;\n        const iy = qw * y + qz * x - qx * z;\n        const iz = qw * z + qx * y - qy * x;\n        const iw = -qx * x - qy * y - qz * z;\n\n        // calculate result * inverse quat\n\n        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n        return this;\n    }\n\n    // project( camera ) {\n\n    // \treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\n\n    // }\n\n    // unproject( camera ) {\n\n    // \treturn this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );\n\n    // }\n\n    transformDirection(m: Matrix4) {\n        // input: THREE.Matrix4 affine matrix\n        // vector interpreted as a direction\n\n        const x = this.x,\n            y = this.y,\n            z = this.z;\n        const e = m.elements;\n\n        this.x = e[0] * x + e[4] * y + e[8] * z;\n        this.y = e[1] * x + e[5] * y + e[9] * z;\n        this.z = e[2] * x + e[6] * y + e[10] * z;\n\n        return this.normalize();\n    }\n\n    divide(v: Vector3) {\n        this.x /= v.x;\n        this.y /= v.y;\n        this.z /= v.z;\n\n        return this;\n    }\n\n    divideScalar(scalar: number) {\n        return this.multiplyScalar(1 / scalar);\n    }\n\n    min(v: Vector3) {\n        this.x = Math.min(this.x, v.x);\n        this.y = Math.min(this.y, v.y);\n        this.z = Math.min(this.z, v.z);\n\n        return this;\n    }\n\n    max(v: Vector3) {\n        this.x = Math.max(this.x, v.x);\n        this.y = Math.max(this.y, v.y);\n        this.z = Math.max(this.z, v.z);\n\n        return this;\n    }\n\n    clamp(min: Vector3, max: Vector3) {\n        // assumes min < max, componentwise\n\n        this.x = Math.max(min.x, Math.min(max.x, this.x));\n        this.y = Math.max(min.y, Math.min(max.y, this.y));\n        this.z = Math.max(min.z, Math.min(max.z, this.z));\n\n        return this;\n    }\n\n    clampScalar(minVal: number, maxVal: number) {\n        this.x = Math.max(minVal, Math.min(maxVal, this.x));\n        this.y = Math.max(minVal, Math.min(maxVal, this.y));\n        this.z = Math.max(minVal, Math.min(maxVal, this.z));\n\n        return this;\n    }\n\n    clampLength(min: number, max: number) {\n        const length = this.length();\n\n        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n    }\n\n    floor() {\n        this.x = Math.floor(this.x);\n        this.y = Math.floor(this.y);\n        this.z = Math.floor(this.z);\n\n        return this;\n    }\n\n    ceil() {\n        this.x = Math.ceil(this.x);\n        this.y = Math.ceil(this.y);\n        this.z = Math.ceil(this.z);\n\n        return this;\n    }\n\n    round() {\n        this.x = Math.round(this.x);\n        this.y = Math.round(this.y);\n        this.z = Math.round(this.z);\n\n        return this;\n    }\n\n    roundToZero() {\n        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n\n        return this;\n    }\n\n    negate() {\n        this.x = -this.x;\n        this.y = -this.y;\n        this.z = -this.z;\n\n        return this;\n    }\n\n    dot(v: Vector3) {\n        return this.x * v.x + this.y * v.y + this.z * v.z;\n    }\n\n    // TODO lengthSquared?\n\n    lengthSq() {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n\n    manhattanLength() {\n        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n    }\n\n    normalize() {\n        return this.divideScalar(this.length() || 1);\n    }\n\n    setLength(length: number) {\n        return this.normalize().multiplyScalar(length);\n    }\n\n    lerp(v: Vector3, alpha: number) {\n        this.x += (v.x - this.x) * alpha;\n        this.y += (v.y - this.y) * alpha;\n        this.z += (v.z - this.z) * alpha;\n\n        return this;\n    }\n\n    lerpVectors(v1: Vector3, v2: Vector3, alpha: number) {\n        this.x = v1.x + (v2.x - v1.x) * alpha;\n        this.y = v1.y + (v2.y - v1.y) * alpha;\n        this.z = v1.z + (v2.z - v1.z) * alpha;\n\n        return this;\n    }\n\n    cross(v: Vector3) {\n        return this.crossVectors(this, v);\n    }\n\n    crossVectors(a: Vector3, b: Vector3) {\n        const ax = a.x,\n            ay = a.y,\n            az = a.z;\n        const bx = b.x,\n            by = b.y,\n            bz = b.z;\n\n        this.x = ay * bz - az * by;\n        this.y = az * bx - ax * bz;\n        this.z = ax * by - ay * bx;\n\n        return this;\n    }\n\n    projectOnVector(v: Vector3) {\n        const denominator = v.lengthSq();\n\n        if (denominator === 0) return this.set(0, 0, 0);\n\n        const scalar = v.dot(this) / denominator;\n\n        return this.copy(v).multiplyScalar(scalar);\n    }\n\n    projectOnPlane(planeNormal: Vector3) {\n        _vector.copy(this).projectOnVector(planeNormal);\n\n        return this.sub(_vector);\n    }\n\n    reflect(normal: Vector3) {\n        // reflect incident vector off plane orthogonal to normal\n        // normal is assumed to have unit length\n\n        return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));\n    }\n\n    angleTo(v: Vector3) {\n        const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n\n        if (denominator === 0) return Math.PI / 2;\n\n        const theta = this.dot(v) / denominator;\n\n        // clamp, to handle numerical problems\n\n        return Math.acos(MathUtils.clamp(theta, -1, 1));\n    }\n\n    distanceTo(v: Vector3) {\n        return Math.sqrt(this.distanceToSquared(v));\n    }\n\n    distanceToSquared(v: Vector3) {\n        const dx = this.x - v.x,\n            dy = this.y - v.y,\n            dz = this.z - v.z;\n\n        return dx * dx + dy * dy + dz * dz;\n    }\n\n    manhattanDistanceTo(v: Vector3) {\n        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n    }\n\n    setFromSpherical(s: Spherical) {\n        return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n    }\n\n    setFromSphericalCoords(radius: number, phi: number, theta: number) {\n        const sinPhiRadius = Math.sin(phi) * radius;\n\n        this.x = sinPhiRadius * Math.sin(theta);\n        this.y = Math.cos(phi) * radius;\n        this.z = sinPhiRadius * Math.cos(theta);\n\n        return this;\n    }\n\n    // setFromCylindrical( c ) {\n\n    // \treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\n\n    // }\n\n    setFromCylindricalCoords(radius: number, theta: number, y: number) {\n        this.x = radius * Math.sin(theta);\n        this.y = y;\n        this.z = radius * Math.cos(theta);\n\n        return this;\n    }\n\n    setFromMatrixPosition(m: Matrix4) {\n        const e = m.elements;\n\n        this.x = e[12];\n        this.y = e[13];\n        this.z = e[14];\n\n        return this;\n    }\n\n    setFromMatrixScale(m: Matrix4) {\n        const sx = this.setFromMatrixColumn(m, 0).length();\n        const sy = this.setFromMatrixColumn(m, 1).length();\n        const sz = this.setFromMatrixColumn(m, 2).length();\n\n        this.x = sx;\n        this.y = sy;\n        this.z = sz;\n\n        return this;\n    }\n\n    setFromMatrixColumn(m: Matrix4, index: number) {\n        return this.fromArray(m.elements, index * 4);\n    }\n\n    setFromMatrix3Column(m: Matrix3, index: number) {\n        return this.fromArray(m.elements, index * 3);\n    }\n\n    setFromEuler(e: Euler) {\n        this.x = e.x;\n        this.y = e.y;\n        this.z = e.z;\n\n        return this;\n    }\n\n    setFromColor(c: Color) {\n        this.x = c.r;\n        this.y = c.g;\n        this.z = c.b;\n\n        return this;\n    }\n\n    equals(v: Vector3) {\n        return v.x === this.x && v.y === this.y && v.z === this.z;\n    }\n\n    fromArray(array: Array<number>, offset = 0) {\n        this.x = array[offset];\n        this.y = array[offset + 1];\n        this.z = array[offset + 2];\n\n        return this;\n    }\n\n    toArray(array: Array<number> = [], offset = 0) {\n        array[offset] = this.x;\n        array[offset + 1] = this.y;\n        array[offset + 2] = this.z;\n\n        return array;\n    }\n\n    fromBufferAttribute(attribute: BufferAttribute, index: number) {\n        this.x = attribute.getX(index);\n        this.y = attribute.getY(index);\n        this.z = attribute.getZ(index);\n\n        return this;\n    }\n\n    random() {\n        this.x = Math.random();\n        this.y = Math.random();\n        this.z = Math.random();\n\n        return this;\n    }\n\n    randomDirection() {\n        // Derived from https://mathworld.wolfram.com/SpherePointPicking.html\n\n        const u = (Math.random() - 0.5) * 2;\n        const t = Math.random() * Math.PI * 2;\n        const f = Math.sqrt(1 - u ** 2);\n\n        this.x = f * Math.cos(t);\n        this.y = f * Math.sin(t);\n        this.z = u;\n\n        return this;\n    }\n\n    *[Symbol.iterator]() {\n        yield this.x;\n        yield this.y;\n        yield this.z;\n    }\n}\n\nconst _vector = /*@__PURE__*/ new Vector3();\nconst _quaternion = /*@__PURE__*/ new Quaternion();\n\nexport { Vector3 };\n","import { BufferAttribute } from \"../core/BufferAttribute\";\nimport { Matrix4 } from \"./Matrix4\";\nimport { Quaternion } from \"./Quaternion\";\n\nexport class Vector4 {\n    public x: number;\n    public y: number;\n    public z: number;\n    public w: number;\n\n    constructor(x = 0, y = 0, z = 0, w = 1) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n\n    get width() {\n        return this.z;\n    }\n\n    set width(value) {\n        this.z = value;\n    }\n\n    get height() {\n        return this.w;\n    }\n\n    set height(value) {\n        this.w = value;\n    }\n\n    set(x: number, y: number, z: number, w: number) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n\n        return this;\n    }\n\n    setScalar(scalar: number) {\n        this.x = scalar;\n        this.y = scalar;\n        this.z = scalar;\n        this.w = scalar;\n\n        return this;\n    }\n\n    setX(x: number) {\n        this.x = x;\n\n        return this;\n    }\n\n    setY(y: number) {\n        this.y = y;\n\n        return this;\n    }\n\n    setZ(z: number) {\n        this.z = z;\n\n        return this;\n    }\n\n    setW(w: number) {\n        this.w = w;\n\n        return this;\n    }\n\n    setComponent(index: number, value: number) {\n        switch (index) {\n            case 0:\n                this.x = value;\n                break;\n            case 1:\n                this.y = value;\n                break;\n            case 2:\n                this.z = value;\n                break;\n            case 3:\n                this.w = value;\n                break;\n            default:\n                throw new Error(\"index is out of range: \" + index);\n        }\n\n        return this;\n    }\n\n    getComponent(index: number) {\n        switch (index) {\n            case 0:\n                return this.x;\n            case 1:\n                return this.y;\n            case 2:\n                return this.z;\n            case 3:\n                return this.w;\n            default:\n                throw new Error(\"index is out of range: \" + index);\n        }\n    }\n\n    clone() {\n        return new Vector4(this.x, this.y, this.z, this.w);\n    }\n\n    copy(v: Vector4) {\n        this.x = v.x;\n        this.y = v.y;\n        this.z = v.z;\n        this.w = v.w !== undefined ? v.w : 1;\n\n        return this;\n    }\n\n    add(v: Vector4) {\n        this.x += v.x;\n        this.y += v.y;\n        this.z += v.z;\n        this.w += v.w;\n\n        return this;\n    }\n\n    addScalar(s: number) {\n        this.x += s;\n        this.y += s;\n        this.z += s;\n        this.w += s;\n\n        return this;\n    }\n\n    addVectors(a: Vector4, b: Vector4) {\n        this.x = a.x + b.x;\n        this.y = a.y + b.y;\n        this.z = a.z + b.z;\n        this.w = a.w + b.w;\n\n        return this;\n    }\n\n    addScaledVector(v: Vector4, s: number) {\n        this.x += v.x * s;\n        this.y += v.y * s;\n        this.z += v.z * s;\n        this.w += v.w * s;\n\n        return this;\n    }\n\n    sub(v: Vector4) {\n        this.x -= v.x;\n        this.y -= v.y;\n        this.z -= v.z;\n        this.w -= v.w;\n\n        return this;\n    }\n\n    subScalar(s: number) {\n        this.x -= s;\n        this.y -= s;\n        this.z -= s;\n        this.w -= s;\n\n        return this;\n    }\n\n    subVectors(a: Vector4, b: Vector4) {\n        this.x = a.x - b.x;\n        this.y = a.y - b.y;\n        this.z = a.z - b.z;\n        this.w = a.w - b.w;\n\n        return this;\n    }\n\n    multiply(v: Vector4) {\n        this.x *= v.x;\n        this.y *= v.y;\n        this.z *= v.z;\n        this.w *= v.w;\n\n        return this;\n    }\n\n    multiplyScalar(scalar: number) {\n        this.x *= scalar;\n        this.y *= scalar;\n        this.z *= scalar;\n        this.w *= scalar;\n\n        return this;\n    }\n\n    applyMatrix4(m: Matrix4) {\n        const x = this.x,\n            y = this.y,\n            z = this.z,\n            w = this.w;\n        const e = m.elements;\n\n        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\n        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\n        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\n        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\n\n        return this;\n    }\n\n    divideScalar(scalar: number) {\n        return this.multiplyScalar(1 / scalar);\n    }\n\n    setAxisAngleFromQuaternion(q: Quaternion) {\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n        // q is assumed to be normalized\n\n        this.w = 2 * Math.acos(q.w);\n\n        const s = Math.sqrt(1 - q.w * q.w);\n\n        if (s < 0.0001) {\n            this.x = 1;\n            this.y = 0;\n            this.z = 0;\n        } else {\n            this.x = q.x / s;\n            this.y = q.y / s;\n            this.z = q.z / s;\n        }\n\n        return this;\n    }\n\n    setAxisAngleFromRotationMatrix(m: Matrix4) {\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        let angle, x, y, z; // variables for result\n        const epsilon = 0.01, // margin to allow for rounding errors\n            epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees\n            te = m.elements,\n            m11 = te[0],\n            m12 = te[4],\n            m13 = te[8],\n            m21 = te[1],\n            m22 = te[5],\n            m23 = te[9],\n            m31 = te[2],\n            m32 = te[6],\n            m33 = te[10];\n\n        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n            // singularity found\n            // first check for identity matrix which must have +1 for all terms\n            // in leading diagonal and zero in other terms\n\n            if (\n                Math.abs(m12 + m21) < epsilon2 &&\n                Math.abs(m13 + m31) < epsilon2 &&\n                Math.abs(m23 + m32) < epsilon2 &&\n                Math.abs(m11 + m22 + m33 - 3) < epsilon2\n            ) {\n                // this singularity is identity matrix so angle = 0\n\n                this.set(1, 0, 0, 0);\n\n                return this; // zero angle, arbitrary axis\n            }\n\n            // otherwise this singularity is angle = 180\n\n            angle = Math.PI;\n\n            const xx = (m11 + 1) / 2;\n            const yy = (m22 + 1) / 2;\n            const zz = (m33 + 1) / 2;\n            const xy = (m12 + m21) / 4;\n            const xz = (m13 + m31) / 4;\n            const yz = (m23 + m32) / 4;\n\n            if (xx > yy && xx > zz) {\n                // m11 is the largest diagonal term\n\n                if (xx < epsilon) {\n                    x = 0;\n                    y = 0.707106781;\n                    z = 0.707106781;\n                } else {\n                    x = Math.sqrt(xx);\n                    y = xy / x;\n                    z = xz / x;\n                }\n            } else if (yy > zz) {\n                // m22 is the largest diagonal term\n\n                if (yy < epsilon) {\n                    x = 0.707106781;\n                    y = 0;\n                    z = 0.707106781;\n                } else {\n                    y = Math.sqrt(yy);\n                    x = xy / y;\n                    z = yz / y;\n                }\n            } else {\n                // m33 is the largest diagonal term so base result on this\n\n                if (zz < epsilon) {\n                    x = 0.707106781;\n                    y = 0.707106781;\n                    z = 0;\n                } else {\n                    z = Math.sqrt(zz);\n                    x = xz / z;\n                    y = yz / z;\n                }\n            }\n\n            this.set(x, y, z, angle);\n\n            return this; // return 180 deg rotation\n        }\n\n        // as we have reached here there are no singularities so we can handle normally\n\n        let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize\n\n        if (Math.abs(s) < 0.001) s = 1;\n\n        // prevent divide by zero, should not happen if matrix is orthogonal and should be\n        // caught by singularity test above, but I've left it in just in case\n\n        this.x = (m32 - m23) / s;\n        this.y = (m13 - m31) / s;\n        this.z = (m21 - m12) / s;\n        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n\n        return this;\n    }\n\n    min(v: Vector4) {\n        this.x = Math.min(this.x, v.x);\n        this.y = Math.min(this.y, v.y);\n        this.z = Math.min(this.z, v.z);\n        this.w = Math.min(this.w, v.w);\n\n        return this;\n    }\n\n    max(v: Vector4) {\n        this.x = Math.max(this.x, v.x);\n        this.y = Math.max(this.y, v.y);\n        this.z = Math.max(this.z, v.z);\n        this.w = Math.max(this.w, v.w);\n\n        return this;\n    }\n\n    clamp(min: Vector4, max: Vector4) {\n        // assumes min < max, componentwise\n\n        this.x = Math.max(min.x, Math.min(max.x, this.x));\n        this.y = Math.max(min.y, Math.min(max.y, this.y));\n        this.z = Math.max(min.z, Math.min(max.z, this.z));\n        this.w = Math.max(min.w, Math.min(max.w, this.w));\n\n        return this;\n    }\n\n    clampScalar(minVal: number, maxVal: number) {\n        this.x = Math.max(minVal, Math.min(maxVal, this.x));\n        this.y = Math.max(minVal, Math.min(maxVal, this.y));\n        this.z = Math.max(minVal, Math.min(maxVal, this.z));\n        this.w = Math.max(minVal, Math.min(maxVal, this.w));\n\n        return this;\n    }\n\n    clampLength(min: number, max: number) {\n        const length = this.length();\n\n        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n    }\n\n    floor() {\n        this.x = Math.floor(this.x);\n        this.y = Math.floor(this.y);\n        this.z = Math.floor(this.z);\n        this.w = Math.floor(this.w);\n\n        return this;\n    }\n\n    ceil() {\n        this.x = Math.ceil(this.x);\n        this.y = Math.ceil(this.y);\n        this.z = Math.ceil(this.z);\n        this.w = Math.ceil(this.w);\n\n        return this;\n    }\n\n    round() {\n        this.x = Math.round(this.x);\n        this.y = Math.round(this.y);\n        this.z = Math.round(this.z);\n        this.w = Math.round(this.w);\n\n        return this;\n    }\n\n    roundToZero() {\n        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);\n\n        return this;\n    }\n\n    negate() {\n        this.x = -this.x;\n        this.y = -this.y;\n        this.z = -this.z;\n        this.w = -this.w;\n\n        return this;\n    }\n\n    dot(v: Vector4) {\n        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n    }\n\n    lengthSq() {\n        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n    }\n\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n    }\n\n    manhattanLength() {\n        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n    }\n\n    normalize() {\n        return this.divideScalar(this.length() || 1);\n    }\n\n    setLength(length: number) {\n        return this.normalize().multiplyScalar(length);\n    }\n\n    lerp(v: Vector4, alpha: number) {\n        this.x += (v.x - this.x) * alpha;\n        this.y += (v.y - this.y) * alpha;\n        this.z += (v.z - this.z) * alpha;\n        this.w += (v.w - this.w) * alpha;\n\n        return this;\n    }\n\n    lerpVectors(v1: Vector4, v2: Vector4, alpha: number) {\n        this.x = v1.x + (v2.x - v1.x) * alpha;\n        this.y = v1.y + (v2.y - v1.y) * alpha;\n        this.z = v1.z + (v2.z - v1.z) * alpha;\n        this.w = v1.w + (v2.w - v1.w) * alpha;\n\n        return this;\n    }\n\n    equals(v: Vector4) {\n        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n    }\n\n    fromArray(array: Array<number>, offset = 0) {\n        this.x = array[offset];\n        this.y = array[offset + 1];\n        this.z = array[offset + 2];\n        this.w = array[offset + 3];\n\n        return this;\n    }\n\n    toArray(array = new Float32Array(4), offset = 0) {\n        array[offset] = this.x;\n        array[offset + 1] = this.y;\n        array[offset + 2] = this.z;\n        array[offset + 3] = this.w;\n\n        return array;\n    }\n\n    fromBufferAttribute(attribute: BufferAttribute, index: number) {\n        this.x = attribute.getX(index);\n        this.y = attribute.getY(index);\n        this.z = attribute.getZ(index);\n        this.w = attribute.getW(index);\n\n        return this;\n    }\n\n    random() {\n        this.x = Math.random();\n        this.y = Math.random();\n        this.z = Math.random();\n        this.w = Math.random();\n\n        return this;\n    }\n\n    *[Symbol.iterator]() {\n        yield this.x;\n        yield this.y;\n        yield this.z;\n        yield this.w;\n    }\n}\n","import { BufferGeometry } from \"../core/BufferGeometry\";\nimport { Material } from \"../materials/Material\";\nimport { RenderableObject } from \"../core/RenderableObject\";\nimport { Object3D } from \"../core/Object3D\";\n\nexport class Mesh extends RenderableObject {\n    public get type() {\n        return \"Mesh\";\n    }\n\n    public static Is(object: Object3D) {\n        return object instanceof Mesh;\n    }\n\n    constructor(geometry: BufferGeometry, material: Material) {\n        super(geometry, material);\n    }\n}\n","import { Camera } from \"../cameras/Camera\";\nimport { PerspectiveCamera } from \"../cameras/PerspectiveCamera\";\nimport { GPUIndexFormat, GPUTextureFormat } from \"../Constants\";\nimport { RenderableObject } from \"../core/RenderableObject\";\nimport { Context } from \"../core/ResourceManagers\";\nimport { Scene } from \"../core/Scene\";\nimport { Material } from \"../materials/Material\";\nimport { Color } from \"../math/Color\";\nimport { RenderTarget } from \"./WebGPURenderTarget\";\n\ninterface WebGPURendererParameters {\n    canvas?: HTMLCanvasElement;\n    powerPreference?: GPUPowerPreference;\n    sampleCount?: number;\n    antialias?: boolean;\n}\n\ninterface RendererSize {\n    width: number;\n    height: number;\n}\n\nexport class WebGPURenderer {\n    private _parameters: WebGPURendererParameters;\n    private _canvas: HTMLCanvasElement;\n    private _device: GPUDevice;\n    private _presentationFormat: GPUTextureFormat = Context.textureFormat;\n    private _context: GPUCanvasContext;\n    private _alphaMode: GPUCanvasAlphaMode = \"premultiplied\";\n    private _colorBuffer: GPUTexture;\n    private _depthBuffer: GPUTexture;\n    private _size: RendererSize;\n    private _pixelRatio = window.devicePixelRatio || 1;\n    private _colorAttachmentView: GPUTextureView;\n    private _sampleCount = 1;\n    private _clearColor = new Color(1, 1, 1);\n    private _sizeChanged = false;\n\n    private _renderPassDescriptor: GPURenderPassDescriptor;\n\n    private _currentRenderTarget: RenderTarget = null;\n\n    constructor(parameters: WebGPURendererParameters = {}) {\n        this._parameters = parameters;\n\n        if (this._parameters.antialias === true) {\n            this._sampleCount = parameters.sampleCount === undefined ? 4 : parameters.sampleCount;\n        } else {\n            this._sampleCount = 1;\n        }\n    }\n\n    public init() {\n        if (!this._parameters.canvas) {\n            this._canvas = document.createElement(\"canvas\");\n            this._canvas.style.width = \"100%\";\n            this._canvas.style.height = \"100%\";\n        } else {\n            this._canvas = this._parameters.canvas;\n        }\n\n        this._device = Context.activeDevice;\n\n        this._context = this._canvas.getContext(\"webgpu\");\n        this._context.configure({\n            device: this._device,\n            format: this._presentationFormat,\n            alphaMode: this._alphaMode,\n        });\n\n        this._initGlobalData();\n\n        this._renderPassDescriptor = {\n            colorAttachments: [\n                {\n                    view: null,\n                    resolveTarget: undefined,\n                    clearValue: {\n                        r: this._clearColor.r,\n                        g: this._clearColor.g,\n                        b: this._clearColor.b,\n                        a: 1.0,\n                    },\n                    loadOp: \"clear\",\n                    storeOp: \"store\",\n                },\n            ],\n            depthStencilAttachment: {\n                view: null,\n                depthClearValue: 1.0,\n                depthLoadOp: \"clear\",\n                depthStoreOp: \"store\",\n            },\n        };\n    }\n\n    _initGlobalData() {\n        Context.activeDevice = this._device;\n    }\n\n    public setSize(width: number, height: number) {\n        this._size = {\n            width: width,\n            height: height,\n        };\n        this._canvas.width = width * this._pixelRatio;\n        this._canvas.height = height * this._pixelRatio;\n        this._setupColorBuffer();\n        this._setupDepthBuffer();\n        this._sizeChanged = true;\n    }\n\n    public render(scene: Scene, camera: Camera) {\n        if (!this._colorAttachmentView) {\n            this.setSize(this._canvas.clientWidth, this._canvas.clientHeight);\n        }\n\n        if (this._sizeChanged) {\n            if (PerspectiveCamera.Is(camera)) {\n                const perspectiveCamera = camera as PerspectiveCamera;\n                perspectiveCamera.aspect = this._canvas.width / this._canvas.height;\n                perspectiveCamera.updateProjectionMatrix();\n            }\n\n            this._sizeChanged = false;\n        }\n        camera.update();\n        const sceneUpdated = scene.update(camera);\n\n        if (this._currentRenderTarget) {\n            this._currentRenderTarget.depthTexture;\n            // const descriptor = {\n            //     colorAttachments: [\n            //         {\n            //             view: null,\n            //             resolveTarget: undefined,\n            //             clearValue: { r: this._clearColor.r, g: this._clearColor.g, b: this._clearColor.b, a: 1.0 },\n            //             loadOp: \"clear\",\n            //             storeOp: \"store\",\n            //         },\n            //     ],\n            //     depthStencilAttachment: {\n            //         depthClearValue: 1.0,\n            //         depthLoadOp: 'clear',\n            //         depthStoreOp: 'store',\n            //     },\n            // }\n        }\n\n        const view = this.sampleCount > 1 ? this._colorAttachmentView : this._context.getCurrentTexture().createView();\n        const resolveTarget = this.sampleCount > 1 ? this._context.getCurrentTexture().createView() : undefined;\n        (this._renderPassDescriptor.colorAttachments as Array<GPURenderPassColorAttachment>)[0].view = view;\n        (this._renderPassDescriptor.colorAttachments as Array<GPURenderPassColorAttachment>)[0].resolveTarget =\n            resolveTarget;\n        (this._renderPassDescriptor.depthStencilAttachment as GPURenderPassDepthStencilAttachment).view =\n            this._depthBuffer.createView();\n\n        const materialObjects = scene.renderableObjs;\n\n        const commandEncoder = this.device.createCommandEncoder();\n        const passEncoder = commandEncoder.beginRenderPass(this._renderPassDescriptor);\n\n        for (const [material, objects] of materialObjects) {\n            if (sceneUpdated) {\n                material.pipeline.needsCompile = true;\n            }\n            this._renderSamePipeline(passEncoder, material, objects, scene);\n        }\n\n        passEncoder.end();\n\n        this.device.queue.submit([commandEncoder.finish()]);\n    }\n\n    public setRenderTarget(renderTarget: RenderTarget) {\n        this._currentRenderTarget = renderTarget;\n    }\n\n    private _renderSamePipeline(\n        passEncoder: GPURenderPassEncoder,\n        material: Material,\n        objects: Array<RenderableObject>,\n        scene: Scene\n    ) {\n        if (material.pipeline.needsCompile) material.pipeline.compilePipeline(this, scene);\n\n        passEncoder.setPipeline(material.pipeline.pipeline);\n\n        material.pipeline.createCommonBindGroups(scene);\n        material.pipeline.bindCommonUniform(passEncoder);\n\n        material.updateBinds();\n\n        for (let i = 0; i < objects.length; ++i) {\n            material.pipeline.createObjectBindGroup(objects[i]);\n            material.pipeline.bindObjectUnform(passEncoder, objects[i]);\n            this._renderObject(passEncoder, objects[i]);\n        }\n    }\n\n    private _renderObject(passEncoder: GPURenderPassEncoder, object: RenderableObject) {\n        object.update();\n\n        const geometry = object.geometry;\n        geometry.update();\n        geometry.setVertexBuffer(passEncoder, object.material.shaderOptions.attributeValues);\n        if (geometry.indices) {\n            passEncoder.setIndexBuffer(geometry.indices.buffer.buffer, GPUIndexFormat.Uint32);\n            passEncoder.drawIndexedIndirect(object.geometry.drawBuffer.buffer, 0);\n        } else {\n            passEncoder.drawIndirect(object.geometry.drawBuffer.buffer, 0);\n        }\n    }\n\n    private _setupColorBuffer() {\n        const device = this._device;\n\n        if (device) {\n            if (this._colorBuffer) this._colorBuffer.destroy();\n\n            this._colorBuffer = this._device.createTexture({\n                size: {\n                    width: Math.floor(this._size.width * this._pixelRatio),\n                    height: Math.floor(this._size.height * this._pixelRatio),\n                    depthOrArrayLayers: 1,\n                },\n                sampleCount: this._sampleCount,\n                format: this._presentationFormat,\n                usage: GPUTextureUsage.RENDER_ATTACHMENT,\n            });\n            this._colorAttachmentView = this._colorBuffer.createView();\n        }\n    }\n\n    private _setupDepthBuffer() {\n        if (this._depthBuffer) this._depthBuffer.destroy();\n\n        this._depthBuffer = this.device.createTexture({\n            label: \"depthBuffer\",\n            size: {\n                width: Math.floor(this._size.width * this._pixelRatio),\n                height: Math.floor(this._size.height * this._pixelRatio),\n                depthOrArrayLayers: 1,\n            },\n            sampleCount: this._sampleCount,\n            format: GPUTextureFormat.Depth24Plus,\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n        });\n    }\n\n    get domElement() {\n        return this._canvas;\n    }\n\n    get device() {\n        return this._device;\n    }\n\n    get presentationFormat() {\n        return this._presentationFormat;\n    }\n\n    get sampleCount() {\n        return this._sampleCount;\n    }\n}\n","import { Scene } from \"../core/Scene\";\nimport { Material } from \"../materials/Material\";\nimport { Shader } from \"./Shader\";\nimport * as basic from \"./ShaderBasic\";\n\nexport class MeshBasicShader extends Shader {\n    constructor(material: Material) {\n        super(material);\n    }\n\n    protected override _createVertexShader(scene: Scene) {\n        const shaderOptions = this._material.shaderOptions;\n        const indexObj = { index: 1 } as basic.IndexObj;\n\n        const uvItem = shaderOptions.attributeValues.get(\"uv\");\n\n        this._vertexShaderCode = `\n            ${basic.bind_value(0, scene.bindValues.get(\"projectionMatrix\"))}\n            ${basic.bind_value(0, scene.bindValues.get(\"matrixWorldInverse\"))}\n\n            @group(2) @binding(0) var<uniform> modelMatrix : mat4x4<f32>;\n            \n            struct VertexOutput {\n                @builtin(position) Position : vec4<f32>,\n                ${basic.itemVary_value(uvItem, indexObj)}\n            }\n\n            @vertex\n            fn main(\n            @location(0) position : vec3<f32>,\n            ${basic.location_vert(uvItem)}\n            ) -> VertexOutput {\n                var output : VertexOutput;\n                ${basic.transform_vert()}\n                ${basic.uv_vert(uvItem)}\n                return output;\n            }\n        \n        `;\n    }\n\n    protected override _createFragmentShader(scene: Scene) {\n        const shaderOptions = this._material.shaderOptions;\n        const indexObj = { index: 1 } as basic.IndexObj;\n        const uvItem = shaderOptions.attributeValues.get(\"uv\");\n\n        this._fragmentShaderCode = `\n            ${basic.bind_value(1, shaderOptions.bindValues.get(\"parameters\"))}\n            ${basic.bind_value(1, shaderOptions.bindValues.get(\"color\"))}\n            ${basic.bind_value(1, shaderOptions.bindValues.get(\"colorSampler\"))}\n            ${basic.bind_value(1, shaderOptions.bindValues.get(\"colorTexture\"))}\n            \n\n\n            @fragment\n            fn main(\n                ${basic.itemVary_value(uvItem, indexObj)}\n            ) -> @location(0) vec4<f32> {\n                var baseColor:vec4<f32>;\n                ${basic.getColor_frag(\n                    shaderOptions.bindValues.get(\"colorTexture\"),\n                    shaderOptions.bindValues.get(\"colorSampler\"),\n                    shaderOptions.bindValues.get(\"color\")\n                )}\n                return baseColor;\n            }\n\n        `;\n    }\n}\n","import { Material } from \"../materials/Material\";\nimport { Scene } from \"../core/Scene\";\nimport { Shader } from \"./Shader\";\nimport * as basic from \"./ShaderBasic\";\n\nexport class MeshPhongShader extends Shader {\n    constructor(material: Material) {\n        super(material);\n    }\n\n    protected _createVertexShader(scene: Scene): void {\n        const shaderOptions = this._material.shaderOptions;\n        const indexObj = { index: 1 } as basic.IndexObj;\n        const uvItem = shaderOptions.attributeValues.get(\"uv\");\n        const normalItem = shaderOptions.attributeValues.get(\"normal\");\n\n        this._vertexShaderCode = `\n            ${basic.bind_value(0, scene.bindValues.get(\"projectionMatrix\"))}\n            ${basic.bind_value(0, scene.bindValues.get(\"matrixWorldInverse\"))}\n\n            @group(2) @binding(0) var<uniform> modelMatrix : mat4x4<f32>;\n\n            struct VertexOutput {\n                @builtin(position) Position : vec4<f32>,\n                ${basic.itemVary_value(uvItem, indexObj)}\n                ${basic.itemVary_value(normalItem, indexObj)}\n                ${basic.customVary_value(\"vViewPosition\", \"vec3<f32>\", indexObj)}\n            }\n\n            @vertex\n            fn main(\n            @location(0) position : vec3<f32>,\n            ${basic.location_vert(normalItem)}\n            ${basic.location_vert(uvItem)}\n            ) -> VertexOutput {\n                var output : VertexOutput;\n                ${basic.transform_vert()}\n                ${basic.uv_vert(uvItem)}\n                output.vViewPosition = - mvPosition.xyz;\n                output.normal = normal;\n                return output;\n            }\n        \n        `;\n    }\n\n    protected _createFragmentShader(scene: Scene): void {\n        const shaderOptions = this._material.shaderOptions;\n        const indexObj = { index: 1 } as basic.IndexObj;\n        const uvItem = shaderOptions.attributeValues.get(\"uv\");\n        const normalItem = shaderOptions.attributeValues.get(\"normal\");\n\n        this._fragmentShaderCode = `\n            const RECIPROCAL_PI = 0.3183098861837907;\n            struct IncidentLight {\n                color:vec3<f32>,\n                direction:vec3<f32>,\n                visible:bool,\n            };\n\n            struct ReflectedLight {\n                directDiffuse:vec3<f32>,\n                directSpecular:vec3<f32>,\n                indirectDiffuse:vec3<f32>,\n                indirectSpecular:vec3<f32>,\n            };\n\n            struct GeometricContext {\n                position:vec3<f32>,\n                normal:vec3<f32>,\n                viewDir:vec3<f32>,\n            };\n\n            struct BlinnPhongMaterial {\n\n                diffuseColor:vec3<f32>,\n                specularColor:vec3<f32>,\n                specularShininess:f32,\n                specularStrength:f32,\n            \n            };\n\n            struct DirectionalLight {\n                color:vec4<f32>,\n                direction:vec4<f32>,\n            };\n\n            fn saturate( a:f32 )->f32 {\n                return clamp( a, 0.0, 1.0 );\n            } \n\n            fn BRDF_Lambert( diffuseColor:vec3<f32> )->vec3<f32> {\n\n                return RECIPROCAL_PI * diffuseColor;\n            \n            }\n\n            fn F_Schlick( f0:vec3<f32>, f90:f32, dotVH:f32 )->vec3<f32> {\n\n                var fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n            \n                return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n            \n            } \n\n            fn G_BlinnPhong_Implicit()->f32 {\n\n                return 0.25;\n            \n            }\n\n            fn D_BlinnPhong( shininess:f32, dotNH:f32)->f32 {\n\n                return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n            \n            }\n\n            fn BRDF_BlinnPhong( lightDir:vec3<f32>, viewDir:vec3<f32>, normal:vec3<f32>, specularColor:vec3<f32>, shininess:f32 )->vec3<f32> {\n\n                var halfDir = normalize( lightDir + viewDir );\n            \n                var dotNH = saturate( dot( normal, halfDir ) );\n                var dotVH = saturate( dot( viewDir, halfDir ) );\n            \n                var F = F_Schlick( specularColor, 1.0, dotVH );\n            \n                var G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n            \n                var D = D_BlinnPhong( shininess, dotNH );\n            \n                return F * ( G * D );\n            \n            }\n\n            fn RE_Direct_BlinnPhong( \n                directLight:IncidentLight, \n                geometry:GeometricContext, \n                material:BlinnPhongMaterial, \n                reflectedLight: ptr<function,ReflectedLight>\n                ) {\n\n                var dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n                var irradiance = dotNL * directLight.color;\n\n                (*reflectedLight).directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n            \n                (*reflectedLight).directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n            }\n\n            ${basic.bind_value(0, scene.bindValues.get(\"directionalLights\"))}\n\n            ${basic.bind_value(1, shaderOptions.bindValues.get(\"parameters\"))}\n            ${basic.bind_value(1, shaderOptions.bindValues.get(\"color\"))}\n            ${basic.bind_value(1, shaderOptions.bindValues.get(\"colorSampler\"))}\n            ${basic.bind_value(1, shaderOptions.bindValues.get(\"colorTexture\"))}\n            ${basic.bind_value(1, shaderOptions.bindValues.get(\"specular\"))}\n            ${basic.bind_value(1, shaderOptions.bindValues.get(\"emissive\"))}\n            ${basic.bind_value(1, shaderOptions.bindValues.get(\"shininess\"))}\n\n            @fragment\n            fn main(\n                ${basic.itemVary_value(uvItem, indexObj)}\n                ${basic.itemVary_value(normalItem, indexObj)}\n                ${basic.customVary_value(\"vViewPosition\", \"vec3<f32>\", indexObj)}\n            ) -> @location(0) vec4<f32> {\n                var baseColor:vec4<f32>;\n                ${basic.getColor_frag(\n                    shaderOptions.bindValues.get(\"colorTexture\"),\n                    shaderOptions.bindValues.get(\"colorSampler\"),\n                    shaderOptions.bindValues.get(\"color\")\n                )}\n\n                var diffuse = baseColor.xyz;\n                // var emissive = vec3<f32>(0.0,0.0,0.0);\n                // var specular = vec3<f32>(0.043,0.043,0.043);\n                // var shininess = 30.;\n                var opacity = 1.;\n                var specularStrength = 1.;\n\n                var diffuseColor = vec4<f32>( diffuse, opacity );\n                var reflectedLight:ReflectedLight;\n                reflectedLight.directDiffuse = vec3<f32>( 0.0 );\n                reflectedLight.directSpecular = vec3<f32>( 0.0 );\n                reflectedLight.indirectDiffuse = vec3<f32>( 0.0 );\n                reflectedLight.indirectSpecular = vec3<f32>( 0.0 );\n\n                var totalEmissiveRadiance = emissive;\n\n                var material:BlinnPhongMaterial;\n                material.diffuseColor = diffuse;\n                material.specularColor = specular;\n                material.specularShininess = shininess;\n                material.specularStrength = specularStrength;\n\n                var geometry:GeometricContext;\n\n                geometry.position = - vViewPosition;\n                geometry.normal = normal;\n                //geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n                geometry.viewDir = normalize( vViewPosition );\n\n                ${\n                    scene.directionalLights.size > 0\n                        ? `\n                    for(var i = 0u;i < ${scene.directionalLights.size}u;i++){\n                        var directionalLight = directionalLights[i];\n        \n                        var directLight:IncidentLight;\n                        directLight.color = directionalLight.color.xyz;\n                        directLight.direction = directionalLight.direction.xyz;\n                        //directLight.direction = vec3<f32>(0.,1.,0.);\n                        directLight.visible = true;\n        \n                        RE_Direct_BlinnPhong( directLight, geometry, material, &reflectedLight );\n                    }\n                \n                `\n                        : ``\n                }\n                //var directionalLight:DirectionalLight;\n                \n\n                // directionalLight.direction = vec3<f32>(0.,1.,1.);\n                // directionalLight.color = vec3<f32>(1.,1.,1.);\n\n                // var directLight:IncidentLight;\n                // directLight.color = directionalLight.color;\n                // directLight.direction = directionalLight.direction;\n                // directLight.visible = true;\n\n                // //getDirectionalLightInfo( directionalLight, geometry, directLight );\n\n                // RE_Direct_BlinnPhong( directLight, geometry, material, &reflectedLight );\n\n                var outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n                var finalColor = vec4( outgoingLight, diffuseColor.a );\n\n                return finalColor;\n            }\n        `;\n    }\n}\n","import { Material } from \"../materials/Material\";\nimport { Scene } from \"../core/Scene\";\n\nexport abstract class Shader {\n    protected _vertexShaderCode: string;\n    protected _fragmentShaderCode: string;\n    protected _material: Material;\n\n    constructor(material: Material) {\n        this._material = material;\n    }\n\n    public recreate(scene: Scene) {\n        this._createVertexShader(scene);\n        this._createFragmentShader(scene);\n    }\n\n    protected abstract _createVertexShader(scene: Scene): void;\n\n    protected abstract _createFragmentShader(scene: Scene): void;\n\n    public get vertexShaderCode() {\n        return this._vertexShaderCode;\n    }\n\n    public get fragmentShaderCode() {\n        return this._fragmentShaderCode;\n    }\n}\n","import { BindShaderItem, BindType, ShaderItem } from \"../core/Defines\";\n\nexport interface IndexObj {\n    index: number;\n}\n\nexport function location_vert(item: ShaderItem) {\n    if (item) return `@location(${item.index}) ${item.name} : ${item.shaderItemType},`;\n    return \"\";\n}\n\nexport function itemVary_value(item: ShaderItem, index: IndexObj) {\n    if (item) {\n        return `@location(${index.index++}) ${item.name} : ${item.shaderItemType},`;\n    }\n\n    return \"\";\n}\n\nexport function customVary_value(name: string, itemType: string, indexObj: IndexObj) {\n    return `@location(${indexObj.index++}) ${name} : ${itemType},`;\n}\n\nexport function transform_vert() {\n    return `\n            var mvPosition = matrixWorldInverse * modelMatrix * vec4<f32>(position, 1.0);\n            output.Position = projectionMatrix * mvPosition;\n            `;\n}\n\nexport function uv_vert(item: ShaderItem) {\n    if (item) return `output.uv = uv;`;\n    return \"\";\n}\n\nexport function bind_value(groupIndex: number, item: BindShaderItem) {\n    if (item)\n        return `@group(${groupIndex}) @binding(${item.index}) var${\n            item.bindType === BindType.buffer ? \"<uniform>\" : \"\"\n        } ${item.name} : ${item.shaderItemType};`;\n    return \"\";\n}\n\nexport function getColor_frag(textureItem: ShaderItem, samplerItem: ShaderItem, colorItem: ShaderItem) {\n    if (textureItem) return `baseColor = textureSample(${textureItem.name}, ${samplerItem.name}, uv);`;\n    else {\n        if (colorItem.shaderItemType === \"vec3<f32>\") return `baseColor = vec4(${colorItem.name},1.0);`;\n        else return `baseColor = ${colorItem.name};`;\n    }\n}\n","import * as MathUtils from \"../math/MathUtils\";\n\nexport class Source {\n    public uuid = MathUtils.generateUUID();\n    public data: any;\n\n    public version = 0;\n    constructor(data: any = null) {\n        this.data = data;\n\n        this.version = 0;\n    }\n\n    set needsUpdate(value: boolean) {\n        if (value === true) this.version++;\n    }\n}\n","import * as MathUtils from \"../math/MathUtils\";\nimport { Vector2 } from \"../math/Vector2\";\nimport { Matrix3 } from \"../math/Matrix3\";\nimport * as Constants from \"../Constants\";\nimport { Source } from \"./Source\";\nimport {\n    GPUAddressMode,\n    GPUFilterMode,\n    GPUMipmapFilterMode,\n    GPUTextureFormat,\n    MagnificationTextureFilter,\n    Mapping,\n    MinificationTextureFilter,\n    TextureDataType,\n    Wrapping,\n} from \"../Constants\";\nimport { BindTexture } from \"../core/binds/BindTexture\";\nimport { BindSampler } from \"../core/binds/BindSampler\";\n\nconst t_nullCanvas = document.createElement(\"canvas\") as HTMLCanvasElement;\nt_nullCanvas.width = 1;\nt_nullCanvas.height = 1;\nconst t_ctx = t_nullCanvas.getContext(\"2d\");\nt_ctx.fillStyle = \"#ffffff\";\nt_ctx.fillRect(0, 0, t_nullCanvas.width, t_nullCanvas.height);\n\nconst t_nullImage = document.createElement(\"img\") as HTMLImageElement;\nt_nullImage.width = 1;\nt_nullImage.height = 1;\nt_nullImage.src = t_nullCanvas.toDataURL();\nexport class Texture {\n    static DEFAULT_IMAGE: HTMLImageElement = t_nullImage;\n    static DEFAULT_MAPPING: Mapping = Constants.UVMapping;\n    static DEFAULT_ANISOTROPY = 1;\n\n    public uuid = MathUtils.generateUUID();\n\n    public name = \"\";\n\n    public source: Source;\n    public mipmapSize: number;\n\n    public mapping: Mapping;\n    public channel = 0;\n\n    public wrapU: GPUAddressMode;\n    public wrapV: GPUAddressMode;\n    public wrapW: GPUAddressMode;\n\n    public magFilter: GPUFilterMode;\n    public minFilter: GPUFilterMode;\n\n    public mipmapFilter: GPUMipmapFilterMode;\n\n    public anisotropy: number;\n\n    public format: GPUTextureFormat;\n    public type: TextureDataType;\n\n    public offset = new Vector2(0, 0);\n    public repeat = new Vector2(1, 1);\n    public center = new Vector2(0, 0);\n    public rotation = 0;\n\n    public matrixAutoUpdate = true;\n    public matrix = new Matrix3();\n\n    public generateMipmaps = true;\n    public premultiplyAlpha = false;\n    public flipY = true;\n    public unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n    public colorSpace: string;\n\n    public version = 0;\n\n    public isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not\n    public needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)\n\n    public internalFormat: any = null;\n\n    private _bind: BindTexture;\n    private _sampler: BindSampler;\n\n    constructor(\n        image = Texture.DEFAULT_IMAGE,\n        mapping = Texture.DEFAULT_MAPPING,\n        wrapU: GPUAddressMode = GPUAddressMode.MirrorRepeat,\n        wrapV: GPUAddressMode = GPUAddressMode.MirrorRepeat,\n        wrapW: GPUAddressMode = GPUAddressMode.MirrorRepeat,\n        magFilter: GPUFilterMode = GPUFilterMode.Linear,\n        minFilter: GPUFilterMode = GPUFilterMode.Linear,\n        mipmapFilter: GPUMipmapFilterMode = GPUMipmapFilterMode.Linear,\n        format: GPUTextureFormat = GPUTextureFormat.RGBA8Unorm,\n        type: TextureDataType = Constants.UnsignedByteType,\n        anisotropy = Texture.DEFAULT_ANISOTROPY,\n        colorSpace = Constants.NoColorSpace\n    ) {\n        this.uuid = MathUtils.generateUUID();\n\n        this.name = \"\";\n\n        this.source = new Source(image);\n        this.mipmapSize = 1;\n\n        this.mapping = mapping;\n        this.channel = 0;\n\n        this.wrapU = wrapU;\n        this.wrapV = wrapV;\n        this.wrapW = wrapW;\n\n        this.magFilter = magFilter;\n        this.minFilter = minFilter;\n        this.mipmapFilter = mipmapFilter;\n\n        this.anisotropy = anisotropy;\n\n        this.format = format;\n        this.type = type;\n\n        this.colorSpace = colorSpace;\n    }\n\n    get image() {\n        return this.source.data;\n    }\n\n    set image(value: any) {\n        this.source.data = value;\n    }\n\n    updateMatrix() {\n        this.matrix.setUvTransform(\n            this.offset.x,\n            this.offset.y,\n            this.repeat.x,\n            this.repeat.y,\n            this.rotation,\n            this.center.x,\n            this.center.y\n        );\n    }\n\n    clone() {\n        return new Texture().copy(this);\n    }\n\n    copy(source: Texture) {\n        this.name = source.name;\n\n        this.source = source.source;\n        this.mipmapSize = source.mipmapSize;\n\n        this.mapping = source.mapping;\n        this.channel = source.channel;\n\n        this.wrapU = source.wrapU;\n        this.wrapV = source.wrapV;\n\n        this.magFilter = source.magFilter;\n        this.minFilter = source.minFilter;\n\n        this.anisotropy = source.anisotropy;\n\n        this.format = source.format;\n        this.type = source.type;\n\n        this.offset.copy(source.offset);\n        this.repeat.copy(source.repeat);\n        this.center.copy(source.center);\n        this.rotation = source.rotation;\n\n        this.matrixAutoUpdate = source.matrixAutoUpdate;\n        this.matrix.copy(source.matrix);\n\n        this.generateMipmaps = source.generateMipmaps;\n        this.premultiplyAlpha = source.premultiplyAlpha;\n        this.flipY = source.flipY;\n        this.unpackAlignment = source.unpackAlignment;\n        this.colorSpace = source.colorSpace;\n\n        this.needsUpdate = true;\n\n        return this;\n    }\n\n    transformUv(uv: Vector2) {\n        if (this.mapping !== Constants.UVMapping) return uv;\n\n        uv.applyMatrix3(this.matrix);\n\n        if (uv.x < 0 || uv.x > 1) {\n            switch (this.wrapU) {\n                case GPUAddressMode.Repeat:\n                    uv.x = uv.x - Math.floor(uv.x);\n                    break;\n\n                case GPUAddressMode.ClampToEdge:\n                    uv.x = uv.x < 0 ? 0 : 1;\n                    break;\n\n                case GPUAddressMode.MirrorRepeat:\n                    if (Math.abs(Math.floor(uv.x) % 2) === 1) {\n                        uv.x = Math.ceil(uv.x) - uv.x;\n                    } else {\n                        uv.x = uv.x - Math.floor(uv.x);\n                    }\n\n                    break;\n            }\n        }\n\n        if (uv.y < 0 || uv.y > 1) {\n            switch (this.wrapV) {\n                case GPUAddressMode.Repeat:\n                    uv.y = uv.y - Math.floor(uv.y);\n                    break;\n\n                case GPUAddressMode.ClampToEdge:\n                    uv.y = uv.y < 0 ? 0 : 1;\n                    break;\n\n                case GPUAddressMode.MirrorRepeat:\n                    if (Math.abs(Math.floor(uv.y) % 2) === 1) {\n                        uv.y = Math.ceil(uv.y) - uv.y;\n                    } else {\n                        uv.y = uv.y - Math.floor(uv.y);\n                    }\n\n                    break;\n            }\n        }\n\n        if (this.flipY) {\n            uv.y = 1 - uv.y;\n        }\n\n        return uv;\n    }\n\n    set needsUpdate(value: boolean) {\n        if (value === true) {\n            if (this._bind) this._bind.update();\n\n            this.version++;\n            this.source.needsUpdate = true;\n        }\n    }\n\n    get bind() {\n        if (!this._bind) {\n            this._bind = new BindTexture(this, this.mipmapSize);\n        }\n        return this._bind;\n    }\n\n    get sampler() {\n        if (!this._sampler) this._sampler = new BindSampler(this);\n        return this._sampler;\n    }\n}\n\nexport const NullTexture = new Texture();\n","import { GPUSamplerBindingType, GPUTextureFormat } from \"../Constants\";\nimport { Context } from \"../core/ResourceManagers\";\nimport { Texture } from \"./Texture\";\n\nexport class TextureMipmapGenerator {\n    private static mipmapShader = `\n    var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n      struct VertexOutput {\n        @builtin(position) position : vec4<f32>;\n        @location(0) texCoord : vec2<f32>;\n      };\n      @vertex\n      fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n        var output : VertexOutput;\n        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n        return output;\n      }\n      @binding(0) @group(0) var imgSampler : sampler;\n      @binding(1) @group(0) var img : texture_2d<f32>;\n      @fragment\n      fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n        var outColor: vec4<f32> = textureSample(img, imgSampler, texCoord);\n        return outColor ;\n      }`;\n    private static pipelineCache: { [key: string]: GPURenderPipeline } = {};\n    private static pipeline: any;\n\n    public static getMipmapPipeline(texture: Texture) {\n        const format = texture.format;\n        const device = Context.activeDevice;\n        let pipeline: GPURenderPipeline = TextureMipmapGenerator.pipelineCache[format];\n        let mipmapShaderModule: GPUShaderModule;\n        if (!pipeline) {\n            mipmapShaderModule = device.createShaderModule({\n                code: TextureMipmapGenerator.mipmapShader,\n            });\n\n            const textureLayout = device.createBindGroupLayout({\n                entries: [\n                    {\n                        binding: 0,\n                        //TODO : After adding a shadow reflection, it is necessary to know that the vertex is used | the segment is used\n                        visibility: GPUShaderStage.FRAGMENT,\n                        // use GPUSamplerBindingLayout = { type:`filtering`} error\n                        sampler: {\n                            type: GPUSamplerBindingType.Filtering,\n                        },\n                    },\n                    {\n                        binding: 1,\n                        //TODO : After adding a shadow reflection, it is necessary to know that the vertex is used | the segment is used\n                        visibility: GPUShaderStage.FRAGMENT,\n                        // use GPUTextureBindingLayout = { sampleType:`float`} error\n                        texture: {},\n                    },\n                ],\n            });\n\n            const layouts = device.createPipelineLayout({\n                bindGroupLayouts: [textureLayout],\n            });\n\n            pipeline = device.createRenderPipeline({\n                layout: layouts,\n                vertex: {\n                    module: mipmapShaderModule,\n                    entryPoint: \"vertexMain\",\n                },\n                fragment: {\n                    module: mipmapShaderModule,\n                    entryPoint: \"fragmentMain\",\n                    targets: [{ format: Context.textureFormat }],\n                },\n            });\n            TextureMipmapGenerator.pipelineCache[format] = pipeline;\n        }\n        return pipeline;\n    }\n\n    // TextureDescriptor should be the descriptor that the texture was created with.\n    // This version only works for basic 2D textures.\n    public static webGPUGenerateMipmap(texture: Texture) {\n        const device = Context.activeDevice;\n        //const textureDescriptor = texture.textureDescriptor;\n\n        if (!TextureMipmapGenerator.pipeline) {\n            // Create a simple shader that renders a fullscreen textured quad.\n            const mipmapShaderModule = device.createShaderModule({\n                code: `\n        var<private> pos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(\n          vec2<f32>(-1.0, 1.0), vec2<f32>(1.0, 1.0),\n          vec2<f32>(-1.0, -1.0), vec2<f32>(1.0, -1.0));\n\n        struct VertexOutput {\n          @builtin(position) position : vec4<f32>,\n          @location(0) texCoord : vec2<f32>\n        };\n\n        @vertex\n        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n          var output : VertexOutput;\n          output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n          output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n          return output;\n        }\n\n        @binding(0) @group(0) var imgSampler : sampler;\n        @binding(1) @group(0) var img : texture_2d<f32>;\n\n        @fragment\n        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n          var outColor: vec4<f32> = textureSample(img, imgSampler, texCoord);\n          return outColor;\n        }\n      `,\n            });\n\n            TextureMipmapGenerator.pipeline = device.createRenderPipeline({\n                layout: `auto`,\n                vertex: {\n                    module: mipmapShaderModule,\n                    entryPoint: \"vertexMain\",\n                },\n                fragment: {\n                    module: mipmapShaderModule,\n                    entryPoint: \"fragmentMain\",\n                    targets: [\n                        {\n                            format: texture.format, // Make sure to use the same format as the texture\n                        },\n                    ],\n                },\n                primitive: {\n                    topology: \"triangle-strip\",\n                    stripIndexFormat: \"uint32\",\n                },\n            });\n        }\n\n        // We'll ALWAYS be rendering minified here, so that's the only filter mode we need to set.\n        let sampler: GPUSampler;\n        if (texture.format == GPUTextureFormat.RGBA16Float) {\n            sampler = device.createSampler({\n                minFilter: `nearest`,\n                magFilter: `linear`,\n            });\n        } else {\n            sampler = device.createSampler({\n                minFilter: `linear`,\n                magFilter: `linear`,\n            });\n        }\n\n        let srcView = texture.bind.gpuTexture.createView({\n            baseMipLevel: 0,\n            mipLevelCount: 1,\n        });\n\n        // Loop through each mip level and renders the previous level's contents into it.\n        const commandEncoder = Context.commandEncoder;\n        for (let i = 1; i < texture.mipmapSize; ++i) {\n            const dstView = texture.bind.gpuTexture.createView({\n                baseMipLevel: i, // Make sure we're getting the right mip level...\n                mipLevelCount: 1, // And only selecting one mip level\n            });\n\n            const passEncoder = commandEncoder.beginRenderPass({\n                colorAttachments: [\n                    {\n                        view: dstView, // Render pass uses the next mip level as it's render attachment.\n                        clearValue: [0, 0, 0, 0],\n                        loadOp: `clear`,\n                        storeOp: \"store\",\n                    },\n                ],\n            });\n\n            // Need a separate bind group for each level to ensurev\n            // we're only sampling from the previous level.\n            const bindGroup = device.createBindGroup({\n                layout: TextureMipmapGenerator.pipeline.getBindGroupLayout(0),\n                entries: [\n                    {\n                        binding: 0,\n                        resource: sampler,\n                    },\n                    {\n                        binding: 1,\n                        resource: srcView,\n                    },\n                ],\n            });\n\n            // Render\n            passEncoder.setPipeline(TextureMipmapGenerator.pipeline);\n            passEncoder.setBindGroup(0, bindGroup);\n            passEncoder.draw(4);\n            passEncoder.end();\n\n            // The source texture view for the next iteration of the loop is the\n            // destination view for this one.\n            srcView = dstView;\n        }\n        device.queue.submit([commandEncoder.finish()]);\n    }\n}\n","const _cache: any = {};\nexport class CommonUtils {\n    public static warnOnce(message: string) {\n        if (message in _cache) return;\n\n        _cache[message] = true;\n\n        console.warn(message);\n    }\n\n    public static isDefined(o: any) {\n        return o !== undefined && o !== null;\n    }\n\n    public static removeArrayItemByValue<T>(array: Array<T>, value: T) {\n        for (let i = 0; i < array.length; ++i) {\n            if (array[i] === value) {\n                array.splice(i, 1);\n                break;\n            }\n        }\n    }\n}\n","import { Matrix4 } from \"../math/Matrix4\";\nimport { Vector3 } from \"../math/Vector3\";\n\nexport const IdentifyMatrix4 = new Matrix4();\n\nexport const Vector0 = new Vector3();\nexport const Vector1 = new Vector3();\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Context } from \"./core/ResourceManagers\";\n\nexport * as GPUConstances from \"./Constants\";\n\nexport * as Environment from \"./core/Defines\";\n\nexport { WebGPURenderer } from \"./renderers/WebGPURenderer\";\n\nexport { BufferAttribute } from \"./core/BufferAttribute\";\nexport { BufferGeometry } from \"./core/BufferGeometry\";\n\nexport { BoxGeometry } from \"./geometries/BoxGeometry\";\nexport { PlaneGeometry } from \"./geometries/PlaneGeometry\";\nexport { SphereGeometry } from \"./geometries/SphereGeometry\";\n\nexport { MeshBasicMaterial } from \"./materials/MeshBasicMaterial\";\nexport { MeshPhongMaterial } from \"./materials/MeshPhongMaterial\";\n\nexport { Color } from \"./math/Color\";\nexport { Euler } from \"./math/Euler\";\nexport { Matrix3 } from \"./math/Matrix3\";\nexport { Matrix4 } from \"./math/Matrix4\";\nexport { Quaternion } from \"./math/Quaternion\";\nexport { Vector2 } from \"./math/Vector2\";\nexport { Vector3 } from \"./math/Vector3\";\n\nexport { Object3D } from \"./core/Object3D\";\nexport { Scene } from \"./core/Scene\";\n\nexport { Mesh } from \"./objects/Mesh\";\n\nexport { DirectionalLight } from \"./lights/DirectionalLight\";\n\nexport { PerspectiveCamera } from \"./cameras/PerspectiveCamera\";\nexport { OrthographicCamera } from \"./cameras/OrthographicCamera\";\n\nexport { OrbitControls } from \"./controls/OrbitControls\";\n\nexport { FileLoader } from \"./loaders/FileLoader\";\nexport { ImageLoader } from \"./loaders/ImageLoader\";\nexport { TextureLoader } from \"./loaders/TextureLoader\";\n\nexport * as ConstantsValues from \"./utils/TempValues\";\n\nexport async function Init(parameters: any = {}) {\n    const powerPreference = parameters.powerPreference ? parameters.powerPreference : \"high-performance\";\n    const adapter = await navigator.gpu.requestAdapter({\n        powerPreference,\n    });\n\n    Context.activeDevice = await adapter.requestDevice();\n}\n"],"names":[],"sourceRoot":""}