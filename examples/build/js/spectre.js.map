{"version":3,"file":"js/spectre.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;ACnVA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAUA;AAEA;AAVA;AAEA;AAEA;AAEA;AAMA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;ACxGA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAaA;AAEA;AAbA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;;;;;;;;;;;;;;;;;AC/HA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAYA;AAEA;AAZA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;;;;;;;AAOA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAGA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AAEA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;AC7NA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AA0EA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AAAA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAGA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACryBA;AAEA;AAYA;AACA;AACA;AAEA;AAdA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChGA;AAGA;AAEA;AAOA;AANA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAAA;AACA;AACA;AACA;AACA;AACA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzEA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAMA;AACA;AACA;AAEA;AACA;AACA;AAsCA;AA7BA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAOA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAGA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAvnBA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1BA;AAGA;AAEA;AAEA;AAaA;AATA;AACA;AAEA;AAEA;AAEA;AAGA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChPA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAQA;AACA;AAHA;AAIA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;ACzEA;AAMA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;;AAlCA;AAEA;AAoCA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;;AANA;;;;;;;;;;;;;;;;ACxDA;AAEA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AAEA;AAMA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7EA;AAKA;AAFA;AAGA;AACA;AAIA;AAEA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AAGA;AASA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;AC7JA;AACA;AACA;AAEA;AAOA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AAGA;AAUA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;AC7HA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAMA;AAEA;AANA;AAQA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;;;;;;;;;;;;;;;;ACvEA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9BA;AACA;AAGA;AAEA;AAIA;AAEA;AACA;AAEA;AAEA;AAEA;AAKA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAAA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAGA;;;;;;;;;;;;;;;;;ACjSA;AACA;AAGA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;;;;;;;;;;;;;;;;ACvFA;AAEA;AASA;AANA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAIA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;;;;;;;;;;;;;;;;ACpEA;AAYA;AACA;AACA;AAbA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;;;;;;;;;;;;;;;;;;AC1IA;AACA;AACA;AAGA;AAIA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAGA;;;;;;;;;;;;;;;;;;;;;;;AC1CA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAoBA;AAjBA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAGA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnRA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAMA;AACA;AALA;AACA;AACA;AAKA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1DA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AAMA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAMA;AAEA;AAGA;AAEA;AAEA;AAMA;AAEA;AAEA;AACA;AACA;AAEA;AAIA;AAEA;AAEA;AAMA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAMA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAIA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AArdA;AAwdA;AAEA;;;;;;;;;;;;;;;;;;;;;ACzoBA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;;;;;;;;;;AAUA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;;;;;;;;;;;;;;;;;;ACxIA;AACA;AACA;AAGA;AACA;AAEA;AASA;AALA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAGA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;;AA3OA;AA+OA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvPA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAAA;AACA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AACA;AAAA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;ACrRA;AAQA;AAPA;AAEA;AACA;AACA;AAEA;AAOA;AAEA;AAEA;AAEA;AAEA;AAKA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;AAQA;AAEA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAQA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAIA;AAEA;AAEA;AAEA;AAYA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAMA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAQA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAQA;AAEA;AAEA;AAEA;AAQA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;;;;;;;;;;;;;;;;ACzXA;AAGA;AAQA;AAPA;AACA;AACA;AACA;AACA;AACA;AASA;AAEA;AAEA;AAEA;AAEA;AAMA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;AASA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AASA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAOA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAKA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAIA;AAEA;AAEA;AAEA;AACA;AAYA;AAEA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AASA;AAEA;AAEA;AAEA;AAEA;AASA;AAEA;AAEA;AAEA;AAEA;AASA;AAEA;AAEA;AAEA;AAEA;AASA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AASA;AAEA;AAEA;AAEA;AASA;AAEA;AAEA;AAEA;AASA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;ACh2BA;AAIA;AAOA;AALA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAKA;AAKA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAIA;AACA;AAEA;AAGA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAQA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAAA;AACA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAOA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;;;;;;;;;;;;;;;;AC7lBA;;;;;AAKA;AAEA;AAGA;AAIA;AAHA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpEA;AAGA;AAKA;AAHA;AACA;AAIA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;;;;;;;;;;;;;;;;;AC/dA;AAGA;AAGA;AAMA;AAJA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AAAA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;;;;;;;;;;;;;;;;ACxtBA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AAEA;AAEA;AAgBA;AAsBA;AAhBA;AAEA;AAIA;AAEA;AACA;AACA;AAIA;AAGA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChQA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;;;;AAIA;;;;;;AAMA;;;AAGA;AACA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;;;AAGA;;;;AAIA;AACA;AACA;;;;;;;;;;;;;;;;;AC7DA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;AAIA;AACA;AACA;;;;;;AAMA;AACA;;;AAGA;AACA;;;;;;AAMA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsGA;AACA;AACA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoDA;AACA;AACA;;;;;;;;;;;;;;;ACxNA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC3BA;AAMA;AACA;;;;;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;AC7DA;AAEA;AAMA;AAJA;AAGA;AAGA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA8CA;AAzCA;AAEA;AAGA;AAGA;AAaA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAIA;AAEA;AACA;AAQA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;;AArOA;AACA;AACA;AAuOA;;;;;;;;;;;;;;;;;;AC3PA;AACA;AAEA;AAEA;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA","sources":["webpack://spectrejs/./src/Constants.ts","webpack://spectrejs/./src/cameras/Camera.ts","webpack://spectrejs/./src/cameras/OrthographicCamera.ts","webpack://spectrejs/./src/cameras/PerspectiveCamera.ts","webpack://spectrejs/./src/controls/OrbitControls.ts","webpack://spectrejs/./src/core/BufferAttribute.ts","webpack://spectrejs/./src/core/BufferGeometry.ts","webpack://spectrejs/./src/core/Defines.ts","webpack://spectrejs/./src/core/GPUBufferWrapper.ts","webpack://spectrejs/./src/core/Object3D.ts","webpack://spectrejs/./src/core/Pipeline.ts","webpack://spectrejs/./src/core/RenderableObject.ts","webpack://spectrejs/./src/core/ResourceManagers.ts","webpack://spectrejs/./src/core/Scene.ts","webpack://spectrejs/./src/core/binds/BindBuffer.ts","webpack://spectrejs/./src/core/binds/BindSampler.ts","webpack://spectrejs/./src/core/binds/BindTexture.ts","webpack://spectrejs/./src/core/binds/BindValue.ts","webpack://spectrejs/./src/geometries/BoxGeometry.ts","webpack://spectrejs/./src/geometries/PlaneGeometry.ts","webpack://spectrejs/./src/geometries/SphereGeometry.ts","webpack://spectrejs/./src/lights/DirectionalLight.ts","webpack://spectrejs/./src/lights/Light.ts","webpack://spectrejs/./src/loaders/FileLoader.ts","webpack://spectrejs/./src/loaders/ImageLoader.ts","webpack://spectrejs/./src/loaders/Loader.ts","webpack://spectrejs/./src/loaders/LoadingManager.ts","webpack://spectrejs/./src/loaders/TextureLoader.ts","webpack://spectrejs/./src/materials/Material.ts","webpack://spectrejs/./src/materials/MeshBasicMaterial.ts","webpack://spectrejs/./src/materials/MeshPhongMaterial.ts","webpack://spectrejs/./src/math/Color.ts","webpack://spectrejs/./src/math/ColorManagement.ts","webpack://spectrejs/./src/math/Euler.ts","webpack://spectrejs/./src/math/MathUtils.ts","webpack://spectrejs/./src/math/Matrix3.ts","webpack://spectrejs/./src/math/Matrix4.ts","webpack://spectrejs/./src/math/Quaternion.ts","webpack://spectrejs/./src/math/Spherical.ts","webpack://spectrejs/./src/math/Vector2.ts","webpack://spectrejs/./src/math/Vector3.ts","webpack://spectrejs/./src/objects/Mesh.ts","webpack://spectrejs/./src/renderers/WebGPURenderer.ts","webpack://spectrejs/./src/shaders/MeshBasicShader.ts","webpack://spectrejs/./src/shaders/MeshPhongShader.ts","webpack://spectrejs/./src/shaders/Shader.ts","webpack://spectrejs/./src/shaders/ShaderBasic.ts","webpack://spectrejs/./src/textures/Source.ts","webpack://spectrejs/./src/textures/Texture.ts","webpack://spectrejs/./src/utils/TMPValues.ts","webpack://spectrejs/webpack/bootstrap","webpack://spectrejs/webpack/runtime/define property getters","webpack://spectrejs/webpack/runtime/hasOwnProperty shorthand","webpack://spectrejs/webpack/runtime/make namespace object","webpack://spectrejs/./src/spectre.ts"],"sourcesContent":["export type NumberArrayType = Float32Array | Int32Array | Int8Array | Uint32Array | Uint16Array | Uint8Array;\r\n\r\nexport const GPUPrimitiveTopology = {\r\n\tPointList: 'point-list' as GPUPrimitiveTopology,\r\n\tLineList: 'line-list' as GPUPrimitiveTopology,\r\n\tLineStrip: 'line-strip' as GPUPrimitiveTopology,\r\n\tTriangleList: 'triangle-list' as GPUPrimitiveTopology,\r\n\tTriangleStrip: 'triangle-strip' as GPUPrimitiveTopology,\r\n};\r\n\r\nexport const GPUCompareFunction = {\r\n\tNever: 'never' as GPUCompareFunction,\r\n\tLess: 'less' as GPUCompareFunction,\r\n\tEqual: 'equal' as GPUCompareFunction,\r\n\tLessEqual: 'less-equal' as GPUCompareFunction,\r\n\tGreater: 'greater' as GPUCompareFunction,\r\n\tNotEqual: 'not-equal' as GPUCompareFunction,\r\n\tGreaterEqual: 'greater-equal' as GPUCompareFunction,\r\n\tAlways: 'always' as GPUCompareFunction\r\n};\r\n\r\nexport const GPUStoreOp = {\r\n\tStore: 'store',\r\n\tDiscard: 'discard'\r\n};\r\n\r\nexport const GPULoadOp = {\r\n\tLoad: 'load',\r\n\tClear: 'clear'\r\n};\r\n\r\nexport const GPUFrontFace = {\r\n\tCCW: 'ccw',\r\n\tCW: 'cw'\r\n};\r\n\r\nexport const GPUCullMode = {\r\n\tNone: 'none' as GPUCullMode,\r\n\tFront: 'front' as GPUCullMode,\r\n\tBack: 'back' as GPUCullMode\r\n};\r\n\r\nexport const GPUIndexFormat = {\r\n\tUint16: 'uint16' as GPUIndexFormat,\r\n\tUint32: 'uint32' as GPUIndexFormat\r\n};\r\n\r\nexport const GPUVertexFormat = {\r\n\tUint8x2: 'uint8x2' as GPUVertexFormat,\r\n\tUint8x4: 'uint8x4' as GPUVertexFormat,\r\n\tSint8x2: 'sint8x2' as GPUVertexFormat,\r\n\tSint8x4: 'sint8x4' as GPUVertexFormat,\r\n\tUnorm8x2: 'unorm8x2' as GPUVertexFormat,\r\n\tUnorm8x4: 'unorm8x4' as GPUVertexFormat,\r\n\tSnorm8x2: 'snorm8x2' as GPUVertexFormat,\r\n\tSnorm8x4: 'snorm8x4' as GPUVertexFormat,\r\n\tUint16x2: 'uint16x2' as GPUVertexFormat,\r\n\tUint16x4: 'uint16x4' as GPUVertexFormat,\r\n\tSint16x2: 'sint16x2' as GPUVertexFormat,\r\n\tSint16x4: 'sint16x4' as GPUVertexFormat,\r\n\tUnorm16x2: 'unorm16x2' as GPUVertexFormat,\r\n\tUnorm16x4: 'unorm16x4' as GPUVertexFormat,\r\n\tSnorm16x2: 'snorm16x2' as GPUVertexFormat,\r\n\tSnorm16x4: 'snorm16x4' as GPUVertexFormat,\r\n\tFloat16x2: 'float16x2' as GPUVertexFormat,\r\n\tFloat16x4: 'float16x4' as GPUVertexFormat,\r\n\tFloat32: 'float32' as GPUVertexFormat,\r\n\tFloat32x2: 'float32x2' as GPUVertexFormat,\r\n\tFloat32x3: 'float32x3' as GPUVertexFormat,\r\n\tFloat32x4: 'float32x4' as GPUVertexFormat,\r\n\tUint32: 'uint32' as GPUVertexFormat,\r\n\tUint32x2: 'uint32x2' as GPUVertexFormat,\r\n\tUint32x3: 'uint32x3' as GPUVertexFormat,\r\n\tUint32x4: 'uint32x4' as GPUVertexFormat,\r\n\tSint32: 'sint32' as GPUVertexFormat,\r\n\tSint32x2: 'sint32x2' as GPUVertexFormat,\r\n\tSint32x3: 'sint32x3' as GPUVertexFormat,\r\n\tSint32x4: 'sint32x4' as GPUVertexFormat\r\n};\r\n\r\nexport const GPUTextureFormat = {\r\n\r\n\t// 8-bit formats\r\n\r\n\tR8Unorm: 'r8unorm' as GPUTextureFormat,\r\n\tR8Snorm: 'r8snorm',\r\n\tR8Uint: 'r8uint',\r\n\tR8Sint: 'r8sint',\r\n\r\n\t// 16-bit formats\r\n\r\n\tR16Uint: 'r16uint' as GPUTextureFormat,\r\n\tR16Sint: 'r16sint' as GPUTextureFormat,\r\n\tR16Float: 'r16float' as GPUTextureFormat,\r\n\tRG8Unorm: 'rg8unorm' as GPUTextureFormat,\r\n\tRG8Snorm: 'rg8snorm' as GPUTextureFormat,\r\n\tRG8Uint: 'rg8uint' as GPUTextureFormat,\r\n\tRG8Sint: 'rg8sint' as GPUTextureFormat,\r\n\r\n\t// 32-bit formats\r\n\r\n\tR32Uint: 'r32uint' as GPUTextureFormat,\r\n\tR32Sint: 'r32sint' as GPUTextureFormat,\r\n\tR32Float: 'r32float' as GPUTextureFormat,\r\n\tRG16Uint: 'rg16uint' as GPUTextureFormat,\r\n\tRG16Sint: 'rg16sint' as GPUTextureFormat,\r\n\tRG16Float: 'rg16float' as GPUTextureFormat,\r\n\tRGBA8Unorm: 'rgba8unorm' as GPUTextureFormat,\r\n\tRGBA8UnormSRGB: 'rgba8unorm-srgb' as GPUTextureFormat,\r\n\tRGBA8Snorm: 'rgba8snorm' as GPUTextureFormat,\r\n\tRGBA8Uint: 'rgba8uint' as GPUTextureFormat,\r\n\tRGBA8Sint: 'rgba8sint' as GPUTextureFormat,\r\n\tBGRA8Unorm: 'bgra8unorm' as GPUTextureFormat,\r\n\tBGRA8UnormSRGB: 'bgra8unorm-srgb' as GPUTextureFormat,\r\n\t// Packed 32-bit formats\r\n\tRGB9E5UFloat: 'rgb9e5ufloat' as GPUTextureFormat,\r\n\tRGB10A2Unorm: 'rgb10a2unorm' as GPUTextureFormat,\r\n\tRG11B10uFloat: 'rgb10a2unorm' as GPUTextureFormat,\r\n\r\n\t// 64-bit formats\r\n\r\n\tRG32Uint: 'rg32uint' as GPUTextureFormat,\r\n\tRG32Sint: 'rg32sint' as GPUTextureFormat,\r\n\tRG32Float: 'rg32float' as GPUTextureFormat,\r\n\tRGBA16Uint: 'rgba16uint' as GPUTextureFormat,\r\n\tRGBA16Sint: 'rgba16sint' as GPUTextureFormat,\r\n\tRGBA16Float: 'rgba16float' as GPUTextureFormat,\r\n\r\n\t// 128-bit formats\r\n\r\n\tRGBA32Uint: 'rgba32uint' as GPUTextureFormat,\r\n\tRGBA32Sint: 'rgba32sint' as GPUTextureFormat,\r\n\tRGBA32Float: 'rgba32float' as GPUTextureFormat,\r\n\r\n\t// Depth and stencil formats\r\n\r\n\tStencil8: 'stencil8' as GPUTextureFormat,\r\n\tDepth16Unorm: 'depth16unorm' as GPUTextureFormat,\r\n\tDepth24Plus: 'depth24plus' as GPUTextureFormat,\r\n\tDepth24PlusStencil8: 'depth24plus-stencil8' as GPUTextureFormat,\r\n\tDepth32Float: 'depth32float' as GPUTextureFormat,\r\n\r\n\t// BC compressed formats usable if 'texture-compression-bc' is both\r\n\t// supported by the device/user agent and enabled in requestDevice.\r\n\r\n\tBC1RGBAUnorm: 'bc1-rgba-unorm' as GPUTextureFormat,\r\n\tBC1RGBAUnormSRGB: 'bc1-rgba-unorm-srgb' as GPUTextureFormat,\r\n\tBC2RGBAUnorm: 'bc2-rgba-unorm' as GPUTextureFormat,\r\n\tBC2RGBAUnormSRGB: 'bc2-rgba-unorm-srgb' as GPUTextureFormat,\r\n\tBC3RGBAUnorm: 'bc3-rgba-unorm' as GPUTextureFormat,\r\n\tBC3RGBAUnormSRGB: 'bc3-rgba-unorm-srgb' as GPUTextureFormat,\r\n\tBC4RUnorm: 'bc4-r-unorm' as GPUTextureFormat,\r\n\tBC4RSNorm: 'bc4-r-snorm' as GPUTextureFormat,\r\n\tBC5RGUnorm: 'bc5-rg-unorm' as GPUTextureFormat,\r\n\tBC5RGSnorm: 'bc5-rg-snorm' as GPUTextureFormat,\r\n\tBC6HRGBUFloat: 'bc6h-rgb-ufloat' as GPUTextureFormat,\r\n\tBC6HRGBFloat: 'bc6h-rgb-float' as GPUTextureFormat,\r\n\tBC7RGBAUnorm: 'bc7-rgba-unorm' as GPUTextureFormat,\r\n\tBC7RGBAUnormSRGB: 'bc7-rgba-srgb' as GPUTextureFormat,\r\n\r\n\t// 'depth24unorm-stencil8' extension\r\n\r\n\tDepth24UnormStencil8: 'depth24unorm-stencil8' as GPUTextureFormat,\r\n\r\n\t// 'depth32float-stencil8' extension\r\n\r\n\tDepth32FloatStencil8: 'depth32float-stencil8' as GPUTextureFormat,\r\n\r\n};\r\n\r\nexport const GPUAddressMode = {\r\n\tClampToEdge: 'clamp-to-edge',\r\n\tRepeat: 'repeat',\r\n\tMirrorRepeat: 'mirror-repeat'\r\n};\r\n\r\nexport const GPUFilterMode = {\r\n\tLinear: 'linear',\r\n\tNearest: 'nearest'\r\n};\r\n\r\nexport const GPUBlendFactor = {\r\n\tZero: 'zero' as GPUBlendFactor,\r\n\tOne: 'one' as GPUBlendFactor,\r\n\tSrcColor: 'src-color' as GPUBlendFactor,\r\n\tOneMinusSrcColor: 'one-minus-src-color' as GPUBlendFactor,\r\n\tSrcAlpha: 'src-alpha' as GPUBlendFactor,\r\n\tOneMinusSrcAlpha: 'one-minus-src-alpha' as GPUBlendFactor,\r\n\tDstColor: 'dst-color' as GPUBlendFactor,\r\n\tOneMinusDstColor: 'one-minus-dst-color' as GPUBlendFactor,\r\n\tDstAlpha: 'dst-alpha' as GPUBlendFactor,\r\n\tOneMinusDstAlpha: 'one-minus-dst-alpha' as GPUBlendFactor,\r\n\tSrcAlphaSaturated: 'src-alpha-saturated' as GPUBlendFactor,\r\n\tBlendColor: 'blend-color' as GPUBlendFactor,\r\n\tOneMinusBlendColor: 'one-minus-blend-color' as GPUBlendFactor\r\n};\r\n\r\nexport const GPUBlendOperation = {\r\n\tAdd: 'add',\r\n\tSubtract: 'subtract',\r\n\tReverseSubtract: 'reverse-subtract',\r\n\tMin: 'min',\r\n\tMax: 'max'\r\n};\r\n\r\nexport const GPUColorWriteFlags = {\r\n\tNone: 0,\r\n\tRed: 0x1,\r\n\tGreen: 0x2,\r\n\tBlue: 0x4,\r\n\tAlpha: 0x8,\r\n\tAll: 0xF\r\n};\r\n\r\nexport const GPUStencilOperation = {\r\n\tKeep: 'keep',\r\n\tZero: 'zero',\r\n\tReplace: 'replace',\r\n\tInvert: 'invert',\r\n\tIncrementClamp: 'increment-clamp',\r\n\tDecrementClamp: 'decrement-clamp',\r\n\tIncrementWrap: 'increment-wrap',\r\n\tDecrementWrap: 'decrement-wrap'\r\n};\r\n\r\nexport const GPUBindingType = {\r\n\tUniformBuffer: 'uniform-buffer',\r\n\tStorageBuffer: 'storage-buffer',\r\n\tReadonlyStorageBuffer: 'readonly-storage-buffer',\r\n\tSampler: 'sampler',\r\n\tComparisonSampler: 'comparison-sampler',\r\n\tSampledTexture: 'sampled-texture',\r\n\tMultisampledTexture: 'multisampled-texture',\r\n\tReadonlyStorageTexture: 'readonly-storage-texture',\r\n\tWriteonlyStorageTexture: 'writeonly-storage-texture'\r\n};\r\n\r\nexport const GPUTextureDimension = {\r\n\tOneD: '1d',\r\n\tTwoD: '2d',\r\n\tThreeD: '3d'\r\n};\r\n\r\nexport const GPUTextureViewDimension = {\r\n\tOneD: '1d',\r\n\tTwoD: '2d',\r\n\tTwoDArray: '2d-array',\r\n\tCube: 'cube',\r\n\tCubeArray: 'cube-array',\r\n\tThreeD: '3d'\r\n};\r\n\r\nexport const GPUInputStepMode = {\r\n\tVertex: 'vertex',\r\n\tInstance: 'instance'\r\n};\r\n\r\nexport const GPUSamplerBindingType = {\r\n\tFiltering:\"filtering\" as GPUSamplerBindingType,\r\n    NonFiltering:\"non-filtering\" as GPUSamplerBindingType,\r\n    Comparison:\"comparison\" as GPUSamplerBindingType\r\n}\r\n\r\nexport const GPUBufferBindingType = {\r\n\tUniform:\"uniform\" as GPUBufferBindingType,\r\n    Storage:\"storage\" as GPUBufferBindingType,\r\n    ReadOnlyStorage:\"read-only-storage\" as GPUBufferBindingType\r\n}\r\n\r\nexport const GPUChunkSize = 16; // size of a chunk in bytes (STD140 layout)\r\n\r\n\r\nexport const BlendColorFactor = 211;\r\nexport const OneMinusBlendColorFactor = 212;\r\n\r\nexport const GPUMapModeFlags = {\r\n\tRead:0x0001,\r\n\tWrite:0x0002\r\n}\r\n\r\nexport enum MOUSE {\r\n    LEFT = 0,\r\n    MIDDLE = 1,\r\n    RIGHT = 2,\r\n    ROTATE = 0,\r\n    DOLLY = 1,\r\n    PAN = 2,\r\n}\r\n\r\nexport enum TOUCH {\r\n    ROTATE = 0,\r\n    PAN = 1,\r\n    DOLLY_PAN = 2,\r\n    DOLLY_ROTATE = 3,\r\n}\r\n\r\n\r\nexport const UVMapping = 300;\r\nexport const CubeReflectionMapping = 301;\r\nexport const CubeRefractionMapping = 302;\r\nexport const EquirectangularReflectionMapping = 303;\r\nexport const EquirectangularRefractionMapping = 304;\r\nexport const CubeUVReflectionMapping = 306;\r\nexport const RepeatWrapping = 1000;\r\nexport const ClampToEdgeWrapping = 1001;\r\nexport const MirroredRepeatWrapping = 1002;\r\nexport const NearestFilter = 1003;\r\nexport const NearestMipmapNearestFilter = 1004;\r\nexport const NearestMipMapNearestFilter = 1004;\r\nexport const NearestMipmapLinearFilter = 1005;\r\nexport const NearestMipMapLinearFilter = 1005;\r\nexport const LinearFilter = 1006;\r\nexport const LinearMipmapNearestFilter = 1007;\r\nexport const LinearMipMapNearestFilter = 1007;\r\nexport const LinearMipmapLinearFilter = 1008;\r\nexport const LinearMipMapLinearFilter = 1008;\r\nexport const UnsignedByteType = 1009;\r\nexport const ByteType = 1010;\r\nexport const ShortType = 1011;\r\nexport const UnsignedShortType = 1012;\r\nexport const IntType = 1013;\r\nexport const UnsignedIntType = 1014;\r\nexport const FloatType = 1015;\r\nexport const HalfFloatType = 1016;\r\nexport const UnsignedShort4444Type = 1017;\r\nexport const UnsignedShort5551Type = 1018;\r\nexport const UnsignedInt248Type = 1020;\r\nexport const AlphaFormat = 1021;\r\nexport const RGBAFormat = 1023;\r\nexport const LuminanceFormat = 1024;\r\nexport const LuminanceAlphaFormat = 1025;\r\nexport const DepthFormat = 1026;\r\nexport const DepthStencilFormat = 1027;\r\nexport const RedFormat = 1028;\r\nexport const RedIntegerFormat = 1029;\r\nexport const RGFormat = 1030;\r\nexport const RGIntegerFormat = 1031;\r\nexport const RGBAIntegerFormat = 1033;\r\n\r\nexport const NoColorSpace = '';\r\n","import { Object3D } from '../core/Object3D';\r\nimport { BindBuffer } from '../core/binds/BindBuffer';\r\nimport { Matrix4 } from '../math/Matrix4';\r\nimport { Vector3 } from '../math/Vector3';\r\nimport { IdentifyMatrix4 } from '../utils/TMPValues';\r\n\r\nconst u_projection = \"projectionMatrix\";\r\nconst u_view = \"matrixWorldInverse\";\r\nexport class Camera extends Object3D {\r\n\r\n    public get type() {\r\n\t\treturn \"Camera\";\r\n    }\r\n\r\n\tpublic static Is(object:Object3D){\r\n\t\treturn object instanceof Camera;\r\n\t}\r\n\r\n\tpublic matrixWorldInverse = new Matrix4();\r\n\r\n\tpublic projectionMatrix = new Matrix4();\r\n\r\n\tpublic projectionMatrixInverse = new Matrix4();\r\n\r\n\tprivate _uniforms: Map<string, BindBuffer> = new Map();\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis._initInitialUniform();\r\n\t}\r\n\r\n\toverride copy( source:Camera, recursive = false ) {\r\n\r\n\t\tsuper.copy( source, recursive );\r\n\r\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\r\n\r\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\r\n\t\tthis.projectionMatrixInverse.copy( source.projectionMatrixInverse );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tgetWorldDirection( target:Vector3 ) {\r\n\r\n\t\tthis.updateWorldMatrix( true, false );\r\n\r\n\t\tconst e = this.matrixWorld.elements;\r\n\r\n\t\treturn target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();\r\n\r\n\t}\r\n\r\n\tupdateMatrixWorld() {\r\n\r\n        super.updateMatrixWorld();\r\n\r\n\t\tthis.matrixWorldInverse.copy( this.matrixWorld ).invert();\r\n\r\n\t}\r\n\r\n\tupdateWorldMatrix( updateParents = false, updateChildren = false ) {\r\n\r\n\t\tsuper.updateWorldMatrix( updateParents, updateChildren );\r\n\r\n\t\tthis.matrixWorldInverse.copy( this.matrixWorld ).invert();\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new Camera().copy( this );\r\n\r\n\t}\r\n\r\n\tpublic update(){\r\n\t\tthis.updateWorldMatrix();\r\n\t\tthis._updateUniformValue();\r\n\t}\r\n\r\n\tprivate _updateUniformValue(){\r\n\t\tlet uniform = this._uniforms.get(u_projection);\r\n\t\tuniform.data = this.projectionMatrix.toArray();\r\n\t\tuniform.update();\r\n\t\tuniform = this._uniforms.get(u_view);\r\n\t\tuniform.data = this.matrixWorldInverse.toArray();\r\n\t\tuniform.update();\r\n\t}\r\n\r\n\tprivate _initInitialUniform() {\r\n\t\tconst matrixBuffer = IdentifyMatrix4.toArray();\r\n        const projectionUniform = new BindBuffer(u_projection, matrixBuffer);\r\n        this._uniforms.set(u_projection, projectionUniform);\r\n\r\n        const viewUniform = new BindBuffer(u_view, matrixBuffer);\r\n        this._uniforms.set(u_view, viewUniform);\r\n    }\r\n\r\n\tpublic get uniforms(){\r\n\t\treturn this._uniforms;\r\n\t}\r\n\r\n}\r\n","import { Object3D } from \"../core/Object3D\";\r\nimport { Camera } from \"./Camera\";\r\n\r\n\r\nexport class OrthographicCamera extends Camera {\r\n    public get type(){\r\n        return \"OrthographicCamera\";\r\n    }\r\n\r\n\tpublic static Is(object:Object3D){\r\n\t\treturn object instanceof OrthographicCamera;\r\n\t}\r\n\r\n    public zoom = 1;\r\n    public view : any;\r\n\r\n    public left = - 1;\r\n    public right = 1;\r\n    public top = 1;\r\n    public bottom = -1;\r\n\r\n    public near = 0.1;\r\n    public far = 2000;\r\n\r\n\tconstructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {\r\n\r\n\t\tsuper();\r\n\t\tthis.left = left;\r\n\t\tthis.right = right;\r\n\t\tthis.top = top;\r\n\t\tthis.bottom = bottom;\r\n\t\tthis.near = near;\r\n\t\tthis.far = far;\r\n\r\n\r\n\t\tthis.updateProjectionMatrix();\r\n\r\n\t}\r\n\r\n\tcopy( source:OrthographicCamera, recursive = false ) {\r\n\r\n\t\tsuper.copy( source, recursive );\r\n\r\n\t\tthis.left = source.left;\r\n\t\tthis.right = source.right;\r\n\t\tthis.top = source.top;\r\n\t\tthis.bottom = source.bottom;\r\n\t\tthis.near = source.near;\r\n\t\tthis.far = source.far;\r\n\r\n\t\tthis.zoom = source.zoom;\r\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetViewOffset( fullWidth:number, fullHeight:number, x:number, y:number, width:number, height:number ) {\r\n\r\n\t\tif ( this.view === null ) {\r\n\r\n\t\t\tthis.view = {\r\n\t\t\t\tenabled: true,\r\n\t\t\t\tfullWidth: 1,\r\n\t\t\t\tfullHeight: 1,\r\n\t\t\t\toffsetX: 0,\r\n\t\t\t\toffsetY: 0,\r\n\t\t\t\twidth: 1,\r\n\t\t\t\theight: 1\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tthis.view.enabled = true;\r\n\t\tthis.view.fullWidth = fullWidth;\r\n\t\tthis.view.fullHeight = fullHeight;\r\n\t\tthis.view.offsetX = x;\r\n\t\tthis.view.offsetY = y;\r\n\t\tthis.view.width = width;\r\n\t\tthis.view.height = height;\r\n\r\n\t\tthis.updateProjectionMatrix();\r\n\r\n\t}\r\n\r\n\tclearViewOffset() {\r\n\r\n\t\tif ( this.view !== null ) {\r\n\r\n\t\t\tthis.view.enabled = false;\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateProjectionMatrix();\r\n\r\n\t}\r\n\r\n\tupdateProjectionMatrix() {\r\n\r\n\t\tconst dx = ( this.right - this.left ) / ( 2 * this.zoom );\r\n\t\tconst dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\r\n\t\tconst cx = ( this.right + this.left ) / 2;\r\n\t\tconst cy = ( this.top + this.bottom ) / 2;\r\n\r\n\t\tlet left = cx - dx;\r\n\t\tlet right = cx + dx;\r\n\t\tlet top = cy + dy;\r\n\t\tlet bottom = cy - dy;\r\n\r\n\t\tif ( this.view !== null && this.view.enabled ) {\r\n\r\n\t\t\tconst scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;\r\n\t\t\tconst scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;\r\n\r\n\t\t\tleft += scaleW * this.view.offsetX;\r\n\t\t\tright = left + scaleW * this.view.width;\r\n\t\t\ttop -= scaleH * this.view.offsetY;\r\n\t\t\tbottom = top - scaleH * this.view.height;\r\n\r\n\t\t}\r\n\r\n\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\r\n\r\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\r\n\r\n\t}\r\n\r\n}\r\n","import { Camera } from './Camera';\r\nimport * as MathUtils from '../math/MathUtils';\r\nimport { Object3D } from '../core/Object3D';\r\n\r\nexport class PerspectiveCamera extends Camera {\r\n\r\n    public get type(){\r\n        return \"PerspectiveCamera\";\r\n    }\r\n\r\n\tpublic static Is(object:Object3D){\r\n\t\treturn object instanceof PerspectiveCamera;\r\n\t}\r\n\r\n    public fov = 50;\r\n    public aspect = 1;\r\n    public near = 0.1;\r\n    public far = 2000;\r\n    public zoom = 1;\r\n    public focus = 10;\r\n    public view : any;\r\n    public filmGauge = 35;\r\n    public filmOffset = 10;\r\n\r\n\tconstructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.fov = fov;\r\n\t\tthis.zoom = 1;\r\n\r\n\t\tthis.near = near;\r\n\t\tthis.far = far;\r\n\t\tthis.focus = 10;\r\n\r\n\t\tthis.aspect = aspect;\r\n\t\tthis.view = null;\r\n\r\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\r\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\r\n\r\n\t\tthis.updateProjectionMatrix();\r\n\r\n\t}\r\n\r\n\tcopy( source:PerspectiveCamera, recursive = false ) {\r\n\r\n\t\tsuper.copy( source, recursive );\r\n\r\n\t\tthis.fov = source.fov;\r\n\t\tthis.zoom = source.zoom;\r\n\r\n\t\tthis.near = source.near;\r\n\t\tthis.far = source.far;\r\n\t\tthis.focus = source.focus;\r\n\r\n\t\tthis.aspect = source.aspect;\r\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\r\n\r\n\t\tthis.filmGauge = source.filmGauge;\r\n\t\tthis.filmOffset = source.filmOffset;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\r\n\t *\r\n\t * The default film gauge is 35, so that the focal length can be specified for\r\n\t * a 35mm (full frame) camera.\r\n\t *\r\n\t * Values for focal length and film gauge must have the same unit.\r\n\t */\r\n\tsetFocalLength( focalLength:number ) {\r\n\r\n\t\t/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\r\n\t\tconst vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\r\n\r\n\t\tthis.fov = MathUtils.RAD2DEG * 2 * Math.atan( vExtentSlope );\r\n\t\tthis.updateProjectionMatrix();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the focal length from the current .fov and .filmGauge.\r\n\t */\r\n\tgetFocalLength() {\r\n\r\n\t\tconst vExtentSlope = Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov );\r\n\r\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\r\n\r\n\t}\r\n\r\n\tgetEffectiveFOV() {\r\n\r\n\t\treturn MathUtils.RAD2DEG * 2 * Math.atan(\r\n\t\t\tMath.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom );\r\n\r\n\t}\r\n\r\n\tgetFilmWidth() {\r\n\r\n\t\t// film not completely covered in portrait format (aspect < 1)\r\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\r\n\r\n\t}\r\n\r\n\tgetFilmHeight() {\r\n\r\n\t\t// film not completely covered in landscape format (aspect > 1)\r\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\r\n\t * multi-monitor/multi-machine setups.\r\n\t *\r\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n\t * the monitors are in grid like this\r\n\t *\r\n\t *   +---+---+---+\r\n\t *   | A | B | C |\r\n\t *   +---+---+---+\r\n\t *   | D | E | F |\r\n\t *   +---+---+---+\r\n\t *\r\n\t * then for each monitor you would call it like this\r\n\t *\r\n\t *   const w = 1920;\r\n\t *   const h = 1080;\r\n\t *   const fullWidth = w * 3;\r\n\t *   const fullHeight = h * 2;\r\n\t *\r\n\t *   --A--\r\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n\t *   --B--\r\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n\t *   --C--\r\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n\t *   --D--\r\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n\t *   --E--\r\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n\t *   --F--\r\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n\t *\r\n\t *   Note there is no reason monitors have to be the same size or in a grid.\r\n\t */\r\n\tsetViewOffset( fullWidth:number, fullHeight:number, x:number, y:number, width:number, height:number ) {\r\n\r\n\t\tthis.aspect = fullWidth / fullHeight;\r\n\r\n\t\tif ( this.view === null ) {\r\n\r\n\t\t\tthis.view = {\r\n\t\t\t\tenabled: true,\r\n\t\t\t\tfullWidth: 1,\r\n\t\t\t\tfullHeight: 1,\r\n\t\t\t\toffsetX: 0,\r\n\t\t\t\toffsetY: 0,\r\n\t\t\t\twidth: 1,\r\n\t\t\t\theight: 1\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tthis.view.enabled = true;\r\n\t\tthis.view.fullWidth = fullWidth;\r\n\t\tthis.view.fullHeight = fullHeight;\r\n\t\tthis.view.offsetX = x;\r\n\t\tthis.view.offsetY = y;\r\n\t\tthis.view.width = width;\r\n\t\tthis.view.height = height;\r\n\r\n\t\tthis.updateProjectionMatrix();\r\n\r\n\t}\r\n\r\n\tclearViewOffset() {\r\n\r\n\t\tif ( this.view !== null ) {\r\n\r\n\t\t\tthis.view.enabled = false;\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateProjectionMatrix();\r\n\r\n\t}\r\n\r\n\tupdateProjectionMatrix() {\r\n\r\n\t\tconst near = this.near;\r\n\t\tlet top = near * Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom;\r\n\t\tlet height = 2 * top;\r\n\t\tlet width = this.aspect * height;\r\n\t\tlet left = - 0.5 * width;\r\n\t\tconst view = this.view;\r\n\r\n\t\tif ( this.view !== null && this.view.enabled ) {\r\n\r\n\t\t\tconst fullWidth = view.fullWidth,\r\n\t\t\t\tfullHeight = view.fullHeight;\r\n\r\n\t\t\tleft += view.offsetX * width / fullWidth;\r\n\t\t\ttop -= view.offsetY * height / fullHeight;\r\n\t\t\twidth *= view.width / fullWidth;\r\n\t\t\theight *= view.height / fullHeight;\r\n\r\n\t\t}\r\n\r\n\t\tconst skew = this.filmOffset;\r\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\r\n\r\n\t\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );\r\n\r\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\r\n\r\n\t}\r\n}\r\n","import { Camera } from \"../cameras/Camera\";\r\nimport { OrthographicCamera } from \"../cameras/OrthographicCamera\";\r\nimport { PerspectiveCamera } from \"../cameras/PerspectiveCamera\";\r\nimport { MOUSE } from \"../Constants\";\r\nimport { Matrix4 } from \"../math/Matrix4\";\r\nimport { Quaternion } from \"../math/Quaternion\";\r\nimport { Spherical } from \"../math/Spherical\";\r\nimport { Vector2 } from \"../math/Vector2\";\r\nimport { Vector3 } from \"../math/Vector3\";\r\n\r\nconst STATE = {\r\n  NONE: - 1,\r\n  ROTATE: 0,\r\n  DOLLY: 1,\r\n  PAN: 2,\r\n  TOUCH_ROTATE: 3,\r\n  TOUCH_DOLLY: 4,\r\n  TOUCH_PAN: 5\r\n};\r\n\r\nconst EPS = 0.000001;\r\nconst twoPI = 2 * Math.PI;\r\n/**\r\n* @author qiao / https://github.com/qiao\r\n* @author mrdoob / http://mrdoob.com\r\n* @author alteredq / http://alteredqualia.com/\r\n* @author WestLangley / http://github.com/WestLangley\r\n* @author erich666 / http://erichaines.com\r\n* @author nicolaspanel / http://github.com/nicolaspanel\r\n*\r\n* This set of controls performs orbiting, dollying (zooming), and panning.\r\n* Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\r\n*    Orbit - left mouse / touch: one finger move\r\n*    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\r\n*    Pan - right mouse, or arrow keys / touch:  finger swipe\r\n*/\r\nexport class OrbitControls {\r\n  camera: PerspectiveCamera | OrthographicCamera;\r\n  domElement: HTMLElement;\r\n  window: Window;\r\n\r\n  // API\r\n  enabled: boolean;\r\n  target: Vector3;\r\n\r\n  enableZoom: boolean;\r\n  zoomSpeed: number;\r\n  minDistance: number;\r\n  maxDistance: number;\r\n  enableRotate: boolean;\r\n  rotateSpeed: number;\r\n  enablePan: boolean;\r\n  keyPanSpeed: number;\r\n  autoRotate: boolean;\r\n  autoRotateSpeed: number;\r\n  minZoom: number;\r\n  maxZoom: number;\r\n  minPolarAngle: number;\r\n  maxPolarAngle: number;\r\n  minAzimuthAngle: number;\r\n  maxAzimuthAngle: number;\r\n  enableKeys: boolean;\r\n  keys: { LEFT: number; UP: number; RIGHT: number; BOTTOM: number; };\r\n  mouseButtons: { ORBIT: MOUSE; ZOOM: MOUSE; PAN: MOUSE; };\r\n  enableDamping: boolean;\r\n  dampingFactor: number;\r\n\r\n  private spherical: Spherical;\r\n  private sphericalDelta: Spherical;\r\n  private scale: number;\r\n  private target0: Vector3;\r\n  private position0: Vector3;\r\n  private zoom0: any;\r\n  private state: number;\r\n  private panOffset: Vector3;\r\n  private zoomChanged: boolean;\r\n\r\n  private rotateStart: Vector2;\r\n  private rotateEnd: Vector2;\r\n  private rotateDelta: Vector2\r\n\r\n  private panStart: Vector2;\r\n  private panEnd: Vector2;\r\n  private panDelta: Vector2;\r\n\r\n  private dollyStart: Vector2;\r\n  private dollyEnd: Vector2;\r\n  private dollyDelta: Vector2;\r\n\r\n  private updateLastPosition: Vector3;\r\n  private updateLastTargetPosition: Vector3;\r\n  private updateOffset: Vector3;\r\n  private updateQuat: Quaternion;\r\n  private updateLastQuaternion: Quaternion;\r\n  private updateQuatInverse: Quaternion;\r\n\r\n  private panLeftV: Vector3;\r\n  private panUpV: Vector3;\r\n  private panInternalOffset: Vector3;\r\n\r\n  private onContextMenu: any;\r\n  private onMouseUp: any;\r\n  private onMouseDown: any;\r\n  private onMouseMove: any;\r\n  private onMouseWheel: any;\r\n  private onTouchStart: any;\r\n  private onTouchEnd: any;\r\n  private onTouchMove: any;\r\n  private onKeyDown: any;\r\n\r\n  constructor (object: PerspectiveCamera | OrthographicCamera, domElement: HTMLElement, domWindow?: Window) {\r\n    this.camera = object;\r\n\r\n    this.domElement = domElement;\r\n    this.window = ( domWindow !== undefined ) ? domWindow : window;\r\n\r\n    // Set to false to disable this control\r\n    this.enabled = true;\r\n\r\n    // \"target\" sets the location of focus, where the object orbits around\r\n    this.target = new Vector3();\r\n\r\n    // How far you can dolly in and out ( PerspectiveCamera only )\r\n    this.minDistance = 0;\r\n    this.maxDistance = Infinity;\r\n\r\n    // How far you can zoom in and out ( OrthographicCamera only )\r\n    this.minZoom = 0;\r\n    this.maxZoom = Infinity;\r\n\r\n    // How far you can orbit vertically, upper and lower limits.\r\n    // Range is 0 to Math.PI radians.\r\n    this.minPolarAngle = 0; // radians\r\n    this.maxPolarAngle = Math.PI; // radians\r\n\r\n    // How far you can orbit horizontally, upper and lower limits.\r\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\r\n    this.minAzimuthAngle = - Infinity; // radians\r\n    this.maxAzimuthAngle = Infinity; // radians\r\n\r\n    // Set to true to enable damping (inertia)\r\n    // If damping is enabled, you must call controls.update() in your animation loop\r\n    this.enableDamping = false;\r\n    this.dampingFactor = 0.25;\r\n\r\n    // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\r\n    // Set to false to disable zooming\r\n    this.enableZoom = true;\r\n    this.zoomSpeed = 1.0;\r\n\r\n    // Set to false to disable rotating\r\n    this.enableRotate = true;\r\n    this.rotateSpeed = 1.0;\r\n\r\n    // Set to false to disable panning\r\n    this.enablePan = true;\r\n    this.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\r\n\r\n    // Set to true to automatically rotate around the target\r\n    // If auto-rotate is enabled, you must call controls.update() in your animation loop\r\n    this.autoRotate = false;\r\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\r\n\r\n    // Set to false to disable use of the keys\r\n    this.enableKeys = true;\r\n\r\n    // The four arrow keys\r\n    this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\r\n\r\n    // Mouse buttons\r\n    this.mouseButtons = { ORBIT: MOUSE.LEFT, ZOOM: MOUSE.MIDDLE, PAN: MOUSE.RIGHT };\r\n\r\n    // for reset\r\n    this.target0 = this.target.clone();\r\n    this.position0 = this.camera.position.clone();\r\n    this.zoom0 = (this.camera as any).zoom;\r\n\r\n    // for update speedup\r\n    this.updateOffset = new Vector3();\r\n    // so camera.up is the orbit axis\r\n    this.updateQuat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );\r\n    this.updateQuatInverse = this.updateQuat.clone().invert();\r\n    this.updateLastPosition = new Vector3();\r\n    this.updateLastTargetPosition = new Vector3();\r\n    this.updateLastQuaternion = new Quaternion();\r\n\r\n    this.state = STATE.NONE;\r\n    this.scale = 1;\r\n\r\n    // current position in spherical coordinates\r\n    this.spherical = new Spherical();\r\n    this.sphericalDelta = new Spherical();\r\n\r\n    this.panOffset = new Vector3();\r\n    this.zoomChanged = false;\r\n\r\n    this.rotateStart = new Vector2();\r\n    this.rotateEnd = new Vector2();\r\n    this.rotateDelta = new Vector2();\r\n\r\n    this.panStart = new Vector2();\r\n    this.panEnd = new Vector2();\r\n    this.panDelta = new Vector2();\r\n\r\n    this.dollyStart = new Vector2();\r\n    this.dollyEnd = new Vector2();\r\n    this.dollyDelta = new Vector2();\r\n\r\n    this.panLeftV = new Vector3();\r\n    this.panUpV = new Vector3();\r\n    this.panInternalOffset = new Vector3();\r\n\r\n    // event handlers - FSM: listen for events and reset state\r\n\r\n    this.onMouseDown = ( event: MouseEvent ) => {\r\n      if ( this.enabled === false ) return;\r\n      event.preventDefault();\r\n      if ( (event as any).button === this.mouseButtons.ORBIT ) {\r\n        if ( this.enableRotate === false ) return;\r\n        this.rotateStart.set( event.clientX, event.clientY );\r\n        this.state = STATE.ROTATE;\r\n      } else if ( event.button === this.mouseButtons.ZOOM ) {\r\n        if ( this.enableZoom === false ) return;\r\n        this.dollyStart.set( event.clientX, event.clientY );\r\n        this.state = STATE.DOLLY;\r\n      } else if ( event.button === this.mouseButtons.PAN ) {\r\n        if ( this.enablePan === false ) return;\r\n        this.panStart.set( event.clientX, event.clientY );\r\n        this.state = STATE.PAN;\r\n      }\r\n\r\n      if ( this.state !== STATE.NONE ) {\r\n        document.addEventListener( 'mousemove', this.onMouseMove, false );\r\n        document.addEventListener( 'mouseup', this.onMouseUp, false );\r\n        //this.dispatchEvent( START_EVENT );\r\n      }\r\n    };\r\n\r\n    this.onMouseMove = ( event: MouseEvent ) => {\r\n\r\n      if ( this.enabled === false ) return;\r\n\r\n      event.preventDefault();\r\n\r\n      if ( this.state === STATE.ROTATE ) {\r\n        if ( this.enableRotate === false ) return;\r\n        this.rotateEnd.set( event.clientX, event.clientY );\r\n        this.rotateDelta.subVectors( this.rotateEnd, this.rotateStart );\r\n        const element = this.domElement;\r\n\r\n        // rotating across whole screen goes 360 degrees around\r\n        this.rotateLeft( 2 * Math.PI * this.rotateDelta.x / (element as any).clientWidth * this.rotateSpeed );\r\n        // rotating up and down along whole screen attempts to go 360, but limited to 180\r\n        this.rotateUp( 2 * Math.PI * this.rotateDelta.y / (element as any).clientHeight * this.rotateSpeed );\r\n        this.rotateStart.copy( this.rotateEnd );\r\n\r\n        this.update();\r\n      } else if ( this.state === STATE.DOLLY ) {\r\n\r\n        if ( this.enableZoom === false ) return;\r\n\r\n        this.dollyEnd.set( event.clientX, event.clientY );\r\n        this.dollyDelta.subVectors( this.dollyEnd, this.dollyStart );\r\n\r\n        if ( this.dollyDelta.y > 0 ) {\r\n          this.dollyIn( this.getZoomScale() );\r\n        } else if ( this.dollyDelta.y < 0 ) {\r\n          this.dollyOut( this.getZoomScale() );\r\n        }\r\n\r\n        this.dollyStart.copy( this.dollyEnd );\r\n        this.update();\r\n      } else if ( this.state === STATE.PAN ) {\r\n\r\n        if ( this.enablePan === false ) return;\r\n\r\n        this.panEnd.set( event.clientX, event.clientY );\r\n        this.panDelta.subVectors( this.panEnd, this.panStart );\r\n        this.pan( this.panDelta.x, this.panDelta.y );\r\n        this.panStart.copy( this.panEnd );\r\n        this.update();\r\n      }\r\n    }\r\n\r\n    this.onMouseUp = () => {\r\n      if ( this.enabled === false ) return;\r\n      document.removeEventListener( 'mousemove', this.onMouseMove, false );\r\n      document.removeEventListener( 'mouseup', this.onMouseUp, false );\r\n\r\n      this.state = STATE.NONE;\r\n    };\r\n\r\n    this.onMouseWheel = ( event: WheelEvent ) => {\r\n\r\n      if ( this.enabled === false || this.enableZoom === false || ( this.state !== STATE.NONE && this.state !== STATE.ROTATE ) ) return;\r\n\r\n      event.preventDefault();\r\n      event.stopPropagation();\r\n\r\n      if ( event.deltaY < 0 ) {\r\n        this.dollyOut( this.getZoomScale() );\r\n      } else if ( event.deltaY > 0 ) {\r\n        this.dollyIn( this.getZoomScale() );\r\n      }\r\n\r\n      this.update();\r\n\r\n      //this.dispatchEvent( START_EVENT ); // not sure why these are here...\r\n      //this.dispatchEvent( END_EVENT );\r\n    };\r\n\r\n    this.onKeyDown = ( event: ControlEvent ) => {\r\n\r\n      if ( this.enabled === false || this.enableKeys === false || this.enablePan === false ) return;\r\n\r\n      switch ( event.keyCode ) {\r\n        case this.keys.UP: {\r\n          this.pan( 0, this.keyPanSpeed );\r\n          this.update();\r\n        } break;\r\n        case this.keys.BOTTOM: {\r\n          this.pan( 0, - this.keyPanSpeed );\r\n          this.update();\r\n        } break;\r\n        case this.keys.LEFT: {\r\n          this.pan( this.keyPanSpeed, 0 );\r\n          this.update();\r\n        } break;\r\n        case this.keys.RIGHT: {\r\n          this.pan( - this.keyPanSpeed, 0 );\r\n          this.update();\r\n        } break;\r\n      }\r\n    };\r\n\r\n    this.onTouchStart = ( event: ControlEvent ) => {\r\n\r\n      if ( this.enabled === false ) return;\r\n\r\n      switch ( event.touches.length ) {\r\n        \t// one-fingered touch: rotate\r\n        case 1: {\r\n          if ( this.enableRotate === false ) return;\r\n\r\n          this.rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n          this.state = STATE.TOUCH_ROTATE;\r\n        } break;\r\n        // two-fingered touch: dolly\r\n        case 2:\t{\r\n          if ( this.enableZoom === false ) return;\r\n\r\n          const dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n          const dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\r\n          const distance = Math.sqrt( dx * dx + dy * dy );\r\n          this.dollyStart.set( 0, distance );\r\n          this.state = STATE.TOUCH_DOLLY;\r\n        } break;\r\n        // -fingered touch: pan\r\n        case 3: {\r\n          if ( this.enablePan === false ) return;\r\n\r\n          this.panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n          this.state = STATE.TOUCH_PAN;\r\n        } break;\r\n        default: {\r\n          this.state = STATE.NONE;\r\n        }\r\n      }\r\n\r\n      if ( this.state !== STATE.NONE ) {\r\n        //this.dispatchEvent( START_EVENT );\r\n      }\r\n    };\r\n\r\n    this.onTouchMove = ( event: TouchEvent ) => {\r\n\r\n      if ( this.enabled === false ) return;\r\n      event.preventDefault();\r\n      event.stopPropagation();\r\n\r\n      switch ( event.touches.length ) {\r\n        // one-fingered touch: rotate\r\n        case 1: {\r\n          if ( this.enableRotate === false ) return;\r\n          if ( this.state !== STATE.TOUCH_ROTATE ) return; // is this needed?...\r\n\r\n          this.rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n          this.rotateDelta.subVectors( this.rotateEnd, this.rotateStart );\r\n\r\n          const element = this.domElement;\r\n\r\n          // rotating across whole screen goes 360 degrees around\r\n          this.rotateLeft( 2 * Math.PI * this.rotateDelta.x / (element as any).clientWidth * this.rotateSpeed );\r\n\r\n          // rotating up and down along whole screen attempts to go 360, but limited to 180\r\n          this.rotateUp( 2 * Math.PI * this.rotateDelta.y / (element as any).clientHeight * this.rotateSpeed );\r\n\r\n          this.rotateStart.copy( this.rotateEnd );\r\n\r\n          this.update();\r\n        } break;\r\n        // two-fingered touch: dolly\r\n        case 2: {\r\n          if ( this.enableZoom === false ) return;\r\n          if ( this.state !== STATE.TOUCH_DOLLY ) return; // is this needed?...\r\n\r\n          //console.log( 'handleTouchMoveDolly' );\r\n          const dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n          const dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\r\n          const distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n          this.dollyEnd.set( 0, distance );\r\n\r\n          this.dollyDelta.subVectors( this.dollyEnd, this.dollyStart );\r\n\r\n          if ( this.dollyDelta.y > 0 ) {\r\n            this.dollyOut( this.getZoomScale() );\r\n          } else if ( this.dollyDelta.y < 0 ) {\r\n            this.dollyIn( this.getZoomScale() );\r\n          }\r\n\r\n          this.dollyStart.copy( this.dollyEnd );\r\n          this.update();\r\n        } break;\r\n        // -fingered touch: pan\r\n        case 3: {\r\n          if ( this.enablePan === false ) return;\r\n          if ( this.state !== STATE.TOUCH_PAN ) return; // is this needed?...\r\n          this.panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n          this.panDelta.subVectors( this.panEnd, this.panStart );\r\n          this.pan( this.panDelta.x, this.panDelta.y );\r\n          this.panStart.copy( this.panEnd );\r\n          this.update();\r\n        } break;\r\n        default: {\r\n          this.state = STATE.NONE;\r\n        }\r\n      }\r\n    };\r\n\r\n    this.onTouchEnd = () => {\r\n\r\n      if ( this.enabled === false ) return;\r\n\r\n      this.state = STATE.NONE;\r\n    }\r\n\r\n    this.onContextMenu = (event:MouseEvent) => {\r\n      event.preventDefault();\r\n    };\r\n\r\n    this.domElement.addEventListener( 'contextmenu', this.onContextMenu, false );\r\n\r\n    this.domElement.addEventListener( 'mousedown', this.onMouseDown, false );\r\n    this.domElement.addEventListener( 'wheel', this.onMouseWheel, false );\r\n\r\n    this.domElement.addEventListener( 'touchstart', this.onTouchStart, false );\r\n    this.domElement.addEventListener( 'touchend', this.onTouchEnd, false );\r\n    this.domElement.addEventListener( 'touchmove', this.onTouchMove, false );\r\n\r\n    this.window.addEventListener( 'keydown', this.onKeyDown, false );\r\n\r\n    // force an update at start\r\n    this.update();\r\n  }\r\n\r\n  update () {\r\n    const position = this.camera.position;\r\n    this.updateOffset.copy( position ).sub( this.target );\r\n\r\n    // rotate offset to \"y-axis-is-up\" space\r\n    this.updateOffset.applyQuaternion( this.updateQuat );\r\n\r\n    // angle from z-axis around y-axis\r\n    this.spherical.setFromVector3( this.updateOffset );\r\n\r\n    if ( this.autoRotate && this.state === STATE.NONE ) {\r\n      this.rotateLeft( this.getAutoRotationAngle() );\r\n    }\r\n\r\n    if ( this.enableDamping ) {\r\n\r\n      this.spherical.theta += this.sphericalDelta.theta * this.dampingFactor;\r\n      this.spherical.phi += this.sphericalDelta.phi * this.dampingFactor;\r\n\r\n    } else {\r\n\r\n      this.spherical.theta += this.sphericalDelta.theta;\r\n      this.spherical.phi += this.sphericalDelta.phi;\r\n\r\n    }\r\n\r\n    // restrict theta to be between desired limits\r\n\r\n    let min = this.minAzimuthAngle;\r\n    let max = this.maxAzimuthAngle;\r\n\r\n    if ( isFinite( min ) && isFinite( max ) ) {\r\n\r\n      if ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;\r\n\r\n      if ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;\r\n\r\n      if ( min <= max ) {\r\n\r\n        this.spherical.theta = Math.max( min, Math.min( max, this.spherical.theta ) );\r\n\r\n      } else {\r\n\r\n        this.spherical.theta = (this.spherical.theta > ( min + max ) / 2 ) ?\r\n          Math.max( min, this.spherical.theta ) :\r\n          Math.min( max, this.spherical.theta );\r\n\r\n      }\r\n\r\n    }\r\n\r\n    // restrict phi to be between desired limits\r\n    this.spherical.phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, this.spherical.phi ) );\r\n\r\n    this.spherical.makeSafe();\r\n\r\n\r\n    this.spherical.radius *= this.scale;\r\n\r\n    // restrict radius to be between desired limits\r\n    this.spherical.radius = Math.max( this.minDistance, Math.min( this.maxDistance, this.spherical.radius ) );\r\n\r\n    // move target to panned location\r\n\r\n    if ( this.enableDamping === true ) {\r\n\r\n      this.target.addScaledVector( this.panOffset, this.dampingFactor );\r\n\r\n    } else {\r\n\r\n      this.target.add( this.panOffset );\r\n\r\n    }\r\n\r\n    this.updateOffset.setFromSpherical(this. spherical );\r\n\r\n    // rotate offset back to \"camera-up-vector-is-up\" space\r\n    this.updateOffset.applyQuaternion( this.updateQuatInverse );\r\n\r\n    position.copy( this.target ).add( this.updateOffset );\r\n\r\n    this.camera.lookAt( this.target );\r\n\r\n    if ( this.enableDamping === true ) {\r\n\r\n      this.sphericalDelta.theta *= ( 1 - this.dampingFactor );\r\n      this.sphericalDelta.phi *= ( 1 - this.dampingFactor );\r\n\r\n      this.panOffset.multiplyScalar( 1 - this.dampingFactor );\r\n\r\n    } else {\r\n\r\n      this.sphericalDelta.set( 0, 0, 0 );\r\n\r\n      this.panOffset.set( 0, 0, 0 );\r\n\r\n    }\r\n\r\n    this.scale = 1;\r\n\r\n    // update condition is:\r\n    // min(camera displacement, camera rotation in radians)^2 > EPS\r\n    // using small-angle approximation cos(x/2) = 1 - x^2 / 8\r\n\r\n    if ( this.zoomChanged ||\r\n      this.updateLastPosition.distanceToSquared( this.camera.position ) > EPS ||\r\n      8 * ( 1 - this.updateLastQuaternion.dot( this.camera.quaternion ) ) > EPS ||\r\n      this.updateLastTargetPosition.distanceToSquared( this.target ) > 0 ) {\r\n\r\n      this.updateLastPosition.copy( this.camera.position );\r\n      this.updateLastQuaternion.copy( this.camera.quaternion );\r\n      this.updateLastTargetPosition.copy( this.target );\r\n\r\n      this.zoomChanged = false;\r\n\r\n      return true;\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n    // this.spherical.theta += this.sphericalDelta.theta;\r\n    // this.spherical.phi += this.sphericalDelta.phi;\r\n\r\n    // // restrict theta to be between desired limits\r\n    // this.spherical.theta = Math.max( this.minAzimuthAngle, Math.min( this.maxAzimuthAngle, this.spherical.theta ) );\r\n\r\n    // // restrict phi to be between desired limits\r\n    // this.spherical.phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, this.spherical.phi ) );\r\n\r\n    // this.spherical.makeSafe();\r\n\r\n    // this.spherical.radius *= this.scale;\r\n\r\n    // // restrict radius to be between desired limits\r\n    // this.spherical.radius = Math.max( this.minDistance, Math.min( this.maxDistance, this.spherical.radius ) );\r\n\r\n    // // move target to panned location\r\n    // this.target.add( this.panOffset );\r\n\r\n    // this.updateOffset.setFromSpherical( this.spherical );\r\n\r\n    // // rotate offset back to \"camera-up-vector-is-up\" space\r\n    // this.updateOffset.applyQuaternion( this.updateQuatInverse );\r\n\r\n    // position.copy( this.target ).add( this.updateOffset );\r\n\r\n    // this.camera.lookAt( this.target );\r\n\r\n    // if ( this.enableDamping === true ) {\r\n\r\n    //   this.sphericalDelta.theta *= ( 1 - this.dampingFactor );\r\n    //   this.sphericalDelta.phi *= ( 1 - this.dampingFactor );\r\n\r\n    // } else {\r\n\r\n    //   this.sphericalDelta.set( 0, 0, 0 );\r\n\r\n    // }\r\n\r\n    // this.scale = 1;\r\n    // this.panOffset.set( 0, 0, 0 );\r\n\r\n    // // update condition is:\r\n    // // min(camera displacement, camera rotation in radians)^2 > EPS\r\n    // // using small-angle approximation cos(x/2) = 1 - x^2 / 8\r\n\r\n    // if ( this.zoomChanged ||\r\n    //   this.updateLastPosition.distanceToSquared( this.camera.position ) > EPS ||\r\n    //   8 * ( 1 - this.updateLastQuaternion.dot( this.camera.quaternion ) ) > EPS ) {\r\n\r\n    //   //this.dispatchEvent( CHANGE_EVENT );\r\n    //   this.updateLastPosition.copy( this.camera.position );\r\n    //   this.updateLastQuaternion.copy( this.camera.quaternion );\r\n    //   this.zoomChanged = false;\r\n    //   return true;\r\n    // }\r\n    // return false;\r\n  }\r\n\r\n  panLeft( distance: number, objectMatrix:Matrix4 ) {\r\n    this.panLeftV.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\r\n    this.panLeftV.multiplyScalar( - distance );\r\n    this.panOffset.add( this.panLeftV );\r\n  }\r\n\r\n  panUp( distance: number, objectMatrix:Matrix4 ) {\r\n    this.panUpV.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix\r\n    this.panUpV.multiplyScalar( distance );\r\n    this.panOffset.add( this.panUpV );\r\n  }\r\n\r\n  // deltaX and deltaY are in pixels; right and down are positive\r\n  pan( deltaX: number, deltaY: number ) {\r\n    const element = this.domElement;\r\n\r\n    if (this._checkPerspectiveCamera(this.camera)) {\r\n      // perspective\r\n      const position = this.camera.position;\r\n      this.panInternalOffset.copy( position ).sub( this.target );\r\n      let targetDistance = this.panInternalOffset.length();\r\n\r\n      // half of the fov is center to top of screen\r\n      targetDistance *= Math.tan( ( this.camera.fov / 2 ) * Math.PI / 180.0 );\r\n\r\n      // we actually don't use screenWidth, since perspective camera is fixed to screen height\r\n      this.panLeft( 2 * deltaX * targetDistance / (element as any).clientHeight, this.camera.matrix );\r\n      this.panUp( 2 * deltaY * targetDistance / (element as any).clientHeight, this.camera.matrix );\r\n    } else if (this._checkOrthographicCamera(this.camera)) {\r\n      // orthographic\r\n      this.panLeft( deltaX * ( this.camera.right - this.camera.left ) / this.camera.zoom / (element as any).clientWidth, this.camera.matrix );\r\n      this.panUp( deltaY * ( this.camera.top - this.camera.bottom ) / this.camera.zoom / (element as any).clientHeight, this.camera.matrix );\r\n    } else {\r\n      // camera neither orthographic nor perspective\r\n      console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\r\n      this.enablePan = false;\r\n    }\r\n  }\r\n\r\n  dollyIn( dollyScale:number ) {\r\n    if (this._checkPerspectiveCamera(this.camera)) {\r\n      this.scale /= dollyScale;\r\n    } else if (this._checkOrthographicCamera(this.camera)) {\r\n      this.camera.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.camera.zoom * dollyScale ) );\r\n      this.camera.updateProjectionMatrix();\r\n      this.zoomChanged = true;\r\n    } else {\r\n      console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\r\n      this.enableZoom = false;\r\n    }\r\n  }\r\n\r\n  dollyOut( dollyScale:number ) {\r\n    if (this._checkPerspectiveCamera(this.camera)) {\r\n      this.scale *= dollyScale;\r\n    } else if (this._checkOrthographicCamera(this.camera)) {\r\n      this.camera.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.camera.zoom / dollyScale ) );\r\n      this.camera.updateProjectionMatrix();\r\n      this.zoomChanged = true;\r\n    } else {\r\n      console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\r\n      this.enableZoom = false;\r\n    }\r\n  }\r\n\r\n  getAutoRotationAngle() {\r\n    return 2 * Math.PI / 60 / 60 * this.autoRotateSpeed;\r\n  }\r\n\r\n  getZoomScale() {\r\n    return Math.pow( 0.95, this.zoomSpeed );\r\n  }\r\n\r\n  rotateLeft( angle: number ) {\r\n    this.sphericalDelta.theta -= angle;\r\n  }\r\n\r\n  rotateUp( angle: number ) {\r\n    this.sphericalDelta.phi -= angle;\r\n  }\r\n\r\n  getPolarAngle (): number {\r\n    return this.spherical.phi;\r\n  }\r\n\r\n  getAzimuthalAngle (): number {\r\n    return this.spherical.theta;\r\n  }\r\n\r\n  dispose (): void {\r\n    this.domElement.removeEventListener( 'contextmenu', this.onContextMenu, false );\r\n    this.domElement.removeEventListener( 'mousedown', this.onMouseDown, false );\r\n    this.domElement.removeEventListener( 'wheel', this.onMouseWheel, false );\r\n\r\n    this.domElement.removeEventListener( 'touchstart', this.onTouchStart, false );\r\n    this.domElement.removeEventListener( 'touchend', this.onTouchEnd, false );\r\n    this.domElement.removeEventListener( 'touchmove', this.onTouchMove, false );\r\n\r\n    document.removeEventListener( 'mousemove', this.onMouseMove, false );\r\n    document.removeEventListener( 'mouseup', this.onMouseUp, false );\r\n\r\n    this.window.removeEventListener( 'keydown', this.onKeyDown, false );\r\n    //this.dispatchEvent( { type: 'dispose' } ); // should this be added here?\r\n  }\r\n\r\n  reset (): void {\r\n    this.target.copy( this.target0 );\r\n    this.camera.position.copy( this.position0 );\r\n    (this.camera as any).zoom = this.zoom0;\r\n\r\n    (this.camera as any).updateProjectionMatrix();\r\n    //this.dispatchEvent( CHANGE_EVENT );\r\n\r\n    this.update();\r\n\r\n    this.state = STATE.NONE;\r\n  }\r\n\r\n  saveState(): void {\r\n    this.target0.copy(this.target);\r\n    this.position0.copy(this.camera.position);\r\n    // Check whether the camera has zoom property\r\n    if (this._checkOrthographicCamera(this.camera) || this._checkPerspectiveCamera(this.camera)){\r\n      this.zoom0 = this.camera.zoom;\r\n    }\r\n  }\r\n\r\n  // backward compatibility\r\n  get center(): Vector3 {\r\n    console.warn('OrbitControls: .center has been renamed to .target');\r\n    return this.target;\r\n  }\r\n  get noZoom(): boolean {\r\n    console.warn( 'OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\r\n    return ! this.enableZoom;\r\n  }\r\n\r\n  set noZoom( value: boolean ) {\r\n    console.warn( 'OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\r\n    this.enableZoom = ! value;\r\n  }\r\n\r\n  /**\r\n   * TS typeguard. Checks whether the provided camera is PerspectiveCamera. \r\n   * If the check passes (returns true) the passed camera will have the type PerspectiveCamera in the if branch where the check was performed.\r\n   * @param camera Object to be checked.\r\n   */\r\n  private _checkPerspectiveCamera(camera: Camera): camera is PerspectiveCamera{\r\n    return PerspectiveCamera.Is(camera);\r\n  }\r\n  /**\r\n   * TS typeguard. Checks whether the provided camera is OrthographicCamera. \r\n   * If the check passes (returns true) the passed camera will have the type OrthographicCamera in the if branch where the check was performed.\r\n   * @param camera Object to be checked.\r\n   */\r\n  private _checkOrthographicCamera(camera: Camera): camera is OrthographicCamera{\r\n    return OrthographicCamera.Is(camera);\r\n  }\r\n}\r\n\r\ninterface ControlEvent extends Event {\r\n  clientX: number;\r\n  clientY: number;\r\n  deltaY: number;\r\n  button: MOUSE;\r\n  touches: Array<any>;\r\n  keyCode: number;\r\n}","import { NumberArrayType } from '../Constants';\r\nimport { GPUBufferWrapper } from './GPUBufferWrapper';\r\n\r\nexport class BufferAttribute{\r\n    private _array : NumberArrayType;\r\n    private _count  = 0;\r\n    private _itemSize  = 0;\r\n    private _format : GPUVertexFormat | GPUIndexFormat;\r\n    private _normalized  = false;\r\n    private _byteLength  = 0;\r\n    private _name  = '';\r\n    private _needsUpdate  = false;\r\n    private _gpuBuffer : GPUBufferWrapper;\r\n    private _usage : GPUFlagsConstant = GPUBufferUsage.VERTEX;\r\n\r\n    get buffer(){\r\n        return this._gpuBuffer;\r\n    }\r\n\r\n    constructor( array : NumberArrayType, format:GPUVertexFormat | GPUIndexFormat,itemSize : number, normalized? : boolean){\r\n        this._array = array;\r\n        this._format = format;\r\n        this._itemSize = itemSize;\r\n        this._parseFormat();\r\n        this._normalized = normalized?normalized:this._normalized;\r\n    }\r\n\r\n    public update(){\r\n        if(this._gpuBuffer === undefined){\r\n            this._gpuBuffer = new GPUBufferWrapper(\r\n                this._usage | GPUBufferUsage.COPY_DST,\r\n                this._array);\r\n        }else{\r\n            if(this.needsUpdate){\r\n                this._gpuBuffer.update(this._array);\r\n                this.needsUpdate = false;\r\n            }\r\n        }\r\n\r\n        \r\n    }\r\n\r\n    private _parseFormat(){\r\n        this._itemSize = this._itemSize;\r\n        this._byteLength = this._array.BYTES_PER_ELEMENT;\r\n        this._count = this._array.length / this._itemSize;\r\n    }\r\n\r\n\r\n    get format(){\r\n        return this._format;\r\n    }\r\n\r\n    get array():NumberArrayType{\r\n        return this._array;\r\n    }\r\n\r\n    get count():number{\r\n        return this._count;\r\n    }\r\n\r\n    set count(v : number){\r\n        this._count = v;\r\n    }\r\n\r\n    get itemSize():number{\r\n        return this._itemSize;\r\n    }\r\n\r\n    set itemSize(v : number){\r\n        this._itemSize = v;\r\n    }\r\n\r\n    get byteLength(){\r\n        return this._byteLength;\r\n    }\r\n\r\n    get name():string{\r\n        return this._name;\r\n    }\r\n\r\n    set name(v : string){\r\n        this._name = v;\r\n    }\r\n\r\n    get needsUpdate():boolean{\r\n        return this._needsUpdate;\r\n    }\r\n\r\n    set needsUpdate(v : boolean){\r\n        this._needsUpdate = v;\r\n    }\r\n\r\n    set Usage(v : GPUFlagsConstant){\r\n        this._usage = v;\r\n    }\r\n}","import { MathUtils } from \"../math/MathUtils\";\r\nimport { BufferAttribute } from \"./BufferAttribute\";\r\nimport { AttributeShaderItem } from \"./Defines\";\r\nimport { GPUBufferWrapper } from \"./GPUBufferWrapper\";\r\n\r\nexport class BufferGeometry {\r\n    private _attributes: Map<string, BufferAttribute> = new Map();\r\n    private _indices: BufferAttribute = null;\r\n    private _drawBuffer: GPUBufferWrapper = null;\r\n\r\n    public uuid: string;\r\n\r\n    constructor() {\r\n        this.uuid = MathUtils.generateUUID();\r\n    }\r\n\r\n    public update() {\r\n        this.updateDrawBuffer();\r\n        for (const attribute of this._attributes.values()) {\r\n            attribute.update();\r\n        }\r\n\r\n        this._indices && this._indices.update();\r\n    }\r\n\r\n    public createVetexBufferLayouts() {\r\n        const bufferLayouts: Array<GPUVertexBufferLayout> = [];\r\n        let index = 0;\r\n        for (const attr of this.attributes.values()) {\r\n            const buffer = {\r\n                // 顶点长度，以字节为单位\r\n                arrayStride: attr.byteLength * attr.itemSize,\r\n                attributes: [\r\n                    {\r\n                        // 变量索引\r\n                        shaderLocation: index,\r\n                        // 偏移\r\n                        offset: 0,\r\n                        // 参数格式\r\n                        format: attr.format as GPUVertexFormat,\r\n                    },\r\n                ],\r\n            };\r\n            ++index;\r\n            bufferLayouts.push(buffer);\r\n        }\r\n        return bufferLayouts;\r\n    }\r\n\r\n    public setVertexBuffer(passEncoder: GPURenderPassEncoder,locationValues: Map<string,AttributeShaderItem>) {\r\n\r\n        for(const value of locationValues.values()){\r\n            const attr = this._attributes.get(value.name);\r\n            if(attr)\r\n                passEncoder.setVertexBuffer(value.index, attr.buffer.buffer);\r\n        }\r\n    }\r\n\r\n    public setIndex(attribute: BufferAttribute): BufferGeometry {\r\n        if (attribute.count !== this._indices?.count && this._drawBuffer) {\r\n            this._drawBuffer.destroy();\r\n            this._drawBuffer = null;\r\n        }\r\n\r\n        this._indices = attribute;\r\n        attribute.Usage = GPUBufferUsage.INDEX;\r\n        return this;\r\n    }\r\n\r\n    public setAttribute(name: string, attribute: BufferAttribute): BufferGeometry {\r\n        this._attributes.set(name, attribute);\r\n        return this;\r\n    }\r\n\r\n    public getAttribute(name: string): BufferAttribute {\r\n        return this._attributes.get(name);\r\n    }\r\n\r\n    public updateDrawBuffer() {\r\n        if (!this._drawBuffer) {\r\n            const k = this.indices ? 5 : 4;\r\n            const parameters = new Uint32Array(k);\r\n            if (this.indices) {\r\n                parameters[0] = this.indices.count; // The indexCount value\r\n                parameters[1] = 1; // The instanceCount value\r\n                parameters[2] = 0; // The firstIndex value\r\n                parameters[3] = 0; // The baseVertex value\r\n                parameters[4] = 0; // The firstInstance value\r\n            } else {\r\n                parameters[0] = this.getAttribute(\"position\").count; // The vertexCount value\r\n                parameters[1] = 1; // The instanceCount value\r\n                parameters[2] = 0; // The firstVertex value\r\n                parameters[3] = 0; // The firstInstance value\r\n            }\r\n            this._drawBuffer = new GPUBufferWrapper(GPUBufferUsage.COPY_DST | GPUBufferUsage.INDIRECT, parameters);\r\n        }\r\n    }\r\n\r\n    public get attributes() {\r\n        return this._attributes;\r\n    }\r\n\r\n    public get indices(): BufferAttribute {\r\n        return this._indices;\r\n    }\r\n\r\n    get drawBuffer(): GPUBufferWrapper {\r\n        return this._drawBuffer;\r\n    }\r\n}\r\n","import { GPUVertexFormat } from \"../Constants\";\r\n\r\n\r\nexport const BindGroupLayoutIndexInfo = {\r\n    global : 0,\r\n    material : 1,\r\n    object : 2,\r\n    custom : 3\r\n}\r\n\r\n// export const VertexBufferLayoutInfo = {\r\n// \tposition:{\r\n// \t\tbyteLength:4,\r\n// \t\titemSize:3,\r\n// \t\tformat:GPUVertexFormat.Float32x3\r\n// \t},\r\n// \tnormal:{\r\n// \t\tbyteLength:4,\r\n// \t\titemSize:3,\r\n// \t\tformat:GPUVertexFormat.Float32x3\r\n// \t},\r\n// \tuv:{\r\n// \t\tbyteLength:4,\r\n// \t\titemSize:2,\r\n// \t\tformat:GPUVertexFormat.Float32x2\r\n// \t}\r\n// };\r\n\r\n\r\n\r\n\r\nexport enum BindType{\r\n\tbuffer = 1,\r\n    storage = 2,\r\n\tsampler = 3,\r\n\ttexture = 4\r\n}\r\n\r\nexport interface ShaderItem {\r\n    name: string;\r\n    index: number;\r\n    shaderItemType:string;\r\n}\r\n\r\nexport interface AttributeShaderItem extends ShaderItem {\r\n    format:GPUVertexFormat;\r\n    itemSize:number;\r\n}\r\n\r\nexport interface BindShaderItem extends ShaderItem {\r\n    bindType:BindType;\r\n    visibility:GPUShaderStageFlags;\r\n}\r\n\r\nexport const GlobalGroupLayoutInfo = {\r\n    projectionMatrix:{\r\n        index : 0,\r\n        bindType : BindType.buffer,\r\n        visibility: GPUShaderStage.VERTEX\r\n    } as BindShaderItem,\r\n    matrixWorldInverse:{\r\n        index : 1,\r\n        bindType : BindType.buffer,\r\n        visibility: GPUShaderStage.VERTEX\r\n    } as BindShaderItem\r\n}\r\n\r\nexport const ObjectGroupLayoutInfo = {\r\n    matrixWorld:{\r\n        index : 0,\r\n        bindType : BindType.buffer,\r\n        visibility: GPUShaderStage.VERTEX\r\n    } as BindShaderItem\r\n}","import { Context } from \"./ResourceManagers\";\r\n\r\nexport class GPUBufferWrapper{\r\n\r\n    private _size : GPUSize64;\r\n    private _usage : GPUBufferUsageFlags;\r\n    public buffer : GPUBuffer;\r\n    constructor(usage: GPUBufferUsageFlags,data:any){\r\n        this._size = data.byteLength;\r\n        this._usage = usage;\r\n        this.buffer = Context.activeDevice.createBuffer( {\r\n            size:this._size,\r\n            usage: usage,\r\n            mappedAtCreation: true\r\n        } );\r\n\r\n        new data.constructor( this.buffer.getMappedRange() ).set( data );\r\n        this.buffer.unmap();\r\n    }\r\n\r\n    public update(data:any){\r\n        Context.activeDevice.queue.writeBuffer(this.buffer,0,data);\r\n    }\r\n\r\n    public destroy(){\r\n        this.buffer.destroy();\r\n    }\r\n\r\n    public get size(){\r\n        return this._size;\r\n    }\r\n\r\n    public get usage(){\r\n        return this._usage;\r\n    }\r\n}","import { Quaternion } from '../math/Quaternion';\r\nimport { Vector3 } from '../math/Vector3';\r\nimport { Matrix4 } from '../math/Matrix4';\r\nimport { Euler } from '../math/Euler';\r\nimport * as MathUtils from '../math/MathUtils';\r\nimport { Color } from '../math/Color';\r\nimport { Camera } from '../cameras/Camera';\r\n\r\nlet _object3DId = 0;\r\n\r\nconst _v1 = /*@__PURE__*/ new Vector3();\r\nconst _q1 = /*@__PURE__*/ new Quaternion();\r\nconst _m1 = /*@__PURE__*/ new Matrix4();\r\nconst _target = /*@__PURE__*/ new Vector3();\r\n\r\nconst _position = /*@__PURE__*/ new Vector3();\r\nconst _scale = /*@__PURE__*/ new Vector3();\r\nconst _quaternion = /*@__PURE__*/ new Quaternion();\r\n\r\nconst _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );\r\nconst _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );\r\nconst _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );\r\n\r\nexport class Object3D {\r\n\r\n    static DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );\r\n    static DEFAULT_MATRIX_AUTO_UPDATE = true;\r\n    static DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;\r\n\r\n    public get type(){\r\n\t\treturn \"Object3D\";\r\n    }\r\n\r\n\tpublic static Is(object:Object3D){\r\n\t\treturn object instanceof Object3D;\r\n\t}\r\n\r\n    public uuid : string;\r\n    public name : string;\r\n    public up : Vector3;\r\n\r\n    private _parent : Object3D;\r\n    private _children : Array<Object3D>;\r\n\r\n\tprivate _position = new Vector3();\r\n\tprivate _rotation = new Euler();\r\n\tprivate _scale = new Vector3(1,1,1);\r\n\tprivate _quaternion = new Quaternion();\r\n\t\r\n\tpublic matrix = new Matrix4();\r\n\tpublic matrixWorld = new Matrix4();\r\n\r\n\tpublic matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;\r\n\tpublic matrixWorldNeedsUpdate = false;\r\n\r\n\tpublic matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer\r\n\r\n\tpublic visible = true;\r\n\r\n\tpublic castShadow = false;\r\n\tpublic receiveShadow = false;\r\n\r\n\tpublic frustumCulled = true;\r\n\tpublic renderOrder = 0;\r\n\r\n\tpublic userData:any = {};\r\n\r\n\tpublic isInstancedMesh = false;\r\n\tpublic count = 0;\r\n\tpublic instanceMatrix : Matrix4;\r\n\tpublic instanceColor : Color ;\r\n\r\n\r\n\tconstructor() {\r\n\r\n\t\tObject.defineProperty( this, 'id', { value: _object3DId ++ } );\r\n\r\n\t\tthis.uuid = MathUtils.generateUUID();\r\n\r\n\t\tthis.name = '';\r\n\r\n\t\tthis._parent = null;\r\n\t\tthis._children = [];\r\n\r\n\t\tthis.up = Object3D.DEFAULT_UP.clone();\r\n\t}\r\n\r\n    onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}\r\n\r\n\tonAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}\r\n\r\n\tapplyMatrix4( matrix:Matrix4 ) {\r\n\r\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\r\n\r\n\t\tthis.matrix.premultiply( matrix );\r\n\r\n\t\tthis.matrix.decompose( this._position, this._quaternion, this._scale );\r\n\r\n\t}\r\n\r\n\tapplyQuaternion( q:Quaternion ) {\r\n\r\n\t\tthis._quaternion.premultiply( q );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetRotationFromAxisAngle( axis:Vector3, angle:number ) {\r\n\r\n\t\t// assumes axis is normalized\r\n\r\n\t\tthis._quaternion.setFromAxisAngle( axis, angle );\r\n\r\n\t}\r\n\r\n\tsetRotationFromEuler( euler:Euler ) {\r\n\r\n\t\tthis._quaternion.setFromEuler( euler );\r\n\r\n\t}\r\n\r\n\tsetRotationFromMatrix( m:Matrix4 ) {\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tthis._quaternion.setFromRotationMatrix( m );\r\n\r\n\t}\r\n\r\n\tsetRotationFromQuaternion( q:Quaternion ) {\r\n\r\n\t\t// assumes q is normalized\r\n\r\n\t\tthis._quaternion.copy( q );\r\n\r\n\t}\r\n\r\n\trotateOnAxis( axis:Vector3, angle:number ) {\r\n\r\n\t\t// rotate object on axis in object space\r\n\t\t// axis is assumed to be normalized\r\n\r\n\t\t_q1.setFromAxisAngle( axis, angle );\r\n\r\n\t\tthis._quaternion.multiply( _q1 );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\trotateOnWorldAxis( axis:Vector3, angle:number ) {\r\n\r\n\t\t// rotate object on axis in world space\r\n\t\t// axis is assumed to be normalized\r\n\t\t// method assumes no rotated parent\r\n\r\n\t\t_q1.setFromAxisAngle( axis, angle );\r\n\r\n\t\tthis._quaternion.premultiply( _q1 );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\trotateX( angle:number ) {\r\n\r\n\t\treturn this.rotateOnAxis( _xAxis, angle );\r\n\r\n\t}\r\n\r\n\trotateY( angle:number) {\r\n\r\n\t\treturn this.rotateOnAxis( _yAxis, angle );\r\n\r\n\t}\r\n\r\n\trotateZ( angle:number ) {\r\n\r\n\t\treturn this.rotateOnAxis( _zAxis, angle );\r\n\r\n\t}\r\n\r\n\ttranslateOnAxis( axis:Vector3, distance:number ) {\r\n\r\n\t\t// translate object by distance along axis in object space\r\n\t\t// axis is assumed to be normalized\r\n\r\n\t\t_v1.copy( axis ).applyQuaternion( this._quaternion );\r\n\r\n\t\tthis._position.add( _v1.multiplyScalar( distance ) );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\ttranslateX( distance:number ) {\r\n\r\n\t\treturn this.translateOnAxis( _xAxis, distance );\r\n\r\n\t}\r\n\r\n\ttranslateY( distance:number ) {\r\n\r\n\t\treturn this.translateOnAxis( _yAxis, distance );\r\n\r\n\t}\r\n\r\n\ttranslateZ( distance:number ) {\r\n\r\n\t\treturn this.translateOnAxis( _zAxis, distance );\r\n\r\n\t}\r\n\r\n\tlocalToWorld( vector:Vector3 ) {\r\n\r\n\t\tthis.updateWorldMatrix( true, false );\r\n\r\n\t\treturn vector.applyMatrix4( this.matrixWorld );\r\n\r\n\t}\r\n\r\n\tworldToLocal( vector:Vector3 ) {\r\n\r\n\t\tthis.updateWorldMatrix( true, false );\r\n\r\n\t\treturn vector.applyMatrix4( _m1.copy( this.matrixWorld ).invert() );\r\n\r\n\t}\r\n\r\n\tlookAt( target:Vector3 ) {\r\n\r\n\t\t// This method does not support objects having non-uniformly-scaled parent(s)\r\n\r\n\t\t_target.copy( target );\r\n\r\n\t\tconst parent = this.parent;\r\n\r\n\t\tthis.updateWorldMatrix( true, false );\r\n\r\n\t\t_position.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\tif ( Camera.Is(this) || this.type === \"Light\" ) {\r\n\r\n\t\t\t_m1.lookAt( _position, _target, this.up );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_m1.lookAt( _target, _position, this.up );\r\n\r\n\t\t}\r\n\r\n\t\tthis._quaternion.setFromRotationMatrix( _m1 );\r\n\r\n\t\tif ( parent ) {\r\n\r\n\t\t\t_m1.extractRotation( parent.matrixWorld );\r\n\t\t\t_q1.setFromRotationMatrix( _m1 );\r\n\t\t\tthis._quaternion.premultiply( _q1.invert() );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tadd( object:Object3D ) {\r\n\r\n\t\tif ( arguments.length > 1 ) {\r\n\r\n\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\r\n\r\n\t\t\t\tthis.add( arguments[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tif ( object === this ) {\r\n\r\n\t\t\tconsole.error( 'THREE.Object3D.add: object can\\'t be added as a child of itself.', object );\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tif ( object) {\r\n\r\n\t\t\tif ( object.parent !== null ) {\r\n\r\n\t\t\t\tobject.parent.remove( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject._parent = this;\r\n\t\t\tthis.children.push( object );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tremove( object:Object3D ) {\r\n\r\n\t\tif ( arguments.length > 1 ) {\r\n\r\n\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\r\n\r\n\t\t\t\tthis.remove( arguments[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tconst index = this.children.indexOf( object );\r\n\r\n\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\tobject._parent = null;\r\n\t\t\tthis.children.splice( index, 1 );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tremoveFromParent() {\r\n\r\n\t\tconst parent = this.parent;\r\n\r\n\t\tif ( parent !== null ) {\r\n\r\n\t\t\tparent.remove( this );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tclear() {\r\n\r\n\t\tfor ( let i = 0; i < this.children.length; i ++ ) {\r\n\r\n\t\t\tconst object = this.children[ i ];\r\n\r\n\t\t\tobject._parent = null;\r\n\r\n\t\t}\r\n\r\n\t\tthis.children.length = 0;\r\n\r\n\t\treturn this;\r\n\r\n\r\n\t}\r\n\r\n\tattach( object:Object3D ) {\r\n\r\n\t\t// adds object as a child of this, while maintaining the object's world transform\r\n\r\n\t\t// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)\r\n\r\n\t\tthis.updateWorldMatrix( true, false );\r\n\r\n\t\t_m1.copy( this.matrixWorld ).invert();\r\n\r\n\t\tif ( object.parent !== null ) {\r\n\r\n\t\t\tobject.parent.updateWorldMatrix( true, false );\r\n\r\n\t\t\t_m1.multiply( object.parent.matrixWorld );\r\n\r\n\t\t}\r\n\r\n\t\tobject.applyMatrix4( _m1 );\r\n\r\n\t\tthis.add( object );\r\n\r\n\t\tobject.updateWorldMatrix( false, true );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tgetWorldPosition( target:Vector3 ) {\r\n\r\n\t\tthis.updateWorldMatrix( true, false );\r\n\r\n\t\treturn target.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t}\r\n\r\n\tgetWorldQuaternion( target:Quaternion ) {\r\n\r\n\t\tthis.updateWorldMatrix( true, false );\r\n\r\n\t\tthis.matrixWorld.decompose( _position, target, _scale );\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n\tgetWorldScale( target:Vector3 ) {\r\n\r\n\t\tthis.updateWorldMatrix( true, false );\r\n\r\n\t\tthis.matrixWorld.decompose( _position, _quaternion, target );\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n\tgetWorldDirection( target:Vector3 ) {\r\n\r\n\t\tthis.updateWorldMatrix( true, false );\r\n\r\n\t\tconst e = this.matrixWorld.elements;\r\n\r\n\t\treturn target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();\r\n\r\n\t}\r\n\r\n\traycast( /* raycaster, intersects */ ) {}\r\n\r\n\ttraverse( callback:Function ) {\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tconst children = this.children;\r\n\r\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].traverse( callback );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttraverseVisible( callback:Function ) {\r\n\r\n\t\tif ( this.visible === false ) return;\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tconst children = this.children;\r\n\r\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].traverseVisible( callback );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttraverseAncestors( callback:Function ) {\r\n\r\n\t\tconst parent = this.parent;\r\n\r\n\t\tif ( parent !== null ) {\r\n\r\n\t\t\tcallback( parent );\r\n\r\n\t\t\tparent.traverseAncestors( callback );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateMatrix() {\r\n\r\n\t\tthis.matrix.compose( this._position, this._quaternion, this._scale );\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = true;\r\n\r\n\t}\r\n\r\n\tupdateMatrixWorld() {\r\n\r\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\r\n\r\n\t\tif ( this.matrixWorldNeedsUpdate ) {\r\n\r\n\t\t\tif ( this.parent === null ) {\r\n\r\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\t// update children\r\n\r\n\t\tconst children = this.children;\r\n\r\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst child = children[ i ];\r\n\r\n\t\t\tif ( child.matrixWorldAutoUpdate === true ) {\r\n\r\n\t\t\t\tchild.updateMatrixWorld();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateWorldMatrix( updateParents = false, updateChildren = false ) {\r\n\r\n\t\tconst parent = this.parent;\r\n\r\n\t\tif ( updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true ) {\r\n\r\n\t\t\tparent.updateWorldMatrix( true, false );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\r\n\r\n\t\tif ( this.parent === null ) {\r\n\r\n\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t}\r\n\r\n\t\t// update children\r\n\r\n\t\tif ( updateChildren === true ) {\r\n\r\n\t\t\tconst children = this.children;\r\n\r\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst child = children[ i ];\r\n\r\n\t\t\t\tif ( child.matrixWorldAutoUpdate === true ) {\r\n\r\n\t\t\t\t\tchild.updateWorldMatrix( false, true );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tclone( recursive = false ) {\r\n\r\n\t\treturn new Object3D().copy( this, recursive );\r\n\r\n\t}\r\n\r\n\tcopy( source:Object3D, recursive = true ) {\r\n\r\n\t\tthis.name = source.name;\r\n\r\n\t\tthis.up.copy( source.up );\r\n\r\n\t\tthis._position.copy( source._position );\r\n\t\tthis._rotation.order = source._rotation.order;\r\n\t\tthis._quaternion.copy( source._quaternion );\r\n\t\tthis._scale.copy( source._scale );\r\n\r\n\t\tthis.matrix.copy( source.matrix );\r\n\t\tthis.matrixWorld.copy( source.matrixWorld );\r\n\r\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\r\n\r\n\t\tthis.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;\r\n\r\n\t\tthis.visible = source.visible;\r\n\r\n\t\tthis.castShadow = source.castShadow;\r\n\t\tthis.receiveShadow = source.receiveShadow;\r\n\r\n\t\tthis.frustumCulled = source.frustumCulled;\r\n\t\tthis.renderOrder = source.renderOrder;\r\n\r\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\r\n\r\n\t\tif ( recursive === true ) {\r\n\r\n\t\t\tfor ( let i = 0; i < source.children.length; i ++ ) {\r\n\r\n\t\t\t\tconst child = source.children[ i ];\r\n\t\t\t\tthis.add( child.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n    public get parent(){\r\n        return this._parent;\r\n    }\r\n\r\n    public get children(){\r\n        return this._children;\r\n    }\r\n\t\r\n\tpublic set position(v:Vector3){\r\n\t\tthis._position.copy(v);\r\n\t}\r\n\r\n\tpublic get position(){\r\n\t\treturn this._position;\r\n\t}\r\n\r\n\tpublic set scale(v:Vector3){\r\n\t\tthis._scale.copy(v);\r\n\t}\r\n\r\n\tpublic get scale(){\r\n\t\treturn this._scale;\r\n\t}\r\n\r\n\tpublic get quaternion(){\r\n\t\treturn this._quaternion;\r\n\t}\r\n\r\n\tpublic set quaternion(v:Quaternion){\r\n\t\tthis._quaternion.copy(v);\r\n\t\tthis._rotation.setFromQuaternion( v, undefined );\r\n\t}\r\n\r\n\tpublic get rotation(){\r\n\t\treturn this._rotation;\r\n\t}\r\n\r\n\tpublic set rotation(v:Euler){\r\n\t\tthis._rotation.copy(v);\r\n\t\tthis._quaternion.setFromEuler( v );\r\n\t}\r\n\r\n}","import { Camera } from \"../cameras/Camera\";\r\nimport { GPUBlendFactor, GPUCompareFunction, GPUCullMode, GPUPrimitiveTopology, GPUTextureFormat } from \"../Constants\";\r\nimport { Material } from \"../materials/Material\";\r\nimport { WebGPURenderer } from \"../renderers/WebGPURenderer\";\r\nimport { BindGroupLayoutIndexInfo, GlobalGroupLayoutInfo, ObjectGroupLayoutInfo } from \"./Defines\";\r\nimport { RenderableObject } from \"./RenderableObject\";\r\nimport { Cache, Context } from \"./ResourceManagers\"\r\n\r\nexport class Pipleline {\r\n    private _material: Material;\r\n    private _pipeline: GPURenderPipeline;\r\n\r\n    private _bindGroupLayouts: Array<GPUBindGroupLayout> = [];\r\n    private _vertexBufferLayouts: Array<GPUVertexBufferLayout> = [];\r\n\r\n    private _cameraBindGroups: any = {};\r\n    private _materialBindGroup: GPUBindGroup;\r\n    private _objectBindGroups: any = {};\r\n\r\n    public needsCompile = true;\r\n\r\n    constructor(material: Material) {\r\n        this._material = material;\r\n\r\n        Cache.add(\"pipelineObjectBindGroup\",this._objectBindGroups);\r\n    }\r\n\r\n    public compilePipeline(renderer: WebGPURenderer) {\r\n        if (!this.needsCompile) return;\r\n\r\n        this._beforeCompile();\r\n        this._compile(renderer);\r\n\r\n        this.needsCompile = false;\r\n    }\r\n\r\n    public bindCommonUniform(passEncoder: GPURenderPassEncoder,camera:Camera) {\r\n\r\n        passEncoder.setBindGroup(0, this._cameraBindGroups[camera.uuid]);\r\n        passEncoder.setBindGroup(1, this._materialBindGroup);\r\n    }\r\n\r\n    public bindObjectUnform(passEncoder: GPURenderPassEncoder,object:RenderableObject){\r\n        passEncoder.setBindGroup(2, this._objectBindGroups[object.uuid]);\r\n    }\r\n\r\n    private _compile(renderer: WebGPURenderer) {\r\n        const device = renderer.device;\r\n        this.material.shader.recreate();\r\n\r\n        this._pipeline = device.createRenderPipeline({\r\n            layout: device.createPipelineLayout({\r\n                bindGroupLayouts: [...this._bindGroupLayouts],\r\n            }),\r\n            vertex: {\r\n                module: device.createShaderModule({\r\n                    code: this.material.shader.vertexShaderCode,\r\n                }),\r\n                entryPoint: \"main\",\r\n                buffers: this._vertexBufferLayouts,\r\n            },\r\n            fragment: {\r\n                module: device.createShaderModule({\r\n                    code: this.material.shader.fragmentShaderCode,\r\n                }),\r\n                entryPoint: \"main\",\r\n                targets: [\r\n                    {\r\n                        format: renderer.presentationFormat,\r\n                        blend: {\r\n                            color: {\r\n                                srcFactor: GPUBlendFactor.SrcAlpha,\r\n                                dstFactor: GPUBlendFactor.OneMinusSrcAlpha,\r\n                            },\r\n                            alpha: {\r\n                                srcFactor: GPUBlendFactor.One,\r\n                                dstFactor: GPUBlendFactor.OneMinusSrcAlpha,\r\n                            },\r\n                        },\r\n                    },\r\n                ],\r\n            },\r\n            primitive: {\r\n                topology: GPUPrimitiveTopology.TriangleList,\r\n                cullMode: GPUCullMode.Back,\r\n            },\r\n            multisample: {\r\n                count: renderer.sampleCount,\r\n            },\r\n            depthStencil: {\r\n                depthWriteEnabled: true,\r\n                depthCompare: GPUCompareFunction.Less,\r\n                format: GPUTextureFormat.Depth24Plus,\r\n            },\r\n        });\r\n    }\r\n\r\n    /****************************create layout start ***********************************/\r\n    private _createVertexBufferLayouts() {\r\n        this._vertexBufferLayouts.length = 0;\r\n\r\n        for (const value of this._material.shaderOptions.attributeValues.values()) {\r\n\r\n            this._vertexBufferLayouts.push({\r\n                arrayStride:value.itemSize,\r\n                attributes: [\r\n                    {\r\n                        shaderLocation: value.index,\r\n                        offset: 0,\r\n                        format: value.format,\r\n                    },\r\n                ],\r\n            });\r\n            \r\n        }\r\n    }\r\n\r\n    private _createGlobalBindLayout() {\r\n        const entries = new Array<GPUBindGroupLayoutEntry>();\r\n        for (const key in GlobalGroupLayoutInfo) {\r\n            entries.push({\r\n                binding: (GlobalGroupLayoutInfo as any)[key].index,\r\n                visibility: (GlobalGroupLayoutInfo as any)[key].visibility,\r\n                buffer: {\r\n                    type: \"uniform\",\r\n                },\r\n            });\r\n        }\r\n\r\n        this._bindGroupLayouts.push(\r\n            Context.activeDevice.createBindGroupLayout({\r\n                entries: entries,\r\n            })\r\n        );\r\n    }\r\n\r\n    private _createMaterialBindLayout() {\r\n        const entries = this.material.getBindLayout();\r\n        this._bindGroupLayouts.push(\r\n            Context.activeDevice.createBindGroupLayout({\r\n                entries: entries,\r\n            })\r\n        );\r\n    }\r\n\r\n    private _createObjectBindLayout() {\r\n        const entries = new Array<GPUBindGroupLayoutEntry>();\r\n        for (const key in ObjectGroupLayoutInfo) {\r\n            entries.push({\r\n                binding: (ObjectGroupLayoutInfo as any)[key].index,\r\n                visibility: (ObjectGroupLayoutInfo as any)[key].visibility,\r\n                buffer: {\r\n                    type: \"uniform\",\r\n                },\r\n            });\r\n        }\r\n        this._bindGroupLayouts.push(\r\n            Context.activeDevice.createBindGroupLayout({\r\n                entries: entries,\r\n            })\r\n        );\r\n    }\r\n\r\n    private _createBindLayouts() {\r\n        this._bindGroupLayouts.length = 0;\r\n        this._createGlobalBindLayout(); //Layout 0\r\n        this._createMaterialBindLayout(); //Layout 1\r\n        this._createObjectBindLayout(); //Layout 2\r\n    }\r\n\r\n    /****************************create layout end ***********************************/\r\n\r\n    /****************************create group start ***********************************/\r\n    private _createGlobalBindGroup(camera: Camera) {\r\n        if (this._cameraBindGroups[camera.uuid]) return;\r\n        const group = new Array<GPUBindGroupEntry>();\r\n        for (const key in GlobalGroupLayoutInfo) {\r\n            group.push({\r\n                binding: (GlobalGroupLayoutInfo as any)[key].index,\r\n                resource: {\r\n                    buffer: camera.uniforms.get(key).buffer,\r\n                },\r\n            });\r\n        }\r\n\r\n        this._cameraBindGroups[camera.uuid] = Context.activeDevice.createBindGroup({\r\n            layout: this.pipeline.getBindGroupLayout(BindGroupLayoutIndexInfo.global),\r\n            entries: group,\r\n        });\r\n    }\r\n\r\n    private _createMaterialBindGroup() {\r\n        if (!this.material.needsCreateBindGroup) return;\r\n        const group = this.material.getBindGroup();\r\n\r\n        this._materialBindGroup = Context.activeDevice.createBindGroup({\r\n            layout: this.pipeline.getBindGroupLayout(BindGroupLayoutIndexInfo.material),\r\n            entries: group,\r\n        });\r\n        this.material.needsCreateBindGroup = false;\r\n    }\r\n\r\n    public createObjectBindGroup(object: RenderableObject){\r\n        if (this._objectBindGroups[object.uuid]) {\r\n            return;\r\n        }\r\n\r\n        const group = new Array<GPUBindGroupEntry>();\r\n        for (const key in ObjectGroupLayoutInfo) {\r\n            group.push({\r\n                binding: (ObjectGroupLayoutInfo as any)[key].index,\r\n                resource: {\r\n                    buffer: object.uniforms.get(key).buffer,\r\n                },\r\n            });\r\n        }\r\n        this._objectBindGroups[object.uuid] = Context.activeDevice.createBindGroup({\r\n            layout: this.pipeline.getBindGroupLayout(BindGroupLayoutIndexInfo.object),\r\n            entries: group,\r\n        });\r\n\r\n    }\r\n\r\n    public createBindGroups(camera: Camera) {\r\n        this._createGlobalBindGroup(camera); //Group 0\r\n        this._createMaterialBindGroup(); //Group 1\r\n        //this._createObjectsBindGroup(objects); //Group 2\r\n    }\r\n\r\n    /****************************create group end ***********************************/\r\n    private _beforeCompile() {\r\n        this._createBindLayouts();\r\n        this._createVertexBufferLayouts();\r\n    }\r\n\r\n    public get pipeline() {\r\n        return this._pipeline;\r\n    }\r\n\r\n    public get material() {\r\n        return this._material;\r\n    }\r\n}","import { BufferGeometry } from \"./BufferGeometry\";\r\nimport { Material } from \"../materials/Material\";\r\nimport { Object3D } from \"./Object3D\";\r\nimport { BindBuffer } from \"./binds/BindBuffer\";\r\nimport { IdentifyMatrix4 } from \"../utils/TMPValues\";\r\n\r\nconst u_modelTranform = \"matrixWorld\";\r\nexport class RenderableObject extends Object3D {\r\n    public get type() {\r\n        return \"RenderableObject\";\r\n    }\r\n\r\n    public static Is(object: Object3D) {\r\n        return object instanceof RenderableObject;\r\n    }\r\n\r\n    protected _geometry: BufferGeometry;\r\n    protected _material: Material;\r\n\r\n    private _pipeline: GPURenderPipeline;\r\n    private _uniforms: Map<string, BindBuffer> = new Map();\r\n\r\n    constructor(geometry: BufferGeometry, material: Material) {\r\n        super();\r\n        this._geometry = geometry;\r\n        this._material = material;\r\n\r\n        this._initInitialUniform();\r\n    }\r\n\r\n    public update() {\r\n\r\n        this.updateMatrixWorld();\r\n\r\n        this._updateUniformValue();\r\n    }\r\n\r\n\r\n    public override updateMatrixWorld() {\r\n        const needsUpdate = this.matrixWorldNeedsUpdate;\r\n        super.updateMatrixWorld();\r\n\r\n        if (needsUpdate) {\r\n            this._uniforms.get(u_modelTranform).data = this.matrixWorld.toArray();\r\n        }\r\n    }\r\n\r\n    private _initInitialUniform() {\r\n\r\n        const tranformUniform = new BindBuffer(u_modelTranform, IdentifyMatrix4.toArray());\r\n        this._uniforms.set(u_modelTranform, tranformUniform);\r\n    }\r\n\r\n    private _updateUniformValue() {\r\n        for (const uniform of this._uniforms.values()) {\r\n            uniform.update();\r\n        }\r\n    }\r\n\r\n    public get pipeline() {\r\n        return this._pipeline;\r\n    }\r\n\r\n    get geometry() {\r\n        return this._geometry;\r\n    }\r\n\r\n    get material() {\r\n        return this._material;\r\n    }\r\n\r\n    get uniforms(){\r\n        return this._uniforms;\r\n    }\r\n\r\n}\r\n","import { GlobalGroupLayoutInfo, ObjectGroupLayoutInfo } from \"./Defines\";\r\n\r\nexport class Cache {\r\n\r\n\tpublic static enabled = false;\r\n\r\n\tstatic caches:any = {};\r\n\r\n\tpublic static add ( key:string, obj:any ) {\r\n\r\n\t\tif ( this.enabled === false ) return;\r\n\r\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\r\n\r\n\t\tthis.caches[ key ] = obj;\r\n\r\n\t}\r\n\r\n\tpublic static get ( key:string ) {\r\n\r\n\t\tif ( this.enabled === false ) return;\r\n\r\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\r\n\r\n\t\treturn this.caches[ key ];\r\n\r\n\t}\r\n\r\n\tpublic static remove ( key:string ) {\r\n\r\n\t\tdelete this.caches[ key ];\r\n\r\n\t}\r\n\r\n\tpublic static clear () {\r\n\r\n\t\tthis.caches = {};\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class Context{\r\n    private static _activeDevice:GPUDevice;\r\n    public static get activeDevice(): GPUDevice{\r\n        return Context._activeDevice;\r\n    }\r\n\r\n    public static set activeDevice(v:GPUDevice) {\r\n\r\n        Context._activeDevice = v;\r\n    }\r\n}\r\n\r\nexport class DelayDestroyer{\r\n\r\n\tpublic static delayTime = 5000;\r\n\r\n\tpublic static destroy(garbage:any,destroyFunc:(g:any)=>void,time = DelayDestroyer.delayTime){\r\n\t\tsetTimeout(() => {\r\n\t\t\tdestroyFunc(garbage);\r\n\t\t}, time);\r\n\t}\r\n}","import { Object3D } from \"./Object3D\";\r\n\r\nexport class Scene extends Object3D{\r\n\r\n    constructor(){\r\n        super();\r\n    }\r\n}","import { NumberArrayType } from \"../../Constants\";\r\nimport { BindType } from \"../Defines\";\r\nimport { GPUBufferWrapper } from \"../GPUBufferWrapper\";\r\nimport { DelayDestroyer } from \"../ResourceManagers\";\r\nimport { BindValue } from \"./BindValue\";\r\n\r\nexport class BindBuffer extends BindValue{\r\n    private _buffer : GPUBufferWrapper;\r\n    private _data : NumberArrayType;\r\n\r\n    constructor(name:string,data:NumberArrayType){\r\n        super(name);\r\n        this._buffer = new GPUBufferWrapper(GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,data);\r\n        this._data = data;\r\n    }\r\n\r\n    public override destroy(): void {\r\n        this._buffer.destroy();\r\n    }\r\n\r\n    public override get type(){\r\n        return BindType.buffer;\r\n    }\r\n    \r\n    public set data(v:NumberArrayType){\r\n        this._needsUpdate = true;\r\n        this._data = v;\r\n    }\r\n\r\n    public override update(){\r\n        if(this._needsUpdate){\r\n            if(this._data.byteLength!==this._buffer.size){\r\n                DelayDestroyer.destroy(this._buffer,(data)=>{\r\n                    data.destroy();\r\n                });\r\n                this._buffer = new GPUBufferWrapper(GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,this._data);\r\n            }else{\r\n                this._buffer.update(this._data);\r\n            }\r\n\r\n            this._needsUpdate = false;\r\n        }\r\n    }\r\n\r\n    public get buffer(){\r\n        return this._buffer.buffer;\r\n    }\r\n}","import { BindType } from \"../Defines\";\r\nimport { Context } from \"../ResourceManagers\";\r\nimport { BindValue } from \"./BindValue\";\r\n\r\nexport class BindSampler extends BindValue{\r\n    private _sampler : GPUSampler;\r\n\r\n    constructor(name:string){\r\n        super(name);\r\n\r\n        this._sampler = Context.activeDevice.createSampler({\r\n            magFilter: 'linear',\r\n            minFilter: 'linear',\r\n        });\r\n    }\r\n\r\n    public override get type(){\r\n        return BindType.sampler;\r\n    }\r\n\r\n    public get sampler(){\r\n        return this._sampler;\r\n    }\r\n}","import { Texture } from \"../../textures/Texture\";\r\nimport { BindType } from \"../Defines\";\r\nimport { Context, DelayDestroyer } from \"../ResourceManagers\";\r\nimport { BindValue } from \"./BindValue\";\r\n\r\nexport class BindTexture extends BindValue {\r\n    private _texture: Texture;\r\n    private _textureBuffer: GPUTexture;\r\n\r\n    public changed = false;\r\n\r\n    constructor(name: string, texture: Texture) {\r\n        super(name);\r\n\r\n        this._texture = texture;\r\n        createImageBitmap(this._texture.image).then((imageBitmap: ImageBitmap) => {\r\n            this._textureBuffer = Context.activeDevice.createTexture({\r\n                size: [imageBitmap.width, imageBitmap.height, 1],\r\n                format: \"rgba8unorm\",\r\n                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\r\n            });\r\n\r\n            Context.activeDevice.queue.copyExternalImageToTexture(\r\n                { source: imageBitmap },\r\n                { texture: this._textureBuffer },\r\n                [imageBitmap.width, imageBitmap.height]\r\n            );\r\n        });\r\n        this._needsUpdate = false;\r\n    }\r\n\r\n    public override update() {\r\n        if (this._needsUpdate) {\r\n            createImageBitmap(this._texture.image).then((imageBitmap: ImageBitmap) => {\r\n                DelayDestroyer.destroy(this._textureBuffer,(data)=>{\r\n                    data.destroy();\r\n                });\r\n                this._textureBuffer = Context.activeDevice.createTexture({\r\n                    size: [imageBitmap.width, imageBitmap.height, 1],\r\n                    format: \"rgba8unorm\",\r\n                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\r\n                });\r\n    \r\n                Context.activeDevice.queue.copyExternalImageToTexture(\r\n                    { source: imageBitmap },\r\n                    { texture: this._textureBuffer },\r\n                    [imageBitmap.width, imageBitmap.height]\r\n                );\r\n                this.changed = true;\r\n            });\r\n\r\n            this._needsUpdate = false;\r\n        }\r\n    }\r\n\r\n    public override destroy(): void {\r\n        DelayDestroyer.destroy(this._textureBuffer,(data)=>{\r\n            data.destroy();\r\n        });\r\n    }\r\n\r\n    public set texture(v: Texture) {\r\n        if (v !== this._texture) {\r\n            this._needsUpdate = true;\r\n            this._texture = v;\r\n        }\r\n    }\r\n\r\n    public get texture() {\r\n        return this._texture;\r\n    }\r\n\r\n    public override get type() {\r\n        return BindType.sampler;\r\n    }\r\n\r\n    public get textureBuffer() {\r\n        return this._textureBuffer;\r\n    }\r\n}\r\n","import { BindType } from \"../Defines\";\r\n\r\nexport abstract class BindValue{\r\n    private _name : string;\r\n\r\n    protected _needsUpdate = true;\r\n\r\n    constructor(name:string){\r\n        this._name = name;\r\n    }\r\n\r\n    public abstract get type():BindType;\r\n\r\n    public destroy(){}\r\n\r\n    public update(){}\r\n\r\n    public get name(){\r\n        return this._name;\r\n    }\r\n}","import { GPUIndexFormat, GPUVertexFormat } from \"../Constants\";\r\nimport { BufferAttribute } from \"../core/BufferAttribute\";\r\nimport { BufferGeometry } from \"../core/BufferGeometry\";\r\nimport { Vector3 } from \"../math/Vector3\";\r\n\r\n\r\nexport class BoxGeometry extends BufferGeometry {\r\n\r\n    public width: number;\r\n    public height: number;\r\n    public depth: number;\r\n    public widthSegments: number;\r\n    public heightSegments: number;\r\n    public depthSegments: number;\r\n\r\n\tconstructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {\r\n\r\n\t\tsuper();\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n        this.depth = depth;\r\n        this.widthSegments = widthSegments;\r\n        this.heightSegments = heightSegments;\r\n        this.depthSegments = depthSegments;\r\n\r\n\t\t// segments\r\n\r\n\t\twidthSegments = Math.floor( widthSegments );\r\n\t\theightSegments = Math.floor( heightSegments );\r\n\t\tdepthSegments = Math.floor( depthSegments );\r\n\r\n\t\t// buffers\r\n\r\n\t\tconst indices:Array<number> = [];\r\n\t\tconst vertices:Array<number>  = [];\r\n\t\tconst normals:Array<number>  = [];\r\n\t\tconst uvs:Array<number>  = [];\r\n\r\n\t\t// helper variables\r\n\r\n\t\tlet numberOfVertices = 0;\r\n\r\n\t\tconst buildPlane = ( u:string, v:string, w:string, \r\n            udir:number, vdir:number, \r\n            width:number, height:number, depth:number, \r\n            gridX:number, gridY:number ) => {\r\n\r\n\t\t\tconst segmentWidth = width / gridX;\r\n\t\t\tconst segmentHeight = height / gridY;\r\n\r\n\t\t\tconst widthHalf = width / 2;\r\n\t\t\tconst heightHalf = height / 2;\r\n\t\t\tconst depthHalf = depth / 2;\r\n\r\n\t\t\tconst gridX1 = gridX + 1;\r\n\t\t\tconst gridY1 = gridY + 1;\r\n\r\n\t\t\tlet vertexCounter = 0;\r\n\r\n\t\t\tconst vector = new Vector3();\r\n\r\n\t\t\t// generate vertices, normals and uvs\r\n\r\n\t\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n\t\t\t\tconst y = iy * segmentHeight - heightHalf;\r\n\r\n\t\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\r\n                    const obj = vector as any;\r\n\t\t\t\t\tconst x = ix * segmentWidth - widthHalf;\r\n\r\n\t\t\t\t\t// set values to correct vector component\r\n\r\n                    obj[ u ] = x * udir;\r\n\t\t\t\t\tobj[ v ] = y * vdir;\r\n\t\t\t\t\tobj[ w ] = depthHalf;\r\n\r\n\t\t\t\t\t// now apply vector to vertex buffer\r\n\r\n\t\t\t\t\tvertices.push( vector.x, vector.y, vector.z );\r\n\r\n\t\t\t\t\t// set values to correct vector component\r\n\r\n                    obj[ u ] = 0;\r\n\t\t\t\t\tobj[ v ] = 0;\r\n\t\t\t\t\tobj[ w ] = depth > 0 ? 1 : - 1;\r\n\r\n\t\t\t\t\t// now apply vector to normal buffer\r\n\r\n\t\t\t\t\tnormals.push( vector.x, vector.y, vector.z );\r\n\r\n\t\t\t\t\t// uvs\r\n\r\n\t\t\t\t\tuvs.push( ix / gridX );\r\n\t\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\r\n\r\n\t\t\t\t\t// counters\r\n\r\n\t\t\t\t\tvertexCounter += 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// indices\r\n\r\n\t\t\t// 1. you need three indices to draw a single face\r\n\t\t\t// 2. a single segment consists of two faces\r\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\r\n\r\n\t\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\r\n\r\n\t\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\r\n\r\n\t\t\t\t\tconst a = numberOfVertices + ix + gridX1 * iy;\r\n\t\t\t\t\tconst b = numberOfVertices + ix + gridX1 * ( iy + 1 );\r\n\t\t\t\t\tconst c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\t\tconst d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\r\n\r\n\t\t\t\t\t// faces\r\n\r\n\t\t\t\t\tindices.push( a, b, d );\r\n\t\t\t\t\tindices.push( b, c, d );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// add a group to the geometry. this will ensure multi material support\r\n\r\n\t\t\t//this.addGroup( groupStart, groupCount, materialIndex );\r\n\r\n\t\t\t// calculate new start value for groups\r\n\r\n\t\t\t// update total number of vertices\r\n\r\n\t\t\tnumberOfVertices += vertexCounter;\r\n\r\n\t\t}\r\n\t\t// build each side of the box geometry\r\n\r\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments ); // px\r\n\t\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments ); // nx\r\n\t\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments ); // py\r\n\t\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments ); // ny\r\n\t\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments ); // pz\r\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments ); // nz\r\n\r\n        // build geometry\r\n        const indicesAttr = new BufferAttribute(new Uint32Array(indices),GPUIndexFormat.Uint32,1);\r\n        this.setIndex( indicesAttr );\r\n        this.setAttribute( 'position', new BufferAttribute( new Float32Array(vertices),GPUVertexFormat.Float32x3, 3 ) );\r\n        this.setAttribute( 'normal', new BufferAttribute( new Float32Array(normals),GPUVertexFormat.Float32x3, 3 ) );\r\n        this.setAttribute( 'uv', new BufferAttribute( new Float32Array(uvs),GPUVertexFormat.Float32x2, 2 ) );\r\n        \r\n\t}\r\n}\r\n","import { BufferGeometry } from '../core/BufferGeometry';\r\nimport { BufferAttribute } from '../core/BufferAttribute';\r\nimport { GPUIndexFormat, GPUVertexFormat } from '../Constants';\r\n\r\nclass PlaneGeometry extends BufferGeometry {\r\n\r\n    public width: number;\r\n    public height: number;\r\n    public widthSegments: number;\r\n    public heightSegments: number;\r\n\r\n\tconstructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {\r\n        super();\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n        this.widthSegments = widthSegments;\r\n        this.heightSegments = heightSegments;\r\n\t\r\n\r\n\t\tconst width_half = width / 2;\r\n\t\tconst height_half = height / 2;\r\n\r\n\t\tconst gridX = Math.floor( widthSegments );\r\n\t\tconst gridY = Math.floor( heightSegments );\r\n\r\n\t\tconst gridX1 = gridX + 1;\r\n\t\tconst gridY1 = gridY + 1;\r\n\r\n\t\tconst segment_width = width / gridX;\r\n\t\tconst segment_height = height / gridY;\r\n\r\n\t\t//\r\n\r\n\t\tconst indices = [];\r\n\t\tconst vertices = [];\r\n\t\tconst normals = [];\r\n\t\tconst uvs = [];\r\n\r\n\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n\t\t\tconst y = iy * segment_height - height_half;\r\n\r\n\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n\t\t\t\tconst x = ix * segment_width - width_half;\r\n\r\n\t\t\t\tvertices.push( x, - y, 0 );\r\n\r\n\t\t\t\tnormals.push( 0, 0, 1 );\r\n\r\n\t\t\t\tuvs.push( ix / gridX );\r\n\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\r\n\r\n\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\r\n\r\n\t\t\t\tconst a = ix + gridX1 * iy;\r\n\t\t\t\tconst b = ix + gridX1 * ( iy + 1 );\r\n\t\t\t\tconst c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\tconst d = ( ix + 1 ) + gridX1 * iy;\r\n\r\n\t\t\t\tindices.push( a, b, d );\r\n\t\t\t\tindices.push( b, c, d );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t    const indicesAttr = new BufferAttribute(new Uint32Array(indices),GPUIndexFormat.Uint32,1);\r\n        this.setIndex( indicesAttr );\r\n        this.setAttribute( 'position', new BufferAttribute( new Float32Array(vertices),GPUVertexFormat.Float32x3, 3 ) );\r\n        this.setAttribute( 'normal', new BufferAttribute( new Float32Array(normals),GPUVertexFormat.Float32x3, 3 ) );\r\n        this.setAttribute( 'uv', new BufferAttribute( new Float32Array(uvs),GPUVertexFormat.Float32x2, 2 ) );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { PlaneGeometry };\r\n","import { GPUIndexFormat, GPUVertexFormat } from \"../Constants\";\r\nimport { BufferAttribute } from \"../core/BufferAttribute\";\r\nimport { BufferGeometry } from \"../core/BufferGeometry\";\r\nimport { Vector3 } from \"../math/Vector3\";\r\n\r\n\r\nexport class SphereGeometry extends BufferGeometry {\r\n\r\n    public radius: number;\r\n    public widthSegments: number;\r\n    public heightSegments: number;\r\n    public phiStart: number;\r\n    public phiLength: number;\r\n    public thetaStart: number;\r\n    public thetaLength: number;\r\n\r\n\tconstructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {\r\n\r\n\t\tsuper();\r\n\r\n\r\n        this.radius = radius,\r\n        this.widthSegments = widthSegments,\r\n        this.heightSegments = heightSegments,\r\n        this.phiStart = phiStart,\r\n        this.phiLength = phiLength,\r\n        this.thetaStart = thetaStart,\r\n        this.thetaLength = thetaLength\r\n\r\n\r\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) );\r\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) );\r\n\r\n\t\tconst thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );\r\n\r\n\t\tlet index = 0;\r\n\t\tconst grid = [];\r\n\r\n\t\tconst vertex = new Vector3();\r\n\t\tconst normal = new Vector3();\r\n\r\n\t\t// buffers\r\n\r\n\t\tconst indices = [];\r\n\t\tconst vertices = [];\r\n\t\tconst normals = [];\r\n\t\tconst uvs = [];\r\n\r\n\t\t// generate vertices, normals and uvs\r\n\r\n\t\tfor ( let iy = 0; iy <= heightSegments; iy ++ ) {\r\n\r\n\t\t\tconst verticesRow = [];\r\n\r\n\t\t\tconst v = iy / heightSegments;\r\n\r\n\t\t\t// special case for the poles\r\n\r\n\t\t\tlet uOffset = 0;\r\n\r\n\t\t\tif ( iy === 0 && thetaStart === 0 ) {\r\n\r\n\t\t\t\tuOffset = 0.5 / widthSegments;\r\n\r\n\t\t\t} else if ( iy === heightSegments && thetaEnd === Math.PI ) {\r\n\r\n\t\t\t\tuOffset = - 0.5 / widthSegments;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( let ix = 0; ix <= widthSegments; ix ++ ) {\r\n\r\n\t\t\t\tconst u = ix / widthSegments;\r\n\r\n\t\t\t\t// vertex\r\n\r\n\t\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\r\n\t\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\r\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t\t// normal\r\n\r\n\t\t\t\tnormal.copy( vertex ).normalize();\r\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\t\t// uv\r\n\r\n\t\t\t\tuvs.push( u + uOffset, 1 - v );\r\n\r\n\t\t\t\tverticesRow.push( index ++ );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgrid.push( verticesRow );\r\n\r\n\t\t}\r\n\r\n\t\t// indices\r\n\r\n\t\tfor ( let iy = 0; iy < heightSegments; iy ++ ) {\r\n\r\n\t\t\tfor ( let ix = 0; ix < widthSegments; ix ++ ) {\r\n\r\n\t\t\t\tconst a = grid[ iy ][ ix + 1 ];\r\n\t\t\t\tconst b = grid[ iy ][ ix ];\r\n\t\t\t\tconst c = grid[ iy + 1 ][ ix ];\r\n\t\t\t\tconst d = grid[ iy + 1 ][ ix + 1 ];\r\n\r\n\t\t\t\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\r\n\t\t\t\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// build geometry\r\n        const indicesAttr = new BufferAttribute(new Uint32Array(indices),GPUIndexFormat.Uint32,1);\r\n        this.setIndex( indicesAttr );\r\n        this.setAttribute( 'position', new BufferAttribute( new Float32Array(vertices),GPUVertexFormat.Float32x3, 3 ) );\r\n        this.setAttribute( 'normal', new BufferAttribute( new Float32Array(normals),GPUVertexFormat.Float32x3, 3 ) );\r\n        this.setAttribute( 'uv', new BufferAttribute( new Float32Array(uvs),GPUVertexFormat.Float32x2, 2 ) );\r\n\r\n\t}\r\n}\r\n","import { Light } from './Light';\r\nimport { BindBuffer } from '../core/binds/BindBuffer';\r\nimport *  as TMPValues from '../utils/TMPValues';\r\nimport { Color } from '../math/Color';\r\nimport { Object3D } from '../core/Object3D';\r\n\r\n\r\nclass DirectionalLight extends Light {\r\n\r\n\tpublic get type(){\r\n\t\treturn \"DirectionalLight\";\r\n    }\r\n\r\n\tpublic static Is(object:Object3D){\r\n\t\treturn object instanceof DirectionalLight;\r\n\t}\r\n\r\n\tprivate _target = new Object3D();\r\n\r\n\tprivate _uniform: BindBuffer;\r\n\r\n\tconstructor( color:Color, intensity = 1 ) {\r\n\r\n\t\tsuper( color, intensity );\r\n\r\n\t\tthis.position.copy( Object3D.DEFAULT_UP );\r\n\t\tthis.updateMatrix();\r\n\r\n\t\t//this.shadow = new DirectionalLightShadow();\r\n\r\n\t\tconst arrayBuffer = new Float32Array(6);\r\n\t\tarrayBuffer.set(this.color.toArray());\r\n\r\n\t\tconst normal = TMPValues.Vector0.subVectors(this._target.position,this.position);\r\n\t\tarrayBuffer.set(normal.toArray(),3);\r\n\r\n\t\tthis._uniform = new BindBuffer(\"color\",arrayBuffer);\r\n\t\t\r\n\t}\r\n\r\n\tpublic get uniform(){\r\n\t\treturn this._uniform;\r\n\t}\r\n\r\n\tpublic set target(v:Object3D){\r\n\t\tthis._target = v;\r\n\t}\r\n\r\n\tpublic get target(){\r\n\t\treturn this._target;\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\t//this.shadow.dispose();\r\n\r\n\t}\r\n\r\n\tcopy( source:DirectionalLight ) {\r\n\r\n\t\tsuper.copy( source );\r\n\r\n\t\tthis._target = source._target.clone();\r\n\t\t//this.shadow = source.shadow.clone();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { DirectionalLight };\r\n","import { Object3D } from \"../core/Object3D\";\r\nimport { Color } from \"../math/Color\";\r\n\r\nexport class Light extends Object3D {\r\n    \r\n    public get type(){\r\n\t\treturn \"Light\";\r\n    }\r\n\r\n\tpublic static Is(object:Object3D){\r\n\t\treturn object instanceof Light;\r\n\t}\r\n\r\n    private _color:Color;\r\n    private _intensity:number;\r\n\r\n    constructor(color:Color, intensity = 1){\r\n        super();\r\n\r\n        this._color = color;\r\n        this._intensity = intensity;\r\n    }\r\n\r\n    public update(){\r\n\r\n    }\r\n\r\n    public get color(){\r\n        return this._color;\r\n    }\r\n}\r\n","import { Cache } from '../core/ResourceManagers';\r\nimport { Loader } from './Loader';\r\nimport { LoadingManager } from './LoadingManager';\r\n\r\nconst loading:any = {};\r\n\r\nclass HttpError extends Error {\r\n\r\n    public response:Response;\r\n\r\n\tconstructor( message:string, response:Response ) {\r\n\r\n\t\tsuper( message );\r\n\t\tthis.response = response;\r\n\r\n\t}\r\n\r\n}\r\n\r\nclass FileLoader extends Loader {\r\n\r\n    public mimeType:DOMParserSupportedType;\r\n    public responseType:string;\r\n\r\n\tconstructor( manager:LoadingManager = undefined ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t}\r\n\r\n\tload( url:string, onLoad:Function, onProgress:Function, onError:Function ) {\r\n\r\n\t\tif ( url === undefined ) url = '';\r\n\r\n\t\tif ( this.path !== undefined ) url = this.path + url;\r\n\r\n\t\turl = this.manager.resolveURL( url );\r\n\r\n\t\tconst cached = Cache.get( url );\r\n\r\n\t\tif ( cached !== undefined ) {\r\n\r\n\t\t\tthis.manager.itemStart( url );\r\n\r\n\t\t\tsetTimeout( () => {\r\n\r\n\t\t\t\tif ( onLoad ) onLoad( cached );\r\n\r\n\t\t\t\tthis.manager.itemEnd( url );\r\n\r\n\t\t\t}, 0 );\r\n\r\n\t\t\treturn cached;\r\n\r\n\t\t}\r\n\r\n\t\t// Check if request is duplicate\r\n\r\n\t\tif ( loading[ url ] !== undefined ) {\r\n\r\n\t\t\tloading[ url ].push( {\r\n\r\n\t\t\t\tonLoad: onLoad,\r\n\t\t\t\tonProgress: onProgress,\r\n\t\t\t\tonError: onError\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t// Initialise array for duplicate requests\r\n\t\tloading[ url ] = [];\r\n\r\n\t\tloading[ url ].push( {\r\n\t\t\tonLoad: onLoad,\r\n\t\t\tonProgress: onProgress,\r\n\t\t\tonError: onError,\r\n\t\t} );\r\n\r\n\t\t// create request\r\n\t\tconst req = new Request( url, {\r\n\t\t\theaders: new Headers( this.requestHeader ),\r\n\t\t\tcredentials: this.withCredentials ? 'include' : 'same-origin',\r\n\t\t\t// An abort controller could be added within a future PR\r\n\t\t} );\r\n\r\n\t\t// record states ( avoid data race )\r\n\t\tconst mimeType = this.mimeType;\r\n\t\tconst responseType = this.responseType;\r\n\r\n\t\t// start the fetch\r\n\t\tfetch( req )\r\n\t\t\t.then( response => {\r\n\r\n\t\t\t\tif ( response.status === 200 || response.status === 0 ) {\r\n\r\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\r\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\r\n\r\n\t\t\t\t\tif ( response.status === 0 ) {\r\n\r\n\t\t\t\t\t\tconsole.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Workaround: Checking if response.body === undefined for Alipay browser #23548\r\n\r\n\t\t\t\t\tif ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {\r\n\r\n\t\t\t\t\t\treturn response;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst callbacks = loading[ url ];\r\n\t\t\t\t\tconst reader = response.body.getReader();\r\n\r\n\t\t\t\t\t// Nginx needs X-File-Size check\r\n\t\t\t\t\t// https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content\r\n\t\t\t\t\tconst contentLength = response.headers.get( 'Content-Length' ) || response.headers.get( 'X-File-Size' );\r\n\t\t\t\t\tconst total = contentLength ? parseInt( contentLength ) : 0;\r\n\t\t\t\t\tconst lengthComputable = total !== 0;\r\n\t\t\t\t\tlet loaded = 0;\r\n\r\n\t\t\t\t\t// periodically read data into the new stream tracking while download progress\r\n\t\t\t\t\tconst stream = new ReadableStream( {\r\n\t\t\t\t\t\tstart( controller ) {\r\n\r\n\t\t\t\t\t\t\treadData();\r\n\r\n\t\t\t\t\t\t\tfunction readData() {\r\n\r\n\t\t\t\t\t\t\t\treader.read().then( ( { done, value } ) => {\r\n\r\n\t\t\t\t\t\t\t\t\tif ( done ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tcontroller.close();\r\n\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\tloaded += value.byteLength;\r\n\r\n\t\t\t\t\t\t\t\t\t\tconst event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );\r\n\t\t\t\t\t\t\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tconst callback = callbacks[ i ];\r\n\t\t\t\t\t\t\t\t\t\t\tif ( callback.onProgress ) callback.onProgress( event );\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tcontroller.enqueue( value );\r\n\t\t\t\t\t\t\t\t\t\treadData();\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t\treturn new Response( stream );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrow new HttpError( `fetch for \"${response.url}\" responded with ${response.status}: ${response.statusText}`, response );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} )\r\n\t\t\t.then( response => {\r\n\r\n\t\t\t\tswitch ( responseType ) {\r\n\r\n\t\t\t\t\tcase 'arraybuffer':\r\n\r\n\t\t\t\t\t\treturn response.arrayBuffer();\r\n\r\n\t\t\t\t\tcase 'blob':\r\n\r\n\t\t\t\t\t\treturn response.blob();\r\n\r\n\t\t\t\t\tcase 'document':\r\n\r\n\t\t\t\t\t\treturn response.text()\r\n\t\t\t\t\t\t\t.then( text => {\r\n\r\n\t\t\t\t\t\t\t\tconst parser = new DOMParser();\r\n\t\t\t\t\t\t\t\treturn parser.parseFromString( text, mimeType );\r\n\r\n\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\tcase 'json':\r\n\r\n\t\t\t\t\t\treturn response.json();\r\n\r\n\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\tif ( mimeType === undefined ) {\r\n\r\n\t\t\t\t\t\t\treturn response.text();\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// sniff encoding\r\n\t\t\t\t\t\t\tconst re = /charset=\"?([^;\"\\s]*)\"?/i;\r\n\t\t\t\t\t\t\tconst exec = re.exec( mimeType );\r\n\t\t\t\t\t\t\tconst label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;\r\n\t\t\t\t\t\t\tconst decoder = new TextDecoder( label );\r\n\t\t\t\t\t\t\treturn response.arrayBuffer().then( ab => decoder.decode( ab ) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} )\r\n\t\t\t.then( data => {\r\n\r\n\t\t\t\t// Add to cache only on HTTP success, so that we do not cache\r\n\t\t\t\t// error response bodies as proper responses to requests.\r\n\t\t\t\tCache.add( url, data );\r\n\r\n\t\t\t\tconst callbacks = loading[ url ];\r\n\t\t\t\tdelete loading[ url ];\r\n\r\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tconst callback = callbacks[ i ];\r\n\t\t\t\t\tif ( callback.onLoad ) callback.onLoad( data );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} )\r\n\t\t\t.catch( err => {\r\n\r\n\t\t\t\t// Abort errors and other errors are handled the same\r\n\r\n\t\t\t\tconst callbacks = loading[ url ];\r\n\r\n\t\t\t\tif ( callbacks === undefined ) {\r\n\r\n\t\t\t\t\t// When onLoad was called and url was deleted in `loading`\r\n\t\t\t\t\tthis.manager.itemError( url );\r\n\t\t\t\t\tthrow err;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdelete loading[ url ];\r\n\r\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tconst callback = callbacks[ i ];\r\n\t\t\t\t\tif ( callback.onError ) callback.onError( err );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.manager.itemError( url );\r\n\r\n\t\t\t} )\r\n\t\t\t.finally( () => {\r\n\r\n\t\t\t\tthis.manager.itemEnd( url );\r\n\r\n\t\t\t} );\r\n\r\n\t\tthis.manager.itemStart( url );\r\n\r\n\t}\r\n\r\n\tsetResponseType( value:string ) {\r\n\r\n\t\tthis.responseType = value;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetMimeType( value:DOMParserSupportedType ) {\r\n\r\n\t\tthis.mimeType = value;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { FileLoader };\r\n","import { Cache } from '../core/ResourceManagers';\r\nimport { Loader } from './Loader';\r\nimport { LoadingManager } from './LoadingManager';\r\n\r\nexport class ImageLoader extends Loader {\r\n\r\n\tconstructor( manager:LoadingManager = undefined ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t}\r\n\r\n\tload( url:string, onLoad:Function, onProgress:Function, onError:Function ) {\r\n\r\n\t\tif ( this.path !== undefined ) url = this.path + url;\r\n\r\n\t\turl = this.manager.resolveURL( url );\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tconst cached = Cache.get( url );\r\n\r\n\t\tif ( cached !== undefined ) {\r\n\r\n\t\t\tscope.manager.itemStart( url );\r\n\r\n\t\t\tsetTimeout( function () {\r\n\r\n\t\t\t\tif ( onLoad ) onLoad( cached );\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t}, 0 );\r\n\r\n\t\t\treturn cached;\r\n\r\n\t\t}\r\n\r\n\t\tconst image = document.createElement(\"img\");\r\n\r\n\t\tconst onImageLoad = () => {\r\n\r\n\t\t\tremoveEventListeners();\r\n\r\n\t\t\tCache.add( url, image );\r\n\r\n\t\t\tif ( onLoad ) onLoad( image );\r\n\r\n\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t}\r\n\r\n\t\tfunction onImageError( event:any ) {\r\n\r\n\t\t\tremoveEventListeners();\r\n\r\n\t\t\tif ( onError ) onError( event );\r\n\r\n\t\t\tscope.manager.itemError( url );\r\n\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t}\r\n\r\n\t\tfunction removeEventListeners() {\r\n\r\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\r\n\t\t\timage.removeEventListener( 'error', onImageError, false );\r\n\r\n\t\t}\r\n\r\n\t\timage.addEventListener( 'load', onImageLoad, false );\r\n\t\timage.addEventListener( 'error', onImageError, false );\r\n\r\n\t\tif ( url.slice( 0, 5 ) !== 'data:' ) {\r\n\r\n\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\r\n\r\n\t\t}\r\n\r\n\t\tscope.manager.itemStart( url );\r\n\r\n\t\timage.src = url;\r\n\r\n\t\treturn image;\r\n\r\n\t}\r\n\r\n}\r\n","import { DefaultLoadingManager, LoadingManager } from './LoadingManager';\r\n\r\n export abstract class Loader {\r\n\r\n    public manager:LoadingManager;\r\n    public crossOrigin = 'anonymous';\r\n    public withCredentials = false;\r\n    public path = '';\r\n    public resourcePath = '';\r\n    public requestHeader = {};\r\n\r\n\tconstructor( manager:LoadingManager = undefined ) {\r\n\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n\t}\r\n\r\n\tabstract load( url:string, onLoad:Function, onProgress:Function, onError:Function ):void;\r\n\r\n\tloadAsync( url:string, onProgress:Function ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\treturn new Promise( function ( resolve, reject ) {\r\n\r\n\t\t\tscope.load( url, resolve, onProgress, reject );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tparse( /* data */ ) {}\r\n\r\n\tsetCrossOrigin( crossOrigin:string ) {\r\n\r\n\t\tthis.crossOrigin = crossOrigin;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetWithCredentials( value:boolean ) {\r\n\r\n\t\tthis.withCredentials = value;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetPath( path:string ) {\r\n\r\n\t\tthis.path = path;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetResourcePath( resourcePath:string ) {\r\n\r\n\t\tthis.resourcePath = resourcePath;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetRequestHeader( requestHeader:any ) {\r\n\r\n\t\tthis.requestHeader = requestHeader;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}","export class LoadingManager {\r\n    private isLoading = false;\r\n    private itemsLoaded = 0;\r\n    private itemsTotal = 0;\r\n    private urlModifier:Function = undefined;\r\n    private handlers:Array<RegExp> = [];\r\n\r\n    public onStart:Function;\r\n    public onLoad:Function;\r\n    public onProgress:Function;\r\n    public onError:Function;\r\n\r\n\tconstructor( onLoad:Function = undefined, onProgress:Function = undefined, onError:Function = undefined ) {\r\n\t\t// Refer to #5689 for the reason why we don't set .onStart\r\n\t\t// in the constructor\r\n\r\n\t\tthis.onStart = undefined;\r\n\t\tthis.onLoad = onLoad;\r\n\t\tthis.onProgress = onProgress;\r\n\t\tthis.onError = onError;\r\n\t}\r\n\r\n    itemStart ( url:string ) {\r\n\r\n        this.itemsTotal ++;\r\n\r\n        if ( this.isLoading === false ) {\r\n\r\n            if ( this.onStart !== undefined ) {\r\n\r\n                this.onStart( url, this.itemsLoaded, this.itemsTotal );\r\n\r\n            }\r\n\r\n        }\r\n\r\n        this.isLoading = true;\r\n\r\n    }\r\n\r\n    itemEnd ( url:string ) {\r\n\r\n        this.itemsLoaded ++;\r\n\r\n        if ( this.onProgress !== undefined ) {\r\n\r\n            this.onProgress( url, this.itemsLoaded, this.itemsTotal );\r\n\r\n        }\r\n\r\n        if ( this.itemsLoaded === this.itemsTotal ) {\r\n\r\n            this.isLoading = false;\r\n\r\n            if ( this.onLoad !== undefined ) {\r\n\r\n                this.onLoad();\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    itemError ( url:string ) {\r\n\r\n        if ( this.onError !== undefined ) {\r\n\r\n            this.onError( url );\r\n\r\n        }\r\n\r\n    }\r\n\r\n    resolveURL ( url:string ) {\r\n\r\n        if ( this.urlModifier ) {\r\n\r\n            return this.urlModifier( url );\r\n\r\n        }\r\n\r\n        return url;\r\n\r\n    }\r\n\r\n    setURLModifier ( transform:Function ) {\r\n\r\n        this.urlModifier = transform;\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n    addHandler ( regex:RegExp, loader:any ) {\r\n\r\n        this.handlers.push( regex, loader );\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n    removeHandler ( regex:RegExp ) {\r\n\r\n        const index = this.handlers.indexOf( regex );\r\n\r\n        if ( index !== - 1 ) {\r\n\r\n            this.handlers.splice( index, 2 );\r\n\r\n        }\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n    getHandler ( file:string ) {\r\n\r\n        for ( let i = 0, l = this.handlers.length; i < l; i += 2 ) {\r\n\r\n            const regex = this.handlers[ i ];\r\n            const loader = this.handlers[ i + 1 ];\r\n\r\n            if ( regex.global ) regex.lastIndex = 0; // see #17920\r\n            \r\n            if ( regex.test( file ) ) {\r\n\r\n                return loader;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return null;\r\n\r\n    }\r\n}\r\n\r\nexport const DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();","import { ImageLoader } from './ImageLoader';\r\nimport { Texture } from '../textures/Texture';\r\nimport { Loader } from './Loader';\r\nimport { LoadingManager } from './LoadingManager';\r\n\r\nclass TextureLoader extends Loader {\r\n\r\n\tpublic image:HTMLImageElement;\r\n\r\n\tconstructor( manager : LoadingManager = undefined ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t}\r\n\r\n\tload( url:string, onLoad:Function, onProgress:Function, onError:Function ) {\r\n\r\n\t\tconst texture = new Texture();\r\n\r\n\t\tconst loader = new ImageLoader( this.manager );\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.setPath( this.path );\r\n\r\n\t\tloader.load( url, function ( image:HTMLImageElement ) {\r\n\r\n\t\t\ttexture.image = image;\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad !== undefined ) {\r\n\r\n\t\t\t\tonLoad( texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { TextureLoader };\r\n","import { BindValue } from \"../core/binds/BindValue\";\r\nimport { Color } from \"../math/Color\";\r\nimport { Texture } from \"../textures/Texture\";\r\nimport { GPUBufferBindingType, GPUSamplerBindingType, GPUVertexFormat } from \"../Constants\";\r\nimport { BindBuffer } from \"../core/binds/BindBuffer\";\r\nimport { BindSampler } from \"../core/binds/BindSampler\";\r\nimport { BindTexture } from \"../core/binds/BindTexture\";\r\nimport { MathUtils } from \"../math/MathUtils\";\r\nimport { Pipleline } from \"../core/Pipeline\";\r\nimport { AttributeShaderItem, BindShaderItem, BindType, ShaderItem } from \"../core/Defines\";\r\nimport { Shader } from \"../shaders/Shader\";\r\n\r\nexport abstract class Material {\r\n\r\n    private _color: Color;\r\n    private _map: Texture = null;\r\n    private _parameters = new Uint32Array(4);\r\n    private _pipeline: Pipleline;\r\n    private _transparent = false;\r\n    private _opacity = 1;\r\n\r\n    protected _uniforms: Map<string, BindValue> = new Map();\r\n    protected _shader: Shader;\r\n    protected _shaderOptions = {\r\n        attributeValues: new Map<string,AttributeShaderItem>(),\r\n        bindValues: new Map<string,BindShaderItem>()\r\n    };\r\n\r\n    public uuid: string;\r\n    public needsCreateBindGroup = true;\r\n    public needsCompile = true;\r\n\r\n    constructor() {\r\n        this.uuid = MathUtils.generateUUID();\r\n\r\n        this._pipeline = new Pipleline(this);\r\n\r\n        this._setAttributeValue(\"position\",\"vec3<f32>\",GPUVertexFormat.Float32x3,4*3);\r\n\r\n        this._uniforms.set(\"parameters\", new BindBuffer(\"parameters\", this._parameters));\r\n        this._setBindValue(\"parameters\",\"vec4<u32>\",BindType.buffer, GPUShaderStage.FRAGMENT);\r\n\r\n        this.color = new Color(1.0, 1.0, 1.0);\r\n    }\r\n\r\n    public updateUniforms() {\r\n        for (const uniform of this.uniforms.values()) {\r\n            uniform.update();\r\n            if (uniform.type === BindType.texture) {\r\n                const textureUniform = uniform as BindTexture;\r\n                if (textureUniform.changed && !this.needsCreateBindGroup) {\r\n                    this.needsCreateBindGroup = true;\r\n                    textureUniform.changed = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    public getBindLayout() {\r\n        const entriesLayout: Array<GPUBindGroupLayoutEntry> = [];\r\n        for(const [name,bindOption] of this._shaderOptions.bindValues){\r\n            if(bindOption.bindType === BindType.buffer){\r\n                const bufferUnform = this.uniforms.get(name) as BindBuffer;\r\n                entriesLayout.push({\r\n                    binding: bindOption.index,\r\n                    visibility: bindOption.visibility,\r\n                    buffer: {\r\n                        type: GPUBufferBindingType.Uniform,\r\n                        minBindingSize: bufferUnform.buffer.size,\r\n                    },\r\n                });\r\n            }else if(bindOption.bindType === BindType.sampler){\r\n                entriesLayout.push({\r\n                    binding: bindOption.index,\r\n                    visibility: bindOption.visibility,\r\n                    sampler: {\r\n                        type: GPUSamplerBindingType.Filtering,\r\n                    },\r\n                });\r\n            }else if(bindOption.bindType === BindType.texture){\r\n                entriesLayout.push({\r\n                    binding: bindOption.index,\r\n                    visibility: bindOption.visibility,\r\n                    texture: {},\r\n                });\r\n            }\r\n        }\r\n        \r\n        return entriesLayout;\r\n    }\r\n\r\n    public getBindGroup() {\r\n        const entriesGroup = new Array<GPUBindGroupEntry>();\r\n\r\n        for(const [name,bindOption] of this._shaderOptions.bindValues){\r\n            if(bindOption.bindType === BindType.buffer){\r\n                const bufferUnform = this.uniforms.get(name) as BindBuffer;\r\n                entriesGroup.push({\r\n                    binding: bindOption.index,\r\n                    resource: {\r\n                        buffer: bufferUnform.buffer,\r\n                    },\r\n                });\r\n            }else if(bindOption.bindType === BindType.sampler){\r\n                const samplerUnform = this.uniforms.get(name) as BindSampler;\r\n                entriesGroup.push({\r\n                    binding: bindOption.index,\r\n                    resource: samplerUnform.sampler,\r\n                });\r\n            }else if(bindOption.bindType === BindType.texture){\r\n                const textureUnform = this.uniforms.get(name) as BindTexture;\r\n                entriesGroup.push({\r\n                    binding: bindOption.index,\r\n                    resource: textureUnform.textureBuffer.createView(),\r\n                });\r\n            }\r\n        }\r\n\r\n        this.needsCreateBindGroup = false;\r\n        return entriesGroup;\r\n    }\r\n\r\n    protected _setAttributeValue(name:string,itemType : string,format:GPUVertexFormat,itemSize:number){\r\n        const map = this.shaderOptions.attributeValues;\r\n        map.set(name,{\r\n            name:name,\r\n            index:this._shaderOptions.bindValues.size,\r\n            format:format,\r\n            shaderItemType:itemType,\r\n            itemSize:itemSize\r\n        });\r\n        let index = 0;\r\n        for(const value of map.values()){\r\n            value.index = index++;\r\n        }\r\n    }\r\n\r\n    protected _setBindValue(name:string,itemType : string,bindType : BindType,  visibility:GPUShaderStageFlags){\r\n        const map = this.shaderOptions.bindValues;\r\n        map.set(name,{\r\n            name:name,\r\n            index:this._shaderOptions.bindValues.size,\r\n            bindType:bindType,\r\n            shaderItemType:itemType,\r\n            visibility:visibility\r\n        });\r\n        let index = 0;\r\n        for(const value of map.values()){\r\n            value.index = index++;\r\n        }\r\n    }\r\n\r\n    protected _deleteValue(map:Map<string,ShaderItem>,name:string){\r\n        map.delete(name);\r\n        let index = 0;\r\n        for(const value of map.values()){\r\n            value.index = index++;\r\n        }\r\n    }\r\n\r\n    public get applyLight(){\r\n        return false;\r\n    }\r\n\r\n    public set color(v: Color) {\r\n        this._color = v;\r\n\r\n        let colorBuffer;\r\n        let itemType;\r\n        if(this._transparent){\r\n            colorBuffer = new Float32Array(4);\r\n            itemType = \"vec4<f32>\";\r\n            colorBuffer.set(this._color.toArray());\r\n            colorBuffer[3] = this._opacity;\r\n        }else{\r\n            colorBuffer = this._color.toArray();\r\n            itemType = \"vec3<f32>\";\r\n        }\r\n\r\n        const colorUniform = this._uniforms.get(\"color\") as BindBuffer;\r\n        if(!colorUniform){\r\n            this._setBindValue(\"color\",itemType,BindType.buffer, GPUShaderStage.FRAGMENT);\r\n\r\n            this._uniforms.set(\"color\", new BindBuffer(\"color\", colorBuffer));\r\n        }else if(colorBuffer.length * colorBuffer.BYTES_PER_ELEMENT !== colorUniform.buffer.size){\r\n            this._shaderOptions.bindValues.get(\"color\").shaderItemType = itemType;\r\n\r\n            this._uniforms.set(\"color\", new BindBuffer(\"color\", colorBuffer));\r\n        } \r\n        else{\r\n            colorUniform.data = colorBuffer;\r\n        }\r\n    }\r\n\r\n    public get color() {\r\n        return this._color;\r\n    }\r\n\r\n    public set map(v: Texture | null) {\r\n        if(v === this._map)\r\n            return;\r\n\r\n        if(v === null && this._map !== null){\r\n            this._uniforms.get(\"colorSampler\").destroy();\r\n            this._uniforms.get(\"texture\").destroy();\r\n            this._uniforms.delete(\"colorSampler\");\r\n            this._uniforms.delete(\"texture\");\r\n\r\n            this._deleteValue(this._shaderOptions.attributeValues,\"uv\");\r\n            this._deleteValue(this._shaderOptions.bindValues,\"colorSampler\");\r\n            this._deleteValue(this._shaderOptions.bindValues,\"texture\");\r\n\r\n            this.pipeline.needsCompile = true;\r\n\r\n        }else if(v !== null && this._map === null){\r\n            this._setAttributeValue(\"uv\",\"vec2<f32>\",GPUVertexFormat.Float32x2,4*2);\r\n\r\n            this._setBindValue(\"colorSampler\",\"sampler\",BindType.sampler, GPUShaderStage.FRAGMENT);\r\n            this._uniforms.set(\"colorSampler\", new BindSampler(\"colorSampler\"));\r\n   \r\n            this._setBindValue(\"texture\",\"texture_2d<f32>\",BindType.texture, GPUShaderStage.FRAGMENT);\r\n            this._uniforms.set(\"texture\", new BindTexture(\"texture\", v));\r\n\r\n            this.pipeline.needsCompile = true;\r\n\r\n            (this._uniforms.get(\"texture\") as BindTexture).texture = v;\r\n        }\r\n\r\n        this.needsCreateBindGroup = true;\r\n        this._map = v;\r\n    }\r\n\r\n    public get map() {\r\n        return this._map;\r\n    }\r\n    \r\n    public set transparent(v:boolean){\r\n        if(this._transparent === v)\r\n            return;\r\n\r\n        this.pipeline.needsCompile = true;\r\n        this.needsCreateBindGroup = true;\r\n        this._transparent = v;\r\n        this.color = this._color;\r\n    }\r\n\r\n    public get transparent(){\r\n        return this._transparent;\r\n    }\r\n\r\n    public set opacity(v:number){\r\n        this._opacity = v;\r\n        this.color = this._color;\r\n    }\r\n\r\n    public get opacity(){\r\n        return this._opacity;\r\n    }\r\n\r\n    public get uniforms() {\r\n        return this._uniforms;\r\n    }\r\n\r\n    public get shaderOptions() {\r\n        return this._shaderOptions;\r\n    }\r\n\r\n    public get shader() {\r\n        return this._shader;\r\n    }\r\n\r\n    public get pipeline() {\r\n        return this._pipeline;\r\n    }\r\n}\r\n","import { MeshBasicShader } from \"../shaders/MeshBasicShader\";\r\nimport { Material } from \"./Material\";\r\n\r\nexport class MeshBasicMaterial extends Material{\r\n    \r\n    constructor(){\r\n        super();\r\n\r\n        this._shader = new MeshBasicShader(this);\r\n    }\r\n\r\n}","import { GPUVertexFormat } from \"../Constants\";\r\nimport { BindBuffer } from \"../core/binds/BindBuffer\";\r\nimport { BindType } from \"../core/Defines\";\r\nimport { DirectionalLight } from \"../lights/DirectionalLight\";\r\nimport { Light } from \"../lights/Light\";\r\nimport { Color } from \"../math/Color\";\r\nimport { MeshPhongShader } from \"../shaders/MeshPhongShader\";\r\nimport { Material } from \"./Material\";\r\n\r\nexport class MeshPhongMaterial extends Material{\r\n    \r\n    private _specular = new Color( 0x111111 ); //高光反射\r\n    private _emissive = new Color( 0x000000 ); //自发光\r\n    private _shininess = 30;\r\n    \r\n    constructor(){\r\n        super();\r\n\r\n        this._shader = new MeshPhongShader(this);\r\n\r\n        this._setAttributeValue(\"normal\",\"vec3<f32>\",GPUVertexFormat.Float32x3,4*3);\r\n\r\n        this._uniforms.set(\"specular\", new BindBuffer(\"specular\", this._specular.toArray()));\r\n        this._setBindValue(\"specular\",\"vec3<f32>\",BindType.buffer, GPUShaderStage.FRAGMENT);\r\n        this._uniforms.set(\"emissive\", new BindBuffer(\"emissive\", this._emissive.toArray()));\r\n        this._setBindValue(\"emissive\",\"vec3<f32>\",BindType.buffer, GPUShaderStage.FRAGMENT);\r\n        this._uniforms.set(\"shininess\", new BindBuffer(\"shininess\", new Float32Array([this._shininess])));\r\n        this._setBindValue(\"shininess\",\"f32\",BindType.buffer, GPUShaderStage.FRAGMENT);\r\n    }\r\n\r\n    public setLights(lights:Array<Light>){\r\n        for(let i = 0;i < lights.length;++i){\r\n            const light = lights[i];\r\n            if(DirectionalLight.Is(light)){\r\n                const dirLight = light as DirectionalLight;\r\n                \r\n            }\r\n        }\r\n    }\r\n\r\n    public override get applyLight(){\r\n        return false;\r\n    }\r\n\r\n    public set specular(v:Color){\r\n        this._specular.copy(v);\r\n        (this._uniforms.get(\"specular\") as BindBuffer).data = v.toArray();\r\n    }\r\n\r\n    public set emissive(v:Color){\r\n        this._emissive.copy(v);\r\n        (this._uniforms.get(\"emissive\") as BindBuffer).data = v.toArray();\r\n    }\r\n\r\n    public set shininess(v:number){\r\n        this._shininess = v;\r\n        (this._uniforms.get(\"specular\") as BindBuffer).data = new Float32Array([v]);\r\n    }\r\n}","import { clamp, euclideanModulo, lerp } from \"./MathUtils\";\r\nimport { ColorManagement, SRGBToLinear, LinearToSRGB } from \"./ColorManagement\";\r\nimport { Vector3 } from \"./Vector3\";\r\nimport { Matrix3 } from \"./Matrix3\";\r\n\r\nexport const SRGBColorSpace = \"srgb\";\r\nconst _colorKeywords: any = {\r\n    aliceblue: 0xf0f8ff,\r\n    antiquewhite: 0xfaebd7,\r\n    aqua: 0x00ffff,\r\n    aquamarine: 0x7fffd4,\r\n    azure: 0xf0ffff,\r\n    beige: 0xf5f5dc,\r\n    bisque: 0xffe4c4,\r\n    black: 0x000000,\r\n    blanchedalmond: 0xffebcd,\r\n    blue: 0x0000ff,\r\n    blueviolet: 0x8a2be2,\r\n    brown: 0xa52a2a,\r\n    burlywood: 0xdeb887,\r\n    cadetblue: 0x5f9ea0,\r\n    chartreuse: 0x7fff00,\r\n    chocolate: 0xd2691e,\r\n    coral: 0xff7f50,\r\n    cornflowerblue: 0x6495ed,\r\n    cornsilk: 0xfff8dc,\r\n    crimson: 0xdc143c,\r\n    cyan: 0x00ffff,\r\n    darkblue: 0x00008b,\r\n    darkcyan: 0x008b8b,\r\n    darkgoldenrod: 0xb8860b,\r\n    darkgray: 0xa9a9a9,\r\n    darkgreen: 0x006400,\r\n    darkgrey: 0xa9a9a9,\r\n    darkkhaki: 0xbdb76b,\r\n    darkmagenta: 0x8b008b,\r\n    darkolivegreen: 0x556b2f,\r\n    darkorange: 0xff8c00,\r\n    darkorchid: 0x9932cc,\r\n    darkred: 0x8b0000,\r\n    darksalmon: 0xe9967a,\r\n    darkseagreen: 0x8fbc8f,\r\n    darkslateblue: 0x483d8b,\r\n    darkslategray: 0x2f4f4f,\r\n    darkslategrey: 0x2f4f4f,\r\n    darkturquoise: 0x00ced1,\r\n    darkviolet: 0x9400d3,\r\n    deeppink: 0xff1493,\r\n    deepskyblue: 0x00bfff,\r\n    dimgray: 0x696969,\r\n    dimgrey: 0x696969,\r\n    dodgerblue: 0x1e90ff,\r\n    firebrick: 0xb22222,\r\n    floralwhite: 0xfffaf0,\r\n    forestgreen: 0x228b22,\r\n    fuchsia: 0xff00ff,\r\n    gainsboro: 0xdcdcdc,\r\n    ghostwhite: 0xf8f8ff,\r\n    gold: 0xffd700,\r\n    goldenrod: 0xdaa520,\r\n    gray: 0x808080,\r\n    green: 0x008000,\r\n    greenyellow: 0xadff2f,\r\n    grey: 0x808080,\r\n    honeydew: 0xf0fff0,\r\n    hotpink: 0xff69b4,\r\n    indianred: 0xcd5c5c,\r\n    indigo: 0x4b0082,\r\n    ivory: 0xfffff0,\r\n    khaki: 0xf0e68c,\r\n    lavender: 0xe6e6fa,\r\n    lavenderblush: 0xfff0f5,\r\n    lawngreen: 0x7cfc00,\r\n    lemonchiffon: 0xfffacd,\r\n    lightblue: 0xadd8e6,\r\n    lightcoral: 0xf08080,\r\n    lightcyan: 0xe0ffff,\r\n    lightgoldenrodyellow: 0xfafad2,\r\n    lightgray: 0xd3d3d3,\r\n    lightgreen: 0x90ee90,\r\n    lightgrey: 0xd3d3d3,\r\n    lightpink: 0xffb6c1,\r\n    lightsalmon: 0xffa07a,\r\n    lightseagreen: 0x20b2aa,\r\n    lightskyblue: 0x87cefa,\r\n    lightslategray: 0x778899,\r\n    lightslategrey: 0x778899,\r\n    lightsteelblue: 0xb0c4de,\r\n    lightyellow: 0xffffe0,\r\n    lime: 0x00ff00,\r\n    limegreen: 0x32cd32,\r\n    linen: 0xfaf0e6,\r\n    magenta: 0xff00ff,\r\n    maroon: 0x800000,\r\n    mediumaquamarine: 0x66cdaa,\r\n    mediumblue: 0x0000cd,\r\n    mediumorchid: 0xba55d3,\r\n    mediumpurple: 0x9370db,\r\n    mediumseagreen: 0x3cb371,\r\n    mediumslateblue: 0x7b68ee,\r\n    mediumspringgreen: 0x00fa9a,\r\n    mediumturquoise: 0x48d1cc,\r\n    mediumvioletred: 0xc71585,\r\n    midnightblue: 0x191970,\r\n    mintcream: 0xf5fffa,\r\n    mistyrose: 0xffe4e1,\r\n    moccasin: 0xffe4b5,\r\n    navajowhite: 0xffdead,\r\n    navy: 0x000080,\r\n    oldlace: 0xfdf5e6,\r\n    olive: 0x808000,\r\n    olivedrab: 0x6b8e23,\r\n    orange: 0xffa500,\r\n    orangered: 0xff4500,\r\n    orchid: 0xda70d6,\r\n    palegoldenrod: 0xeee8aa,\r\n    palegreen: 0x98fb98,\r\n    paleturquoise: 0xafeeee,\r\n    palevioletred: 0xdb7093,\r\n    papayawhip: 0xffefd5,\r\n    peachpuff: 0xffdab9,\r\n    peru: 0xcd853f,\r\n    pink: 0xffc0cb,\r\n    plum: 0xdda0dd,\r\n    powderblue: 0xb0e0e6,\r\n    purple: 0x800080,\r\n    rebeccapurple: 0x663399,\r\n    red: 0xff0000,\r\n    rosybrown: 0xbc8f8f,\r\n    royalblue: 0x4169e1,\r\n    saddlebrown: 0x8b4513,\r\n    salmon: 0xfa8072,\r\n    sandybrown: 0xf4a460,\r\n    seagreen: 0x2e8b57,\r\n    seashell: 0xfff5ee,\r\n    sienna: 0xa0522d,\r\n    silver: 0xc0c0c0,\r\n    skyblue: 0x87ceeb,\r\n    slateblue: 0x6a5acd,\r\n    slategray: 0x708090,\r\n    slategrey: 0x708090,\r\n    snow: 0xfffafa,\r\n    springgreen: 0x00ff7f,\r\n    steelblue: 0x4682b4,\r\n    tan: 0xd2b48c,\r\n    teal: 0x008080,\r\n    thistle: 0xd8bfd8,\r\n    tomato: 0xff6347,\r\n    turquoise: 0x40e0d0,\r\n    violet: 0xee82ee,\r\n    wheat: 0xf5deb3,\r\n    white: 0xffffff,\r\n    whitesmoke: 0xf5f5f5,\r\n    yellow: 0xffff00,\r\n    yellowgreen: 0x9acd32,\r\n};\r\n\r\ninterface HSL {\r\n    h: number;\r\n    l: number;\r\n    s: number;\r\n}\r\n\r\nconst _hslA: HSL = { h: 0, s: 0, l: 0 };\r\nconst _hslB: HSL = { h: 0, s: 0, l: 0 };\r\n\r\nfunction hue2rgb(p: number, q: number, t: number) {\r\n    if (t < 0) t += 1;\r\n    if (t > 1) t -= 1;\r\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\r\n    if (t < 1 / 2) return q;\r\n    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\r\n    return p;\r\n}\r\n\r\nclass Color {\r\n    static NAMES = _colorKeywords;\r\n    public r: number;\r\n    public g: number;\r\n    public b: number;\r\n\r\n    constructor(r: number | string = 0, g?: number, b?: number) {\r\n        return this.set(r, g, b);\r\n    }\r\n\r\n    set(r: number | string, g: number, b: number) {\r\n        if (g === undefined && b === undefined) {\r\n            const value = r;\r\n\r\n            if (typeof value === \"number\") {\r\n                this.setHex(value);\r\n            } else if (typeof value === \"string\") {\r\n                this.setStyle(value);\r\n            }\r\n        } else if (typeof r === \"number\") {\r\n            this.setRGB(r, g, b);\r\n        } else {\r\n            throw \"Color parameter error!\";\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    setScalar(scalar: number) {\r\n        this.r = scalar;\r\n        this.g = scalar;\r\n        this.b = scalar;\r\n\r\n        return this;\r\n    }\r\n\r\n    setHex(hex: number, colorSpace = SRGBColorSpace) {\r\n        hex = Math.floor(hex);\r\n\r\n        this.r = ((hex >> 16) & 255) / 255;\r\n        this.g = ((hex >> 8) & 255) / 255;\r\n        this.b = (hex & 255) / 255;\r\n\r\n        ColorManagement.toWorkingColorSpace(this, colorSpace);\r\n\r\n        return this;\r\n    }\r\n\r\n    setRGB(r: number, g: number, b: number, colorSpace = ColorManagement.workingColorSpace) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n\r\n        ColorManagement.toWorkingColorSpace(this, colorSpace);\r\n\r\n        return this;\r\n    }\r\n\r\n    setHSL(h: number, s: number, l: number, colorSpace = ColorManagement.workingColorSpace) {\r\n        // h,s,l ranges are in 0.0 - 1.0\r\n        h = euclideanModulo(h, 1);\r\n        s = clamp(s, 0, 1);\r\n        l = clamp(l, 0, 1);\r\n\r\n        if (s === 0) {\r\n            this.r = this.g = this.b = l;\r\n        } else {\r\n            const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\r\n            const q = 2 * l - p;\r\n\r\n            this.r = hue2rgb(q, p, h + 1 / 3);\r\n            this.g = hue2rgb(q, p, h);\r\n            this.b = hue2rgb(q, p, h - 1 / 3);\r\n        }\r\n\r\n        ColorManagement.toWorkingColorSpace(this, colorSpace);\r\n\r\n        return this;\r\n    }\r\n\r\n    setStyle(style: string, colorSpace = SRGBColorSpace) {\r\n        function handleAlpha(string: string) {\r\n            if (string === undefined) return;\r\n\r\n            if (parseFloat(string) < 1) {\r\n                console.warn(\"THREE.Color: Alpha component of \" + style + \" will be ignored.\");\r\n            }\r\n        }\r\n\r\n        let m;\r\n\r\n        if ((m = /^(\\w+)\\(([^\\)]*)\\)/.exec(style))) {\r\n            // rgb / hsl\r\n\r\n            let color;\r\n            const name = m[1];\r\n            const components = m[2];\r\n\r\n            switch (name) {\r\n                case \"rgb\":\r\n                case \"rgba\":\r\n                    if ((color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components))) {\r\n                        // rgb(255,0,0) rgba(255,0,0,0.5)\r\n\r\n                        handleAlpha(color[4]);\r\n\r\n                        return this.setRGB(\r\n                            Math.min(255, parseInt(color[1], 10)) / 255,\r\n                            Math.min(255, parseInt(color[2], 10)) / 255,\r\n                            Math.min(255, parseInt(color[3], 10)) / 255,\r\n                            colorSpace\r\n                        );\r\n                    }\r\n\r\n                    if (\r\n                        (color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components))\r\n                    ) {\r\n                        // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\r\n\r\n                        handleAlpha(color[4]);\r\n\r\n                        return this.setRGB(\r\n                            Math.min(100, parseInt(color[1], 10)) / 100,\r\n                            Math.min(100, parseInt(color[2], 10)) / 100,\r\n                            Math.min(100, parseInt(color[3], 10)) / 100,\r\n                            colorSpace\r\n                        );\r\n                    }\r\n\r\n                    break;\r\n\r\n                case \"hsl\":\r\n                case \"hsla\":\r\n                    if (\r\n                        (color =\r\n                            /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(\r\n                                components\r\n                            ))\r\n                    ) {\r\n                        // hsl(120,50%,50%) hsla(120,50%,50%,0.5)\r\n\r\n                        handleAlpha(color[4]);\r\n\r\n                        return this.setHSL(\r\n                            parseFloat(color[1]) / 360,\r\n                            parseFloat(color[2]) / 100,\r\n                            parseFloat(color[3]) / 100,\r\n                            colorSpace\r\n                        );\r\n                    }\r\n\r\n                    break;\r\n\r\n                default:\r\n                    console.warn(\"THREE.Color: Unknown color model \" + style);\r\n            }\r\n        } else if ((m = /^\\#([A-Fa-f\\d]+)$/.exec(style))) {\r\n            // hex color\r\n\r\n            const hex = m[1];\r\n            const size = hex.length;\r\n\r\n            if (size === 3) {\r\n                // #ff0\r\n                return this.setRGB(\r\n                    parseInt(hex.charAt(0), 16) / 15,\r\n                    parseInt(hex.charAt(1), 16) / 15,\r\n                    parseInt(hex.charAt(2), 16) / 15,\r\n                    colorSpace\r\n                );\r\n            } else if (size === 6) {\r\n                // #ff0000\r\n                return this.setHex(parseInt(hex, 16), colorSpace);\r\n            } else {\r\n                console.warn(\"THREE.Color: Invalid hex color \" + style);\r\n            }\r\n        } else if (style && style.length > 0) {\r\n            return this.setColorName(style, colorSpace);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    setColorName(style: string, colorSpace = SRGBColorSpace) {\r\n        // color keywords\r\n        const hex = _colorKeywords[style.toLowerCase()];\r\n\r\n        if (hex !== undefined) {\r\n            // red\r\n            this.setHex(hex, colorSpace);\r\n        } else {\r\n            // unknown color\r\n            console.warn(\"THREE.Color: Unknown color \" + style);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    clone() {\r\n        return new Color(this.r, this.g, this.b);\r\n    }\r\n\r\n    copy(color: Color) {\r\n        this.r = color.r;\r\n        this.g = color.g;\r\n        this.b = color.b;\r\n\r\n        return this;\r\n    }\r\n\r\n    copySRGBToLinear(color: Color) {\r\n        this.r = SRGBToLinear(color.r);\r\n        this.g = SRGBToLinear(color.g);\r\n        this.b = SRGBToLinear(color.b);\r\n\r\n        return this;\r\n    }\r\n\r\n    copyLinearToSRGB(color: Color) {\r\n        this.r = LinearToSRGB(color.r);\r\n        this.g = LinearToSRGB(color.g);\r\n        this.b = LinearToSRGB(color.b);\r\n\r\n        return this;\r\n    }\r\n\r\n    convertSRGBToLinear() {\r\n        this.copySRGBToLinear(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    convertLinearToSRGB() {\r\n        this.copyLinearToSRGB(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    getHex(colorSpace = SRGBColorSpace) {\r\n        ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\r\n\r\n        return (\r\n            Math.round(clamp(_color.r * 255, 0, 255)) * 65536 +\r\n            Math.round(clamp(_color.g * 255, 0, 255)) * 256 +\r\n            Math.round(clamp(_color.b * 255, 0, 255))\r\n        );\r\n    }\r\n\r\n    getHexString(colorSpace = SRGBColorSpace) {\r\n        return (\"000000\" + this.getHex(colorSpace).toString(16)).slice(-6);\r\n    }\r\n\r\n    getHSL(target: HSL, colorSpace = ColorManagement.workingColorSpace) {\r\n        // h,s,l ranges are in 0.0 - 1.0\r\n\r\n        ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\r\n\r\n        const r = _color.r,\r\n            g = _color.g,\r\n            b = _color.b;\r\n\r\n        const max = Math.max(r, g, b);\r\n        const min = Math.min(r, g, b);\r\n\r\n        let hue, saturation;\r\n        const lightness = (min + max) / 2.0;\r\n\r\n        if (min === max) {\r\n            hue = 0;\r\n            saturation = 0;\r\n        } else {\r\n            const delta = max - min;\r\n\r\n            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);\r\n\r\n            switch (max) {\r\n                case r:\r\n                    hue = (g - b) / delta + (g < b ? 6 : 0);\r\n                    break;\r\n                case g:\r\n                    hue = (b - r) / delta + 2;\r\n                    break;\r\n                case b:\r\n                    hue = (r - g) / delta + 4;\r\n                    break;\r\n            }\r\n\r\n            hue /= 6;\r\n        }\r\n\r\n        target.h = hue;\r\n        target.s = saturation;\r\n        target.l = lightness;\r\n\r\n        return target;\r\n    }\r\n\r\n    getRGB(target: Color, colorSpace = ColorManagement.workingColorSpace) {\r\n        ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\r\n\r\n        target.r = _color.r;\r\n        target.g = _color.g;\r\n        target.b = _color.b;\r\n\r\n        return target;\r\n    }\r\n\r\n    getStyle(colorSpace = SRGBColorSpace) {\r\n        ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\r\n\r\n        const r = _color.r,\r\n            g = _color.g,\r\n            b = _color.b;\r\n\r\n        if (colorSpace !== SRGBColorSpace) {\r\n            // Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).\r\n            return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;\r\n        }\r\n\r\n        return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;\r\n    }\r\n\r\n    offsetHSL(h: number, s: number, l: number) {\r\n        this.getHSL(_hslA);\r\n\r\n        _hslA.h += h;\r\n        _hslA.s += s;\r\n        _hslA.l += l;\r\n\r\n        this.setHSL(_hslA.h, _hslA.s, _hslA.l);\r\n\r\n        return this;\r\n    }\r\n\r\n    add(color: Color) {\r\n        this.r += color.r;\r\n        this.g += color.g;\r\n        this.b += color.b;\r\n\r\n        return this;\r\n    }\r\n\r\n    addColors(color1: Color, color2: Color) {\r\n        this.r = color1.r + color2.r;\r\n        this.g = color1.g + color2.g;\r\n        this.b = color1.b + color2.b;\r\n\r\n        return this;\r\n    }\r\n\r\n    addScalar(s: number) {\r\n        this.r += s;\r\n        this.g += s;\r\n        this.b += s;\r\n\r\n        return this;\r\n    }\r\n\r\n    sub(color: Color) {\r\n        this.r = Math.max(0, this.r - color.r);\r\n        this.g = Math.max(0, this.g - color.g);\r\n        this.b = Math.max(0, this.b - color.b);\r\n\r\n        return this;\r\n    }\r\n\r\n    multiply(color: Color) {\r\n        this.r *= color.r;\r\n        this.g *= color.g;\r\n        this.b *= color.b;\r\n\r\n        return this;\r\n    }\r\n\r\n    multiplyScalar(s: number) {\r\n        this.r *= s;\r\n        this.g *= s;\r\n        this.b *= s;\r\n\r\n        return this;\r\n    }\r\n\r\n    lerp(color: Color, alpha: number) {\r\n        this.r += (color.r - this.r) * alpha;\r\n        this.g += (color.g - this.g) * alpha;\r\n        this.b += (color.b - this.b) * alpha;\r\n\r\n        return this;\r\n    }\r\n\r\n    lerpColors(color1: Color, color2: Color, alpha: number) {\r\n        this.r = color1.r + (color2.r - color1.r) * alpha;\r\n        this.g = color1.g + (color2.g - color1.g) * alpha;\r\n        this.b = color1.b + (color2.b - color1.b) * alpha;\r\n\r\n        return this;\r\n    }\r\n\r\n    lerpHSL(color: Color, alpha: number) {\r\n        this.getHSL(_hslA);\r\n        color.getHSL(_hslB);\r\n\r\n        const h = lerp(_hslA.h, _hslB.h, alpha);\r\n        const s = lerp(_hslA.s, _hslB.s, alpha);\r\n        const l = lerp(_hslA.l, _hslB.l, alpha);\r\n\r\n        this.setHSL(h, s, l);\r\n\r\n        return this;\r\n    }\r\n\r\n    setFromVector3(v: Vector3) {\r\n        this.r = v.x;\r\n        this.g = v.y;\r\n        this.b = v.z;\r\n\r\n        return this;\r\n    }\r\n\r\n    applyMatrix3(m: Matrix3) {\r\n        const r = this.r,\r\n            g = this.g,\r\n            b = this.b;\r\n        const e = m.elements;\r\n\r\n        this.r = e[0] * r + e[3] * g + e[6] * b;\r\n        this.g = e[1] * r + e[4] * g + e[7] * b;\r\n        this.b = e[2] * r + e[5] * g + e[8] * b;\r\n\r\n        return this;\r\n    }\r\n\r\n    equals(c: Color) {\r\n        return c.r === this.r && c.g === this.g && c.b === this.b;\r\n    }\r\n\r\n    fromArray(array: ArrayLike<number>, offset = 0) {\r\n        this.r = array[offset];\r\n        this.g = array[offset + 1];\r\n        this.b = array[offset + 2];\r\n\r\n        return this;\r\n    }\r\n\r\n    toArray(array: Float32Array = new Float32Array(3), offset = 0) {\r\n        array[offset] = this.r;\r\n        array[offset + 1] = this.g;\r\n        array[offset + 2] = this.b;\r\n\r\n        return array;\r\n    }\r\n\r\n    // fromBufferAttribute( attribute, index ) {\r\n\r\n    // \tthis.r = attribute.getX( index );\r\n    // \tthis.g = attribute.getY( index );\r\n    // \tthis.b = attribute.getZ( index );\r\n\r\n    // \treturn this;\r\n\r\n    // }\r\n\r\n    toJSON() {\r\n        return this.getHex();\r\n    }\r\n\r\n    *[Symbol.iterator]() {\r\n        yield this.r;\r\n        yield this.g;\r\n        yield this.b;\r\n    }\r\n}\r\n\r\nconst _color = /*@__PURE__*/ new Color();\r\n\r\nexport { Color };\r\n","import { Color } from './Color';\r\nimport { Matrix3 } from './Matrix3';\r\n\r\nexport const SRGBColorSpace = 'srgb';\r\nexport const LinearSRGBColorSpace = 'srgb-linear';\r\nexport const DisplayP3ColorSpace = 'display-p3';\r\n\r\nexport function SRGBToLinear( c:number ) {\r\n\r\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\r\n\r\n}\r\n\r\nexport function LinearToSRGB( c:number ) {\r\n\r\n\treturn ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;\r\n\r\n}\r\n\r\n/**\r\n * Matrices converting P3 <-> Rec. 709 primaries, without gamut mapping\r\n * or clipping. Based on W3C specifications for sRGB and Display P3,\r\n * and ICC specifications for the D50 connection space. Values in/out\r\n * are _linear_ sRGB and _linear_ Display P3.\r\n *\r\n * Note that both sRGB and Display P3 use the sRGB transfer functions.\r\n *\r\n * Reference:\r\n * - http://www.russellcottrell.com/photo/matrixCalculator.htm\r\n */\r\n\r\nconst LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /*@__PURE__*/ new Matrix3().fromArray( [\r\n\t0.8224621, 0.0331941, 0.0170827,\r\n\t0.1775380, 0.9668058, 0.0723974,\r\n\t- 0.0000001, 0.0000001, 0.9105199\r\n] );\r\n\r\nconst LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /*@__PURE__*/ new Matrix3().fromArray( [\r\n\t1.2249401, - 0.0420569, - 0.0196376,\r\n\t- 0.2249404, 1.0420571, - 0.0786361,\r\n\t0.0000001, 0.0000000, 1.0982735\r\n] );\r\n\r\nfunction DisplayP3ToLinearSRGB( color:Color ) {\r\n\r\n\t// Display P3 uses the sRGB transfer functions\r\n\treturn color.convertSRGBToLinear().applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB );\r\n\r\n}\r\n\r\nfunction LinearSRGBToDisplayP3( color:Color ) {\r\n\r\n\t// Display P3 uses the sRGB transfer functions\r\n\treturn color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ).convertLinearToSRGB();\r\n\r\n}\r\n\r\n// Conversions from <source> to Linear-sRGB reference space.\r\nconst TO_LINEAR:any = {\r\n\t[ LinearSRGBColorSpace ]: ( color:Color ) => color,\r\n\t[ SRGBColorSpace ]: ( color:Color ) => color.convertSRGBToLinear(),\r\n\t[ DisplayP3ColorSpace ]: DisplayP3ToLinearSRGB,\r\n};\r\n\r\n// Conversions to <target> from Linear-sRGB reference space.\r\nconst FROM_LINEAR:any = {\r\n\t[ LinearSRGBColorSpace ]: ( color:Color ) => color,\r\n\t[ SRGBColorSpace ]: ( color:Color ) => color.convertLinearToSRGB(),\r\n\t[ DisplayP3ColorSpace ]: LinearSRGBToDisplayP3,\r\n};\r\n\r\nexport const ColorManagement = {\r\n\r\n\tenabled: true,\r\n\r\n\tget legacyMode() {\r\n\r\n\t\tconsole.warn( 'THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.' );\r\n\r\n\t\treturn ! this.enabled;\r\n\r\n\t},\r\n\r\n\tset legacyMode( legacyMode ) {\r\n\r\n\t\tconsole.warn( 'THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.' );\r\n\r\n\t\tthis.enabled = ! legacyMode;\r\n\r\n\t},\r\n\r\n\tget workingColorSpace() {\r\n\r\n\t\treturn LinearSRGBColorSpace;\r\n\r\n\t},\r\n\r\n\tset workingColorSpace( colorSpace ) {\r\n\r\n\t\tconsole.warn( 'THREE.ColorManagement: .workingColorSpace is readonly.' );\r\n\r\n\t},\r\n\r\n\tconvert: function ( color:Color, sourceColorSpace:string, targetColorSpace:string ) {\r\n\r\n\t\tif ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {\r\n\r\n\t\t\treturn color;\r\n\r\n\t\t}\r\n\r\n\t\tconst sourceToLinear = TO_LINEAR[ sourceColorSpace ];\r\n\t\tconst targetFromLinear = FROM_LINEAR[ targetColorSpace ];\r\n\r\n\t\tif ( sourceToLinear === undefined || targetFromLinear === undefined ) {\r\n\r\n\t\t\tthrow new Error( `Unsupported color space conversion, \"${ sourceColorSpace }\" to \"${ targetColorSpace }\".` );\r\n\r\n\t\t}\r\n\r\n\t\treturn targetFromLinear( sourceToLinear( color ) );\r\n\r\n\t},\r\n\r\n\tfromWorkingColorSpace: function ( color:Color, targetColorSpace:string ) {\r\n\r\n\t\treturn this.convert( color, this.workingColorSpace, targetColorSpace );\r\n\r\n\t},\r\n\r\n\ttoWorkingColorSpace: function ( color:Color, sourceColorSpace:string ) {\r\n\r\n\t\treturn this.convert( color, sourceColorSpace, this.workingColorSpace );\r\n\r\n\t},\r\n\r\n};\r\n","import { Quaternion } from './Quaternion';\r\nimport { Matrix4 } from './Matrix4';\r\nimport { clamp } from './MathUtils';\r\nimport { Vector3 } from './Vector3';\r\n\r\nconst _matrix = /*@__PURE__*/ new Matrix4();\r\nconst _quaternion = /*@__PURE__*/ new Quaternion();\r\n\r\nclass Euler {\r\n\r\n    private static DEFAULT_ORDER = 'XYZ';\r\n\r\n    public x = 0;\r\n    public y = 0;\r\n    public z = 0;\r\n\r\n    public order = Euler.DEFAULT_ORDER;\r\n\tconstructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t\tthis.order = order;\r\n\r\n\t}\r\n\r\n\tset( x:number, y:number, z:number, order = this.order ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t\tthis.order = order;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new Euler( this.x, this.y, this.z, this.order );\r\n\r\n\t}\r\n\r\n\tcopy( euler:Euler ) {\r\n\r\n\t\tthis.x = euler.x;\r\n\t\tthis.y = euler.y;\r\n\t\tthis.z = euler.z;\r\n\t\tthis.order = euler.order;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromRotationMatrix( m:Matrix4, order = this.order ) {\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tconst te = m.elements;\r\n\t\tconst m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\r\n\t\tconst m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\r\n\t\tconst m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n\t\tswitch ( order ) {\r\n\r\n\t\t\tcase 'XYZ':\r\n\r\n\t\t\t\tthis.y = Math.asin( clamp( m13, - 1, 1 ) );\r\n\r\n\t\t\t\tif ( Math.abs( m13 ) < 0.9999999 ) {\r\n\r\n\t\t\t\t\tthis.x = Math.atan2( - m23, m33 );\r\n\t\t\t\t\tthis.z = Math.atan2( - m12, m11 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.x = Math.atan2( m32, m22 );\r\n\t\t\t\t\tthis.z = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'YXZ':\r\n\r\n\t\t\t\tthis.x = Math.asin( - clamp( m23, - 1, 1 ) );\r\n\r\n\t\t\t\tif ( Math.abs( m23 ) < 0.9999999 ) {\r\n\r\n\t\t\t\t\tthis.y = Math.atan2( m13, m33 );\r\n\t\t\t\t\tthis.z = Math.atan2( m21, m22 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.y = Math.atan2( - m31, m11 );\r\n\t\t\t\t\tthis.z = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'ZXY':\r\n\r\n\t\t\t\tthis.x = Math.asin( clamp( m32, - 1, 1 ) );\r\n\r\n\t\t\t\tif ( Math.abs( m32 ) < 0.9999999 ) {\r\n\r\n\t\t\t\t\tthis.y = Math.atan2( - m31, m33 );\r\n\t\t\t\t\tthis.z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.y = 0;\r\n\t\t\t\t\tthis.z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'ZYX':\r\n\r\n\t\t\t\tthis.y = Math.asin( - clamp( m31, - 1, 1 ) );\r\n\r\n\t\t\t\tif ( Math.abs( m31 ) < 0.9999999 ) {\r\n\r\n\t\t\t\t\tthis.x = Math.atan2( m32, m33 );\r\n\t\t\t\t\tthis.z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.x = 0;\r\n\t\t\t\t\tthis.z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'YZX':\r\n\r\n\t\t\t\tthis.z = Math.asin( clamp( m21, - 1, 1 ) );\r\n\r\n\t\t\t\tif ( Math.abs( m21 ) < 0.9999999 ) {\r\n\r\n\t\t\t\t\tthis.x = Math.atan2( - m23, m22 );\r\n\t\t\t\t\tthis.y = Math.atan2( - m31, m11 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.x = 0;\r\n\t\t\t\t\tthis.y = Math.atan2( m13, m33 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'XZY':\r\n\r\n\t\t\t\tthis.z = Math.asin( - clamp( m12, - 1, 1 ) );\r\n\r\n\t\t\t\tif ( Math.abs( m12 ) < 0.9999999 ) {\r\n\r\n\t\t\t\t\tthis.x = Math.atan2( m32, m22 );\r\n\t\t\t\t\tthis.y = Math.atan2( m13, m11 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.x = Math.atan2( - m23, m33 );\r\n\t\t\t\t\tthis.y = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );\r\n\r\n\t\t}\r\n\r\n\t\tthis.order = order;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromQuaternion( q:Quaternion, order:string ) {\r\n\r\n\t\t_matrix.makeRotationFromQuaternion( q );\r\n\r\n\t\treturn this.setFromRotationMatrix( _matrix, order );\r\n\r\n\t}\r\n\r\n\tsetFromVector3( v:Vector3, order = this.order ) {\r\n\r\n\t\treturn this.set( v.x, v.y, v.z, order );\r\n\r\n\t}\r\n\r\n\treorder( newOrder:string ) {\r\n\r\n\t\t// WARNING: this discards revolution information -bhouston\r\n\r\n\t\t_quaternion.setFromEuler( this );\r\n\r\n\t\treturn this.setFromQuaternion( _quaternion, newOrder );\r\n\r\n\t}\r\n\r\n\tequals( euler:Euler ) {\r\n\r\n\t\treturn ( euler.x === this.x ) && ( euler.y === this.y ) && ( euler.z === this.z ) && ( euler.order === this.order );\r\n\r\n\t}\r\n\r\n\tfromArray( array:Array<any> ) {\r\n\r\n\t\tthis.x = array[ 0 ];\r\n\t\tthis.y = array[ 1 ];\r\n\t\tthis.z = array[ 2 ];\r\n\t\tif ( array[ 3 ] !== undefined ) this.order = array[ 3 ];\r\n\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\ttoArray( array:Array<number | string> = [], offset = 0 ) {\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\t\tarray[ offset + 2 ] = this.z;\r\n\t\tarray[ offset + 3 ] = this.order;\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n\t*[ Symbol.iterator ]() {\r\n\r\n\t\tyield this.x;\r\n\t\tyield this.y;\r\n\t\tyield this.z;\r\n\t\tyield this.order;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { Euler };\r\n","import { NumberArrayType } from \"../Constants\";\r\n\r\nconst _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];\r\n\r\nlet _seed = 1234567;\r\n\r\n\r\nconst DEG2RAD = Math.PI / 180;\r\nconst RAD2DEG = 180 / Math.PI;\r\n\r\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\r\nfunction generateUUID() {\r\n\r\n\tconst d0 = Math.random() * 0xffffffff | 0;\r\n\tconst d1 = Math.random() * 0xffffffff | 0;\r\n\tconst d2 = Math.random() * 0xffffffff | 0;\r\n\tconst d3 = Math.random() * 0xffffffff | 0;\r\n\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\r\n\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\r\n\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\r\n\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\r\n\r\n\t// .toLowerCase() here flattens concatenated strings to save heap memory space.\r\n\treturn uuid.toLowerCase();\r\n\r\n}\r\n\r\nfunction clamp( value:number, min:number, max:number ) {\r\n\r\n\treturn Math.max( min, Math.min( max, value ) );\r\n\r\n}\r\n\r\n// compute euclidean modulo of m % n\r\n// https://en.wikipedia.org/wiki/Modulo_operation\r\nfunction euclideanModulo( n:number, m:number ) {\r\n\r\n\treturn ( ( n % m ) + m ) % m;\r\n\r\n}\r\n\r\n// Linear mapping from range <a1, a2> to range <b1, b2>\r\nfunction mapLinear( x:number, a1:number, a2:number, b1:number, b2:number ) {\r\n\r\n\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\r\n}\r\n\r\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\r\nfunction inverseLerp( x:number, y:number, value:number ) {\r\n\r\n\tif ( x !== y ) {\r\n\r\n\t\treturn ( value - x ) / ( y - x );\r\n\r\n\t} else {\r\n\r\n\t\treturn 0;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// https://en.wikipedia.org/wiki/Linear_interpolation\r\nfunction lerp( x:number, y:number, t:number ) {\r\n\r\n\treturn ( 1 - t ) * x + t * y;\r\n\r\n}\r\n\r\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\r\nfunction damp( x:number, y:number, lambda:number, dt:number ) {\r\n\r\n\treturn lerp( x, y, 1 - Math.exp( - lambda * dt ) );\r\n\r\n}\r\n\r\n// https://www.desmos.com/calculator/vcsjnyz7x4\r\nfunction pingpong( x:number, length = 1 ) {\r\n\r\n\treturn length - Math.abs( euclideanModulo( x, length * 2 ) - length );\r\n\r\n}\r\n\r\n// http://en.wikipedia.org/wiki/Smoothstep\r\nfunction smoothstep( x:number, min:number, max:number ) {\r\n\r\n\tif ( x <= min ) return 0;\r\n\tif ( x >= max ) return 1;\r\n\r\n\tx = ( x - min ) / ( max - min );\r\n\r\n\treturn x * x * ( 3 - 2 * x );\r\n\r\n}\r\n\r\nfunction smootherstep( x:number, min:number, max:number ) {\r\n\r\n\tif ( x <= min ) return 0;\r\n\tif ( x >= max ) return 1;\r\n\r\n\tx = ( x - min ) / ( max - min );\r\n\r\n\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\r\n\r\n}\r\n\r\n// Random integer from <low, high> interval\r\nfunction randInt( low:number, high:number ) {\r\n\r\n\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\r\n\r\n}\r\n\r\n// Random float from <low, high> interval\r\nfunction randFloat( low:number, high:number ) {\r\n\r\n\treturn low + Math.random() * ( high - low );\r\n\r\n}\r\n\r\n// Random float from <-range/2, range/2> interval\r\nfunction randFloatSpread( range:number ) {\r\n\r\n\treturn range * ( 0.5 - Math.random() );\r\n\r\n}\r\n\r\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\r\nfunction seededRandom( s:number ) {\r\n\r\n\tif ( s !== undefined ) _seed = s;\r\n\r\n\t// Mulberry32 generator\r\n\r\n\tlet t = _seed += 0x6D2B79F5;\r\n\r\n\tt = Math.imul( t ^ t >>> 15, t | 1 );\r\n\r\n\tt ^= t + Math.imul( t ^ t >>> 7, t | 61 );\r\n\r\n\treturn ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;\r\n\r\n}\r\n\r\nfunction degToRad( degrees:number ) {\r\n\r\n\treturn degrees * DEG2RAD;\r\n\r\n}\r\n\r\nfunction radToDeg( radians:number ) {\r\n\r\n\treturn radians * RAD2DEG;\r\n\r\n}\r\n\r\nfunction isPowerOfTwo( value:number ) {\r\n\r\n\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\r\n\r\n}\r\n\r\nfunction ceilPowerOfTwo( value:number ) {\r\n\r\n\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\r\n\r\n}\r\n\r\nfunction floorPowerOfTwo( value:number ) {\r\n\r\n\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\r\n\r\n}\r\n\r\nfunction denormalize( value:number, array:NumberArrayType ) {\r\n\r\n\tswitch ( array.constructor ) {\r\n\r\n\t\tcase Float32Array:\r\n\r\n\t\t\treturn value;\r\n\r\n\t\tcase Uint32Array:\r\n\r\n\t\t\treturn value / 4294967295.0;\r\n\r\n\t\tcase Uint16Array:\r\n\r\n\t\t\treturn value / 65535.0;\r\n\r\n\t\tcase Uint8Array:\r\n\r\n\t\t\treturn value / 255.0;\r\n\r\n\t\tcase Int32Array:\r\n\r\n\t\t\treturn Math.max( value / 2147483647.0, - 1.0 );\r\n\r\n\t\tcase Int16Array:\r\n\r\n\t\t\treturn Math.max( value / 32767.0, - 1.0 );\r\n\r\n\t\tcase Int8Array:\r\n\r\n\t\t\treturn Math.max( value / 127.0, - 1.0 );\r\n\r\n\t\tdefault:\r\n\r\n\t\t\tthrow new Error( 'Invalid component type.' );\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction normalize( value:number, array:NumberArrayType ) {\r\n\r\n\tswitch ( array.constructor ) {\r\n\r\n\t\tcase Float32Array:\r\n\r\n\t\t\treturn value;\r\n\r\n\t\tcase Uint32Array:\r\n\r\n\t\t\treturn Math.round( value * 4294967295.0 );\r\n\r\n\t\tcase Uint16Array:\r\n\r\n\t\t\treturn Math.round( value * 65535.0 );\r\n\r\n\t\tcase Uint8Array:\r\n\r\n\t\t\treturn Math.round( value * 255.0 );\r\n\r\n\t\tcase Int32Array:\r\n\r\n\t\t\treturn Math.round( value * 2147483647.0 );\r\n\r\n\t\tcase Int16Array:\r\n\r\n\t\t\treturn Math.round( value * 32767.0 );\r\n\r\n\t\tcase Int8Array:\r\n\r\n\t\t\treturn Math.round( value * 127.0 );\r\n\r\n\t\tdefault:\r\n\r\n\t\t\tthrow new Error( 'Invalid component type.' );\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst MathUtils = {\r\n\tDEG2RAD: DEG2RAD,\r\n\tRAD2DEG: RAD2DEG,\r\n\tgenerateUUID: generateUUID,\r\n\tclamp: clamp,\r\n\teuclideanModulo: euclideanModulo,\r\n\tmapLinear: mapLinear,\r\n\tinverseLerp: inverseLerp,\r\n\tlerp: lerp,\r\n\tdamp: damp,\r\n\tpingpong: pingpong,\r\n\tsmoothstep: smoothstep,\r\n\tsmootherstep: smootherstep,\r\n\trandInt: randInt,\r\n\trandFloat: randFloat,\r\n\trandFloatSpread: randFloatSpread,\r\n\tseededRandom: seededRandom,\r\n\tdegToRad: degToRad,\r\n\tradToDeg: radToDeg,\r\n\tisPowerOfTwo: isPowerOfTwo,\r\n\tceilPowerOfTwo: ceilPowerOfTwo,\r\n\tfloorPowerOfTwo: floorPowerOfTwo,\r\n\tnormalize: normalize,\r\n\tdenormalize: denormalize\r\n};\r\n\r\nexport {\r\n\tDEG2RAD,\r\n\tRAD2DEG,\r\n\tgenerateUUID,\r\n\tclamp,\r\n\teuclideanModulo,\r\n\tmapLinear,\r\n\tinverseLerp,\r\n\tlerp,\r\n\tdamp,\r\n\tpingpong,\r\n\tsmoothstep,\r\n\tsmootherstep,\r\n\trandInt,\r\n\trandFloat,\r\n\trandFloatSpread,\r\n\tseededRandom,\r\n\tdegToRad,\r\n\tradToDeg,\r\n\tisPowerOfTwo,\r\n\tceilPowerOfTwo,\r\n\tfloorPowerOfTwo,\r\n\tnormalize,\r\n\tdenormalize,\r\n\tMathUtils\r\n};\r\n","import { Matrix4 } from \"./Matrix4\";\r\nimport { Vector2 } from \"./Vector2\";\r\nimport { Vector3 } from \"./Vector3\";\r\n\r\nclass Matrix3 {\r\n    public elements = [\r\n\r\n        1, 0, 0,\r\n        0, 1, 0,\r\n        0, 0, 1\r\n\r\n    ];\r\n\tconstructor( \r\n        n11 = 1, n12 = 0, n13 = 0, \r\n        n21 = 0, n22 = 1, n23 = 0, \r\n        n31 = 0, n32 = 0, n33 = 1 \r\n        ) {\r\n\r\n\t\tif ( n11 !== undefined ) {\r\n\r\n\t\t\tthis.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tset( n11 = 1, n12 = 0, n13 = 0, \r\n        n21 = 0, n22 = 1, n23 = 0, \r\n        n31 = 0, n32 = 0, n33 = 1\r\n        ) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\r\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\r\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tidentity() {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0,\r\n\t\t\t0, 1, 0,\r\n\t\t\t0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tcopy( m:Matrix3 ) {\r\n\r\n\t\tconst te = this.elements;\r\n\t\tconst me = m.elements;\r\n\r\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\r\n\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\r\n\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\textractBasis( xAxis:Vector3, yAxis:Vector3, zAxis:Vector3 ) {\r\n\r\n\t\txAxis.setFromMatrix3Column( this, 0 );\r\n\t\tyAxis.setFromMatrix3Column( this, 1 );\r\n\t\tzAxis.setFromMatrix3Column( this, 2 );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromMatrix4( m:Matrix4 ) {\r\n\r\n\t\tconst me = m.elements;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\r\n\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\r\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmultiply( m:Matrix3 ) {\r\n\r\n\t\treturn this.multiplyMatrices( this, m );\r\n\r\n\t}\r\n\r\n\tpremultiply( m:Matrix3 ) {\r\n\r\n\t\treturn this.multiplyMatrices( m, this );\r\n\r\n\t}\r\n\r\n\tmultiplyMatrices( a:Matrix3, b:Matrix3 ) {\r\n\r\n\t\tconst ae = a.elements;\r\n\t\tconst be = b.elements;\r\n\t\tconst te = this.elements;\r\n\r\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\r\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\r\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\r\n\r\n\t\tconst b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\r\n\t\tconst b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\r\n\t\tconst b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\r\n\r\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\r\n\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\r\n\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\r\n\r\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\r\n\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\r\n\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\r\n\r\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\r\n\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\r\n\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmultiplyScalar( s:number ) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\r\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\r\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tdeterminant() {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tconst a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\r\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\r\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\r\n\r\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\r\n\r\n\t}\r\n\r\n\tinvert() {\r\n\r\n\t\tconst te = this.elements,\r\n\r\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],\r\n\t\t\tn12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],\r\n\t\t\tn13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],\r\n\r\n\t\t\tt11 = n33 * n22 - n32 * n23,\r\n\t\t\tt12 = n32 * n13 - n33 * n12,\r\n\t\t\tt13 = n23 * n12 - n22 * n13,\r\n\r\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\r\n\r\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\r\n\r\n\t\tconst detInv = 1 / det;\r\n\r\n\t\tte[ 0 ] = t11 * detInv;\r\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\r\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\r\n\r\n\t\tte[ 3 ] = t12 * detInv;\r\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\r\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\r\n\r\n\t\tte[ 6 ] = t13 * detInv;\r\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\r\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\ttranspose() {\r\n\r\n\t\tlet tmp;\r\n\t\tconst m = this.elements;\r\n\r\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\r\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\r\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tgetNormalMatrix( matrix4:Matrix4 ) {\r\n\r\n\t\treturn this.setFromMatrix4( matrix4 ).invert().transpose();\r\n\r\n\t}\r\n\r\n\ttransposeIntoArray( r:Array<number> ) {\r\n\r\n\t\tconst m = this.elements;\r\n\r\n\t\tr[ 0 ] = m[ 0 ];\r\n\t\tr[ 1 ] = m[ 3 ];\r\n\t\tr[ 2 ] = m[ 6 ];\r\n\t\tr[ 3 ] = m[ 1 ];\r\n\t\tr[ 4 ] = m[ 4 ];\r\n\t\tr[ 5 ] = m[ 7 ];\r\n\t\tr[ 6 ] = m[ 2 ];\r\n\t\tr[ 7 ] = m[ 5 ];\r\n\t\tr[ 8 ] = m[ 8 ];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetUvTransform( tx:number, ty:number, sx:number, sy:number, rotation:number, cx:number, cy:number ) {\r\n\r\n\t\tconst c = Math.cos( rotation );\r\n\t\tconst s = Math.sin( rotation );\r\n\r\n\t\tthis.set(\r\n\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\r\n\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\r\n\t\t\t0, 0, 1\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tscale( sx:number, sy:number ) {\r\n\r\n\t\tthis.premultiply( _m3.makeScale( sx, sy ) );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\trotate( theta:number ) {\r\n\r\n\t\tthis.premultiply( _m3.makeRotation( - theta ) );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\ttranslate( tx:Vector2 ) {\r\n\r\n\t\tthis.premultiply( _m3.makeTranslation( tx ) );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t// for 2D Transforms\r\n\r\n\tmakeTranslation( x:Vector2 ) {\r\n\r\n        this.set(\r\n\r\n            1, 0, x.x,\r\n            0, 1, x.y,\r\n            0, 0, 1\r\n\r\n        );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmakeRotation( theta:number ) {\r\n\r\n\t\t// counterclockwise\r\n\r\n\t\tconst c = Math.cos( theta );\r\n\t\tconst s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tc, - s, 0,\r\n\t\t\ts, c, 0,\r\n\t\t\t0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmakeScale( x:number, y:number ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tx, 0, 0,\r\n\t\t\t0, y, 0,\r\n\t\t\t0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tequals( matrix:Matrix3 ) {\r\n\r\n\t\tconst te = this.elements;\r\n\t\tconst me = matrix.elements;\r\n\r\n\t\tfor ( let i = 0; i < 9; i ++ ) {\r\n\r\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tfromArray( array:Array<number>, offset = 0 ) {\r\n\r\n\t\tfor ( let i = 0; i < 9; i ++ ) {\r\n\r\n\t\t\tthis.elements[ i ] = array[ i + offset ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\ttoArray( array:Array<number> = [], offset = 0 ) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tarray[ offset ] = te[ 0 ];\r\n\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\r\n\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\r\n\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\t\tarray[ offset + 8 ] = te[ 8 ];\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new Matrix3().fromArray( this.elements );\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst _m3 = /*@__PURE__*/ new Matrix3();\r\n\r\nexport { Matrix3 };\r\n","import { Euler } from \"./Euler\";\r\nimport { Matrix3 } from \"./Matrix3\";\r\nimport { Quaternion } from \"./Quaternion\";\r\nimport { Vector3 } from \"./Vector3\";\r\n\r\n\r\nclass Matrix4 {\r\n    public elements = [\r\n        1, 0, 0, 0,\r\n        0, 1, 0, 0,\r\n        0, 0, 1, 0,\r\n        0, 0, 0, 1\r\n    ];\r\n\r\n\tconstructor( \r\n        n11 = 1, n12 = 0, n13 = 0, n14 = 0, \r\n        n21 = 0, n22 = 1, n23 = 0, n24 = 0, \r\n        n31 = 0, n32 = 0, n33 = 1, n34 = 0, \r\n        n41 = 0, n42 = 0, n43 = 0, n44 = 1\r\n        ) {\r\n\r\n\t\tif ( n11 !== undefined ) {\r\n\r\n\t\t\tthis.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tset( n11:number, n12:number, n13:number, n14:number, \r\n        n21:number, n22:number, n23:number, n24:number, \r\n        n31:number, n32:number, n33:number, n34:number, \r\n        n41:number, n42:number, n43:number, n44:number  \r\n        ) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\r\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\r\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\r\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tidentity() {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, 1, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new Matrix4().fromArray( this.elements );\r\n\r\n\t}\r\n\r\n\tcopy( m:Matrix4 ) {\r\n\r\n\t\tconst te = this.elements;\r\n\t\tconst me = m.elements;\r\n\r\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\r\n\t\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\r\n\t\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\r\n\t\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tcopyPosition( m:Matrix4 ) {\r\n\r\n\t\tconst te = this.elements, me = m.elements;\r\n\r\n\t\tte[ 12 ] = me[ 12 ];\r\n\t\tte[ 13 ] = me[ 13 ];\r\n\t\tte[ 14 ] = me[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromMatrix3( m:Matrix3 ) {\r\n\r\n\t\tconst me = m.elements;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ], 0,\r\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ], 0,\r\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ], 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\textractBasis( xAxis:Vector3, yAxis:Vector3, zAxis:Vector3 ) {\r\n\r\n\t\txAxis.setFromMatrixColumn( this, 0 );\r\n\t\tyAxis.setFromMatrixColumn( this, 1 );\r\n\t\tzAxis.setFromMatrixColumn( this, 2 );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmakeBasis( xAxis:Vector3, yAxis:Vector3, zAxis:Vector3 ) {\r\n\r\n\t\tthis.set(\r\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\r\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\r\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\r\n\t\t\t0, 0, 0, 1\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\textractRotation( m:Matrix4 ) {\r\n\r\n\t\t// this method does not support reflection matrices\r\n\r\n\t\tconst te = this.elements;\r\n\t\tconst me = m.elements;\r\n\r\n\t\tconst scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();\r\n\t\tconst scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();\r\n\t\tconst scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();\r\n\r\n\t\tte[ 0 ] = me[ 0 ] * scaleX;\r\n\t\tte[ 1 ] = me[ 1 ] * scaleX;\r\n\t\tte[ 2 ] = me[ 2 ] * scaleX;\r\n\t\tte[ 3 ] = 0;\r\n\r\n\t\tte[ 4 ] = me[ 4 ] * scaleY;\r\n\t\tte[ 5 ] = me[ 5 ] * scaleY;\r\n\t\tte[ 6 ] = me[ 6 ] * scaleY;\r\n\t\tte[ 7 ] = 0;\r\n\r\n\t\tte[ 8 ] = me[ 8 ] * scaleZ;\r\n\t\tte[ 9 ] = me[ 9 ] * scaleZ;\r\n\t\tte[ 10 ] = me[ 10 ] * scaleZ;\r\n\t\tte[ 11 ] = 0;\r\n\r\n\t\tte[ 12 ] = 0;\r\n\t\tte[ 13 ] = 0;\r\n\t\tte[ 14 ] = 0;\r\n\t\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmakeRotationFromEuler( euler:Euler ) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tconst x = euler.x, y = euler.y, z = euler.z;\r\n\t\tconst a = Math.cos( x ), b = Math.sin( x );\r\n\t\tconst c = Math.cos( y ), d = Math.sin( y );\r\n\t\tconst e = Math.cos( z ), f = Math.sin( z );\r\n\r\n\t\tif ( euler.order === 'XYZ' ) {\r\n\r\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = - c * f;\r\n\t\t\tte[ 8 ] = d;\r\n\r\n\t\t\tte[ 1 ] = af + be * d;\r\n\t\t\tte[ 5 ] = ae - bf * d;\r\n\t\t\tte[ 9 ] = - b * c;\r\n\r\n\t\t\tte[ 2 ] = bf - ae * d;\r\n\t\t\tte[ 6 ] = be + af * d;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'YXZ' ) {\r\n\r\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[ 0 ] = ce + df * b;\r\n\t\t\tte[ 4 ] = de * b - cf;\r\n\t\t\tte[ 8 ] = a * d;\r\n\r\n\t\t\tte[ 1 ] = a * f;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = - b;\r\n\r\n\t\t\tte[ 2 ] = cf * b - de;\r\n\t\t\tte[ 6 ] = df + ce * b;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'ZXY' ) {\r\n\r\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[ 0 ] = ce - df * b;\r\n\t\t\tte[ 4 ] = - a * f;\r\n\t\t\tte[ 8 ] = de + cf * b;\r\n\r\n\t\t\tte[ 1 ] = cf + de * b;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = df - ce * b;\r\n\r\n\t\t\tte[ 2 ] = - a * d;\r\n\t\t\tte[ 6 ] = b;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'ZYX' ) {\r\n\r\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = be * d - af;\r\n\t\t\tte[ 8 ] = ae * d + bf;\r\n\r\n\t\t\tte[ 1 ] = c * f;\r\n\t\t\tte[ 5 ] = bf * d + ae;\r\n\t\t\tte[ 9 ] = af * d - be;\r\n\r\n\t\t\tte[ 2 ] = - d;\r\n\t\t\tte[ 6 ] = b * c;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'YZX' ) {\r\n\r\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = bd - ac * f;\r\n\t\t\tte[ 8 ] = bc * f + ad;\r\n\r\n\t\t\tte[ 1 ] = f;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = - b * e;\r\n\r\n\t\t\tte[ 2 ] = - d * e;\r\n\t\t\tte[ 6 ] = ad * f + bc;\r\n\t\t\tte[ 10 ] = ac - bd * f;\r\n\r\n\t\t} else if ( euler.order === 'XZY' ) {\r\n\r\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = - f;\r\n\t\t\tte[ 8 ] = d * e;\r\n\r\n\t\t\tte[ 1 ] = ac * f + bd;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = ad * f - bc;\r\n\r\n\t\t\tte[ 2 ] = bc * f - ad;\r\n\t\t\tte[ 6 ] = b * e;\r\n\t\t\tte[ 10 ] = bd * f + ac;\r\n\r\n\t\t}\r\n\r\n\t\t// bottom row\r\n\t\tte[ 3 ] = 0;\r\n\t\tte[ 7 ] = 0;\r\n\t\tte[ 11 ] = 0;\r\n\r\n\t\t// last column\r\n\t\tte[ 12 ] = 0;\r\n\t\tte[ 13 ] = 0;\r\n\t\tte[ 14 ] = 0;\r\n\t\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmakeRotationFromQuaternion( q:Quaternion ) {\r\n\r\n\t\treturn this.compose( _zero, q, _one );\r\n\r\n\t}\r\n\r\n\tlookAt( eye:Vector3, target:Vector3, up:Vector3 ) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\t_z.subVectors( eye, target );\r\n\r\n\t\tif ( _z.lengthSq() === 0 ) {\r\n\r\n\t\t\t// eye and target are in the same position\r\n\r\n\t\t\t_z.z = 1;\r\n\r\n\t\t}\r\n\r\n\t\t_z.normalize();\r\n\t\t_x.crossVectors( up, _z );\r\n\r\n\t\tif ( _x.lengthSq() === 0 ) {\r\n\r\n\t\t\t// up and z are parallel\r\n\r\n\t\t\tif ( Math.abs( up.z ) === 1 ) {\r\n\r\n\t\t\t\t_z.x += 0.0001;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_z.z += 0.0001;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_z.normalize();\r\n\t\t\t_x.crossVectors( up, _z );\r\n\r\n\t\t}\r\n\r\n\t\t_x.normalize();\r\n\t\t_y.crossVectors( _z, _x );\r\n\r\n\t\tte[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;\r\n\t\tte[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;\r\n\t\tte[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmultiply( m:Matrix4 ) {\r\n\r\n\t\treturn this.multiplyMatrices( this, m );\r\n\r\n\t}\r\n\r\n\tpremultiply( m:Matrix4 ) {\r\n\r\n\t\treturn this.multiplyMatrices( m, this );\r\n\r\n\t}\r\n\r\n\tmultiplyMatrices( a:Matrix4, b:Matrix4 ) {\r\n\r\n\t\tconst ae = a.elements;\r\n\t\tconst be = b.elements;\r\n\t\tconst te = this.elements;\r\n\r\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\r\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\r\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\r\n\t\tconst a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\r\n\r\n\t\tconst b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\r\n\t\tconst b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\r\n\t\tconst b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\r\n\t\tconst b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\r\n\r\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\r\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\r\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\r\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmultiplyScalar( s:number ) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\r\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\r\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\r\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tdeterminant() {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tconst n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\r\n\t\tconst n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\r\n\t\tconst n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\r\n\t\tconst n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\r\n\r\n\t\t//TODO: make this more efficient\r\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\r\n\t\treturn (\r\n\t\t\tn41 * (\r\n\t\t\t\t+ n14 * n23 * n32\r\n\t\t\t\t - n13 * n24 * n32\r\n\t\t\t\t - n14 * n22 * n33\r\n\t\t\t\t + n12 * n24 * n33\r\n\t\t\t\t + n13 * n22 * n34\r\n\t\t\t\t - n12 * n23 * n34\r\n\t\t\t) +\r\n\t\t\tn42 * (\r\n\t\t\t\t+ n11 * n23 * n34\r\n\t\t\t\t - n11 * n24 * n33\r\n\t\t\t\t + n14 * n21 * n33\r\n\t\t\t\t - n13 * n21 * n34\r\n\t\t\t\t + n13 * n24 * n31\r\n\t\t\t\t - n14 * n23 * n31\r\n\t\t\t) +\r\n\t\t\tn43 * (\r\n\t\t\t\t+ n11 * n24 * n32\r\n\t\t\t\t - n11 * n22 * n34\r\n\t\t\t\t - n14 * n21 * n32\r\n\t\t\t\t + n12 * n21 * n34\r\n\t\t\t\t + n14 * n22 * n31\r\n\t\t\t\t - n12 * n24 * n31\r\n\t\t\t) +\r\n\t\t\tn44 * (\r\n\t\t\t\t- n13 * n22 * n31\r\n\t\t\t\t - n11 * n23 * n32\r\n\t\t\t\t + n11 * n22 * n33\r\n\t\t\t\t + n13 * n21 * n32\r\n\t\t\t\t - n12 * n21 * n33\r\n\t\t\t\t + n12 * n23 * n31\r\n\t\t\t)\r\n\r\n\t\t);\r\n\r\n\t}\r\n\r\n\ttranspose() {\r\n\r\n\t\tconst te = this.elements;\r\n\t\tlet tmp;\r\n\r\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\r\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\r\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\r\n\r\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\r\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\r\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetPosition( x:Vector3 ) {\r\n\r\n\t\tconst te = this.elements;\r\n        \r\n        te[ 12 ] = x.x;\r\n        te[ 13 ] = x.y;\r\n        te[ 14 ] = x.z;\r\n\r\n\t\t \r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tinvert() {\r\n\r\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t\tconst te = this.elements,\r\n\r\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],\r\n\t\t\tn12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],\r\n\t\t\tn13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],\r\n\t\t\tn14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],\r\n\r\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\r\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\r\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\r\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\r\n\r\n\t\tconst det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\r\n\r\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );\r\n\r\n\t\tconst detInv = 1 / det;\r\n\r\n\t\tte[ 0 ] = t11 * detInv;\r\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\r\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\r\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\r\n\r\n\t\tte[ 4 ] = t12 * detInv;\r\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\r\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\r\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\r\n\r\n\t\tte[ 8 ] = t13 * detInv;\r\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\r\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\r\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\r\n\r\n\t\tte[ 12 ] = t14 * detInv;\r\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\r\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\r\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tscale( v:Vector3 ) {\r\n\r\n\t\tconst te = this.elements;\r\n\t\tconst x = v.x, y = v.y, z = v.z;\r\n\r\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\r\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\r\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\r\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tgetMaxScaleOnAxis() {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tconst scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\r\n\t\tconst scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\r\n\t\tconst scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\r\n\r\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\r\n\r\n\t}\r\n\r\n\tmakeTranslation( x:Vector3 ) {\r\n\r\n        this.set(\r\n\r\n            1, 0, 0, x.x,\r\n            0, 1, 0, x.y,\r\n            0, 0, 1, x.z,\r\n            0, 0, 0, 1\r\n\r\n        );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmakeRotationX( theta:number ) {\r\n\r\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, c, - s, 0,\r\n\t\t\t0, s, c, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmakeRotationY( theta:number ) {\r\n\r\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t c, 0, s, 0,\r\n\t\t\t 0, 1, 0, 0,\r\n\t\t\t- s, 0, c, 0,\r\n\t\t\t 0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmakeRotationZ( theta:number ) {\r\n\r\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tc, - s, 0, 0,\r\n\t\t\ts, c, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmakeRotationAxis( axis:Vector3, angle:number ) {\r\n\r\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\r\n\t\tconst c = Math.cos( angle );\r\n\t\tconst s = Math.sin( angle );\r\n\t\tconst t = 1 - c;\r\n\t\tconst x = axis.x, y = axis.y, z = axis.z;\r\n\t\tconst tx = t * x, ty = t * y;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmakeScale( x:number, y:number, z:number ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tx, 0, 0, 0,\r\n\t\t\t0, y, 0, 0,\r\n\t\t\t0, 0, z, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmakeShear( xy:number, xz:number, yx:number, yz:number, zx:number, zy:number ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, yx, zx, 0,\r\n\t\t\txy, 1, zy, 0,\r\n\t\t\txz, yz, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tcompose( position:Vector3, quaternion:Quaternion, scale:Vector3 ) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tconst x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;\r\n\t\tconst x2 = x + x,\ty2 = y + y, z2 = z + z;\r\n\t\tconst xx = x * x2, xy = x * y2, xz = x * z2;\r\n\t\tconst yy = y * y2, yz = y * z2, zz = z * z2;\r\n\t\tconst wx = w * x2, wy = w * y2, wz = w * z2;\r\n\r\n\t\tconst sx = scale.x, sy = scale.y, sz = scale.z;\r\n\r\n\t\tte[ 0 ] = ( 1 - ( yy + zz ) ) * sx;\r\n\t\tte[ 1 ] = ( xy + wz ) * sx;\r\n\t\tte[ 2 ] = ( xz - wy ) * sx;\r\n\t\tte[ 3 ] = 0;\r\n\r\n\t\tte[ 4 ] = ( xy - wz ) * sy;\r\n\t\tte[ 5 ] = ( 1 - ( xx + zz ) ) * sy;\r\n\t\tte[ 6 ] = ( yz + wx ) * sy;\r\n\t\tte[ 7 ] = 0;\r\n\r\n\t\tte[ 8 ] = ( xz + wy ) * sz;\r\n\t\tte[ 9 ] = ( yz - wx ) * sz;\r\n\t\tte[ 10 ] = ( 1 - ( xx + yy ) ) * sz;\r\n\t\tte[ 11 ] = 0;\r\n\r\n\t\tte[ 12 ] = position.x;\r\n\t\tte[ 13 ] = position.y;\r\n\t\tte[ 14 ] = position.z;\r\n\t\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tdecompose( position:Vector3, quaternion:Quaternion, scale:Vector3 ) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tlet sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\r\n\t\tconst sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\r\n\t\tconst sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\r\n\r\n\t\t// if determine is negative, we need to invert one scale\r\n\t\tconst det = this.determinant();\r\n\t\tif ( det < 0 ) sx = - sx;\r\n\r\n\t\tposition.x = te[ 12 ];\r\n\t\tposition.y = te[ 13 ];\r\n\t\tposition.z = te[ 14 ];\r\n\r\n\t\t// scale the rotation part\r\n\t\t_m1.copy( this );\r\n\r\n\t\tconst invSX = 1 / sx;\r\n\t\tconst invSY = 1 / sy;\r\n\t\tconst invSZ = 1 / sz;\r\n\r\n\t\t_m1.elements[ 0 ] *= invSX;\r\n\t\t_m1.elements[ 1 ] *= invSX;\r\n\t\t_m1.elements[ 2 ] *= invSX;\r\n\r\n\t\t_m1.elements[ 4 ] *= invSY;\r\n\t\t_m1.elements[ 5 ] *= invSY;\r\n\t\t_m1.elements[ 6 ] *= invSY;\r\n\r\n\t\t_m1.elements[ 8 ] *= invSZ;\r\n\t\t_m1.elements[ 9 ] *= invSZ;\r\n\t\t_m1.elements[ 10 ] *= invSZ;\r\n\r\n\t\tquaternion.setFromRotationMatrix( _m1 );\r\n\r\n\t\tscale.x = sx;\r\n\t\tscale.y = sy;\r\n\t\tscale.z = sz;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmakePerspective( left:number, right:number, top:number, bottom:number, near:number, far:number ) {\r\n\r\n\t\tconst te = this.elements;\r\n\t\tconst x = 2 * near / ( right - left );\r\n\t\tconst y = 2 * near / ( top - bottom );\r\n\r\n\t\tconst a = ( right + left ) / ( right - left );\r\n\t\tconst b = ( top + bottom ) / ( top - bottom );\r\n\t\tconst c = - ( far + near ) / ( far - near );\r\n\t\tconst d = - 2 * far * near / ( far - near );\r\n\r\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\r\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\r\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\r\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmakeOrthographic( left:number, right:number, top:number, bottom:number, near:number, far:number ) {\r\n\r\n\t\tconst te = this.elements;\r\n\t\tconst w = 1.0 / ( right - left );\r\n\t\tconst h = 1.0 / ( top - bottom );\r\n\t\tconst p = 1.0 / ( far - near );\r\n\r\n\t\tconst x = ( right + left ) * w;\r\n\t\tconst y = ( top + bottom ) * h;\r\n\t\tconst z = ( far + near ) * p;\r\n\r\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\r\n\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\r\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\r\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tequals( matrix:Matrix4 ) {\r\n\r\n\t\tconst te = this.elements;\r\n\t\tconst me = matrix.elements;\r\n\r\n\t\tfor ( let i = 0; i < 16; i ++ ) {\r\n\r\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tfromArray( array:Array<number>, offset = 0 ) {\r\n\r\n\t\tfor ( let i = 0; i < 16; i ++ ) {\r\n\r\n\t\t\tthis.elements[ i ] = array[ i + offset ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\ttoArray( array:Float32Array = new Float32Array(16), offset = 0 ) {\r\n\r\n\t\tconst te = this.elements;\r\n\r\n\t\tarray[ offset ] = te[ 0 ];\r\n\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\r\n\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\r\n\t\tarray[ offset + 8 ] = te[ 8 ];\r\n\t\tarray[ offset + 9 ] = te[ 9 ];\r\n\t\tarray[ offset + 10 ] = te[ 10 ];\r\n\t\tarray[ offset + 11 ] = te[ 11 ];\r\n\r\n\t\tarray[ offset + 12 ] = te[ 12 ];\r\n\t\tarray[ offset + 13 ] = te[ 13 ];\r\n\t\tarray[ offset + 14 ] = te[ 14 ];\r\n\t\tarray[ offset + 15 ] = te[ 15 ];\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst _v1 = /*@__PURE__*/ new Vector3();\r\nconst _m1 = /*@__PURE__*/ new Matrix4();\r\nconst _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );\r\nconst _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );\r\nconst _x = /*@__PURE__*/ new Vector3();\r\nconst _y = /*@__PURE__*/ new Vector3();\r\nconst _z = /*@__PURE__*/ new Vector3();\r\n\r\nexport { Matrix4 };\r\n","import { Euler } from './Euler';\r\nimport * as MathUtils from './MathUtils';\r\nimport { Matrix4 } from './Matrix4';\r\nimport { Vector3 } from './Vector3';\r\n\r\nclass Quaternion {\r\n\r\n    public x = 0;\r\n    public y = 0;\r\n    public z = 0;\r\n    public w = 0;\r\n\r\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t\tthis.w = w;\r\n\r\n\t}\r\n\r\n\tstatic slerpFlat( dst:Array<number>, dstOffset:number, src0:Array<number>, srcOffset0:number, src1:Array<number>, srcOffset1:number, t:number ) {\r\n\r\n\t\t// fuzz-free, array-based Quaternion SLERP operation\r\n\r\n\t\tlet x0 = src0[ srcOffset0 + 0 ],\r\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\r\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\r\n\t\t\tw0 = src0[ srcOffset0 + 3 ];\r\n\r\n\t\tconst x1 = src1[ srcOffset1 + 0 ],\r\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\r\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\r\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\r\n\r\n\t\tif ( t === 0 ) {\r\n\r\n\t\t\tdst[ dstOffset + 0 ] = x0;\r\n\t\t\tdst[ dstOffset + 1 ] = y0;\r\n\t\t\tdst[ dstOffset + 2 ] = z0;\r\n\t\t\tdst[ dstOffset + 3 ] = w0;\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( t === 1 ) {\r\n\r\n\t\t\tdst[ dstOffset + 0 ] = x1;\r\n\t\t\tdst[ dstOffset + 1 ] = y1;\r\n\t\t\tdst[ dstOffset + 2 ] = z1;\r\n\t\t\tdst[ dstOffset + 3 ] = w1;\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\r\n\r\n\t\t\tlet s = 1 - t;\r\n\t\t\tconst cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\r\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\r\n\t\t\t\tsqrSin = 1 - cos * cos;\r\n\r\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\r\n\t\t\tif ( sqrSin > Number.EPSILON ) {\r\n\r\n\t\t\t\tconst sin = Math.sqrt( sqrSin ),\r\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\r\n\r\n\t\t\t\ts = Math.sin( s * len ) / sin;\r\n\t\t\t\tt = Math.sin( t * len ) / sin;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst tDir = t * dir;\r\n\r\n\t\t\tx0 = x0 * s + x1 * tDir;\r\n\t\t\ty0 = y0 * s + y1 * tDir;\r\n\t\t\tz0 = z0 * s + z1 * tDir;\r\n\t\t\tw0 = w0 * s + w1 * tDir;\r\n\r\n\t\t\t// Normalize in case we just did a lerp:\r\n\t\t\tif ( s === 1 - t ) {\r\n\r\n\t\t\t\tconst f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\r\n\r\n\t\t\t\tx0 *= f;\r\n\t\t\t\ty0 *= f;\r\n\t\t\t\tz0 *= f;\r\n\t\t\t\tw0 *= f;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdst[ dstOffset ] = x0;\r\n\t\tdst[ dstOffset + 1 ] = y0;\r\n\t\tdst[ dstOffset + 2 ] = z0;\r\n\t\tdst[ dstOffset + 3 ] = w0;\r\n\r\n\t}\r\n\r\n\tstatic multiplyQuaternionsFlat( dst:Array<number>, dstOffset:number, src0:Array<number>, srcOffset0:number, src1:Array<number>, srcOffset1:number ) {\r\n\r\n\t\tconst x0 = src0[ srcOffset0 ];\r\n\t\tconst y0 = src0[ srcOffset0 + 1 ];\r\n\t\tconst z0 = src0[ srcOffset0 + 2 ];\r\n\t\tconst w0 = src0[ srcOffset0 + 3 ];\r\n\r\n\t\tconst x1 = src1[ srcOffset1 ];\r\n\t\tconst y1 = src1[ srcOffset1 + 1 ];\r\n\t\tconst z1 = src1[ srcOffset1 + 2 ];\r\n\t\tconst w1 = src1[ srcOffset1 + 3 ];\r\n\r\n\t\tdst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\r\n\t\tdst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\r\n\t\tdst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\r\n\t\tdst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\r\n\r\n\t\treturn dst;\r\n\r\n\t}\r\n\r\n\tset( x:number, y:number, z:number, w:number ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new Quaternion( this.x, this.y, this.z, this.w );\r\n\r\n\t}\r\n\r\n\tcopy( quaternion:Quaternion ) {\r\n\r\n\t\tthis.x = quaternion.x;\r\n\t\tthis.y = quaternion.y;\r\n\t\tthis.z = quaternion.z;\r\n\t\tthis.w = quaternion.w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromEuler( euler:Euler) {\r\n\r\n\t\tconst x = euler.x, y = euler.y, z = euler.z, order = euler.order;\r\n\r\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\r\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n\t\t//\tcontent/SpinCalc.m\r\n\r\n\t\tconst cos = Math.cos;\r\n\t\tconst sin = Math.sin;\r\n\r\n\t\tconst c1 = cos( x / 2 );\r\n\t\tconst c2 = cos( y / 2 );\r\n\t\tconst c3 = cos( z / 2 );\r\n\r\n\t\tconst s1 = sin( x / 2 );\r\n\t\tconst s2 = sin( y / 2 );\r\n\t\tconst s3 = sin( z / 2 );\r\n\r\n\t\tswitch ( order ) {\r\n\r\n\t\t\tcase 'XYZ':\r\n\t\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'YXZ':\r\n\t\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'ZXY':\r\n\t\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'ZYX':\r\n\t\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'YZX':\r\n\t\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'XZY':\r\n\t\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromAxisAngle( axis:Vector3, angle:number ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\r\n\t\t// assumes axis is normalized\r\n\r\n\t\tconst halfAngle = angle / 2, s = Math.sin( halfAngle );\r\n\r\n\t\tthis.x = axis.x * s;\r\n\t\tthis.y = axis.y * s;\r\n\t\tthis.z = axis.z * s;\r\n\t\tthis.w = Math.cos( halfAngle );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromRotationMatrix( m:Matrix4 ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tconst te = m.elements,\r\n\r\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\r\n\r\n\t\t\ttrace = m11 + m22 + m33;\r\n\r\n\t\tif ( trace > 0 ) {\r\n\r\n\t\t\tconst s = 0.5 / Math.sqrt( trace + 1.0 );\r\n\r\n\t\t\tthis.w = 0.25 / s;\r\n\t\t\tthis.x = ( m32 - m23 ) * s;\r\n\t\t\tthis.y = ( m13 - m31 ) * s;\r\n\t\t\tthis.z = ( m21 - m12 ) * s;\r\n\r\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\r\n\r\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\r\n\t\t\tthis.w = ( m32 - m23 ) / s;\r\n\t\t\tthis.x = 0.25 * s;\r\n\t\t\tthis.y = ( m12 + m21 ) / s;\r\n\t\t\tthis.z = ( m13 + m31 ) / s;\r\n\r\n\t\t} else if ( m22 > m33 ) {\r\n\r\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\r\n\t\t\tthis.w = ( m13 - m31 ) / s;\r\n\t\t\tthis.x = ( m12 + m21 ) / s;\r\n\t\t\tthis.y = 0.25 * s;\r\n\t\t\tthis.z = ( m23 + m32 ) / s;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\r\n\t\t\tthis.w = ( m21 - m12 ) / s;\r\n\t\t\tthis.x = ( m13 + m31 ) / s;\r\n\t\t\tthis.y = ( m23 + m32 ) / s;\r\n\t\t\tthis.z = 0.25 * s;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromUnitVectors( vFrom:Vector3, vTo:Vector3) {\r\n\r\n\t\t// assumes direction vectors vFrom and vTo are normalized\r\n\r\n\t\tlet r = vFrom.dot( vTo ) + 1;\r\n\r\n\t\tif ( r < Number.EPSILON ) {\r\n\r\n\t\t\t// vFrom and vTo point in opposite directions\r\n\r\n\t\t\tr = 0;\r\n\r\n\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\r\n\r\n\t\t\t\tthis.x = - vFrom.y;\r\n\t\t\t\tthis.y = vFrom.x;\r\n\t\t\t\tthis.z = 0;\r\n\t\t\t\tthis.w = r;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = - vFrom.z;\r\n\t\t\t\tthis.z = vFrom.y;\r\n\t\t\t\tthis.w = r;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\r\n\r\n\t\t\tthis.x = vFrom.y * vTo.z - vFrom.z * vTo.y;\r\n\t\t\tthis.y = vFrom.z * vTo.x - vFrom.x * vTo.z;\r\n\t\t\tthis.z = vFrom.x * vTo.y - vFrom.y * vTo.x;\r\n\t\t\tthis.w = r;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.normalize();\r\n\r\n\t}\r\n\r\n\tangleTo( q:Quaternion ) {\r\n\r\n\t\treturn 2 * Math.acos( Math.abs( MathUtils.clamp( this.dot( q ), - 1, 1 ) ) );\r\n\r\n\t}\r\n\r\n\trotateTowards( q:Quaternion, step:number ) {\r\n\r\n\t\tconst angle = this.angleTo( q );\r\n\r\n\t\tif ( angle === 0 ) return this;\r\n\r\n\t\tconst t = Math.min( 1, step / angle );\r\n\r\n\t\tthis.slerp( q, t );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tidentity() {\r\n\r\n\t\treturn this.set( 0, 0, 0, 1 );\r\n\r\n\t}\r\n\r\n\tinvert() {\r\n\r\n\t\t// quaternion is assumed to have unit length\r\n\r\n\t\treturn this.conjugate();\r\n\r\n\t}\r\n\r\n\tconjugate() {\r\n\r\n\t\tthis.x *= - 1;\r\n\t\tthis.y *= - 1;\r\n\t\tthis.z *= - 1;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tdot( v:Quaternion ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n\t}\r\n\r\n\tlengthSq() {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\r\n\t}\r\n\r\n\tlength() {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\r\n\t}\r\n\r\n\tnormalize() {\r\n\r\n\t\tlet l = this.length();\r\n\r\n\t\tif ( l === 0 ) {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\t\t\tthis.w = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tl = 1 / l;\r\n\r\n\t\t\tthis.x = this.x * l;\r\n\t\t\tthis.y = this.y * l;\r\n\t\t\tthis.z = this.z * l;\r\n\t\t\tthis.w = this.w * l;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmultiply( q:Quaternion ) {\r\n\r\n\t\treturn this.multiplyQuaternions( this, q );\r\n\r\n\t}\r\n\r\n\tpremultiply( q:Quaternion) {\r\n\r\n\t\treturn this.multiplyQuaternions( q, this );\r\n\r\n\t}\r\n\r\n\tmultiplyQuaternions( a:Quaternion, b:Quaternion ) {\r\n\r\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\r\n\t\tconst qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;\r\n\t\tconst qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;\r\n\r\n\t\tthis.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n\t\tthis.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n\t\tthis.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n\t\tthis.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tslerp( qb:Quaternion, t:number ) {\r\n\r\n\t\tif ( t === 0 ) return this;\r\n\t\tif ( t === 1 ) return this.copy( qb );\r\n\r\n\t\tconst x = this.x, y = this.y, z = this.z, w = this.w;\r\n\r\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\r\n\t\tlet cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;\r\n\r\n\t\tif ( cosHalfTheta < 0 ) {\r\n\r\n\t\t\tthis.w = - qb.w;\r\n\t\t\tthis.x = - qb.x;\r\n\t\t\tthis.y = - qb.y;\r\n\t\t\tthis.z = - qb.z;\r\n\r\n\t\t\tcosHalfTheta = - cosHalfTheta;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.copy( qb );\r\n\r\n\t\t}\r\n\r\n\t\tif ( cosHalfTheta >= 1.0 ) {\r\n\r\n\t\t\tthis.w = w;\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tconst sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\r\n\r\n\t\tif ( sqrSinHalfTheta <= Number.EPSILON ) {\r\n\r\n\t\t\tconst s = 1 - t;\r\n\t\t\tthis.w = s * w + t * this.w;\r\n\t\t\tthis.x = s * x + t * this.x;\r\n\t\t\tthis.y = s * y + t * this.y;\r\n\t\t\tthis.z = s * z + t * this.z;\r\n\r\n\t\t\tthis.normalize();\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tconst sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\r\n\t\tconst halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\r\n\t\tconst ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\r\n\t\tthis.w = ( w * ratioA + this.w * ratioB );\r\n\t\tthis.x = ( x * ratioA + this.x * ratioB );\r\n\t\tthis.y = ( y * ratioA + this.y * ratioB );\r\n\t\tthis.z = ( z * ratioA + this.z * ratioB );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tslerpQuaternions( qa:Quaternion, qb:Quaternion, t:number ) {\r\n\r\n\t\treturn this.copy( qa ).slerp( qb, t );\r\n\r\n\t}\r\n\r\n\trandom() {\r\n\r\n\t\t// Derived from http://planning.cs.uiuc.edu/node198.html\r\n\t\t// Note, this source uses w, x, y, z ordering,\r\n\t\t// so we swap the order below.\r\n\r\n\t\tconst u1 = Math.random();\r\n\t\tconst sqrt1u1 = Math.sqrt( 1 - u1 );\r\n\t\tconst sqrtu1 = Math.sqrt( u1 );\r\n\r\n\t\tconst u2 = 2 * Math.PI * Math.random();\r\n\r\n\t\tconst u3 = 2 * Math.PI * Math.random();\r\n\r\n\t\treturn this.set(\r\n\t\t\tsqrt1u1 * Math.cos( u2 ),\r\n\t\t\tsqrtu1 * Math.sin( u3 ),\r\n\t\t\tsqrtu1 * Math.cos( u3 ),\r\n\t\t\tsqrt1u1 * Math.sin( u2 ),\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tequals( quaternion:Quaternion ) {\r\n\r\n\t\treturn ( quaternion.x === this.x ) && ( quaternion.y === this.y ) && ( quaternion.z === this.z ) && ( quaternion.w === this.w );\r\n\r\n\t}\r\n\r\n\tfromArray( array:Array<number>, offset = 0 ) {\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\t\tthis.z = array[ offset + 2 ];\r\n\t\tthis.w = array[ offset + 3 ];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\ttoArray( array:Array<number> = [], offset = 0 ) {\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\t\tarray[ offset + 2 ] = this.z;\r\n\t\tarray[ offset + 3 ] = this.w;\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n\t// fromBufferAttribute( attribute, index ) {\r\n\r\n\t// \tthis.x = attribute.getX( index );\r\n\t// \tthis.y = attribute.getY( index );\r\n\t// \tthis.z = attribute.getZ( index );\r\n\t// \tthis.w = attribute.getW( index );\r\n\r\n\t// \treturn this;\r\n\r\n\t// }\r\n\r\n\ttoJSON() {\r\n\r\n\t\treturn this.toArray();\r\n\r\n\t}\r\n\r\n\t*[ Symbol.iterator ]() {\r\n\r\n\t\tyield this.x;\r\n\t\tyield this.y;\r\n\t\tyield this.z;\r\n\t\tyield this.w;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { Quaternion };\r\n","/**\r\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\r\n *\r\n * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.\r\n * The azimuthal angle (theta) is measured from the positive z-axis.\r\n */\r\n\r\nimport { MathUtils } from \"./MathUtils\";\r\nimport { Vector3 } from \"./Vector3\";\r\n\r\nexport class Spherical {\r\n    public radius = 1;\r\n    public phi = 0;\r\n    public theta = 0;\r\n    constructor(radius = 1, phi = 0, theta = 0) {\r\n\r\n        this.radius = radius;\r\n\t\tthis.phi = phi; // polar angle\r\n\t\tthis.theta = theta; // azimuthal angle\r\n\r\n        return this;\r\n    }\r\n\r\n    set(radius:number, phi:number, theta:number) {\r\n        this.radius = radius;\r\n        this.phi = phi;\r\n        this.theta = theta;\r\n\r\n        return this;\r\n    }\r\n\r\n    copy(other:Spherical) {\r\n        this.radius = other.radius;\r\n        this.phi = other.phi;\r\n        this.theta = other.theta;\r\n\r\n        return this;\r\n    }\r\n\r\n    // restrict phi to be between EPS and PI-EPS\r\n    makeSafe() {\r\n        const EPS = 0.000001;\r\n        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));\r\n\r\n        return this;\r\n    }\r\n\r\n    setFromVector3(v:Vector3) {\r\n        return this.setFromCartesianCoords(v.x, v.y, v.z);\r\n    }\r\n\r\n    setFromCartesianCoords(x:number, y:number, z:number) {\r\n        this.radius = Math.sqrt(x * x + y * y + z * z);\r\n\r\n        if (this.radius === 0) {\r\n            this.theta = 0;\r\n            this.phi = 0;\r\n        } else {\r\n            this.theta = Math.atan2(x, z);\r\n            this.phi = Math.acos(MathUtils.clamp(y / this.radius, -1, 1));\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    clone() {\r\n        return new Spherical().copy(this);\r\n    }\r\n}\r\n","import * as MathUtils from './MathUtils';\r\nimport { Matrix3 } from './Matrix3';\r\n\r\nclass Vector2 {\r\n\r\n    public x = 0;\r\n    public y = 0;\r\n\r\n\tconstructor( x = 0, y = 0 ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\r\n\t}\r\n\r\n\tget width() {\r\n\r\n\t\treturn this.x;\r\n\r\n\t}\r\n\r\n\tset width( value ) {\r\n\r\n\t\tthis.x = value;\r\n\r\n\t}\r\n\r\n\tget height() {\r\n\r\n\t\treturn this.y;\r\n\r\n\t}\r\n\r\n\tset height( value ) {\r\n\r\n\t\tthis.y = value;\r\n\r\n\t}\r\n\r\n\tset( x:number, y:number ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetScalar( scalar:number ) {\r\n\r\n\t\tthis.x = scalar;\r\n\t\tthis.y = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetX( x:number ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetY( y:number ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetComponent( index:number, value:number ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tgetComponent( index:number ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new Vector2( this.x, this.y );\r\n\r\n\t}\r\n\r\n\tcopy( v:Vector2 ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tadd( v:Vector2 ) {\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\taddScalar( s:number ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\taddVectors( a:Vector2, b:Vector2 ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\taddScaledVector( v:Vector2, s:number ) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsub( v:Vector2 ) {\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsubScalar( s:number ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsubVectors( a:Vector2, b:Vector2 ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmultiply( v:Vector2) {\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmultiplyScalar( scalar:number ) {\r\n\r\n\t\tthis.x *= scalar;\r\n\t\tthis.y *= scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tdivide( v:Vector2 ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tdivideScalar( scalar:number ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t}\r\n\r\n\tapplyMatrix3( m:Matrix3 ) {\r\n\r\n\t\tconst x = this.x, y = this.y;\r\n\t\tconst e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\r\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmin( v:Vector2 ) {\r\n\r\n\t\tthis.x = Math.min( this.x, v.x );\r\n\t\tthis.y = Math.min( this.y, v.y );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmax( v:Vector2 ) {\r\n\r\n\t\tthis.x = Math.max( this.x, v.x );\r\n\t\tthis.y = Math.max( this.y, v.y );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tclamp( min:Vector2, max:Vector2 ) {\r\n\r\n\t\t// assumes min < max, componentwise\r\n\r\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tclampScalar( minVal:number, maxVal:number ) {\r\n\r\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\r\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tclampLength( min:number, max:number ) {\r\n\r\n\t\tconst length = this.length();\r\n\r\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\r\n\r\n\t}\r\n\r\n\tfloor() {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tceil() {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tround() {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\troundToZero() {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tnegate() {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tdot( v:Vector2 ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y;\r\n\r\n\t}\r\n\r\n\tcross( v:Vector2 ) {\r\n\r\n\t\treturn this.x * v.y - this.y * v.x;\r\n\r\n\t}\r\n\r\n\tlengthSq() {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y;\r\n\r\n\t}\r\n\r\n\tlength() {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\r\n\r\n\t}\r\n\r\n\tmanhattanLength() {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\r\n\r\n\t}\r\n\r\n\tnormalize() {\r\n\r\n\t\treturn this.divideScalar( this.length() || 1 );\r\n\r\n\t}\r\n\r\n\tangle() {\r\n\r\n\t\t// computes the angle in radians with respect to the positive x-axis\r\n\r\n\t\tconst angle = Math.atan2( - this.y, - this.x ) + Math.PI;\r\n\r\n\t\treturn angle;\r\n\r\n\t}\r\n\r\n\tangleTo( v:Vector2 ) {\r\n\r\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\r\n\r\n\t\tif ( denominator === 0 ) return Math.PI / 2;\r\n\r\n\t\tconst theta = this.dot( v ) / denominator;\r\n\r\n\t\t// clamp, to handle numerical problems\r\n\r\n\t\treturn Math.acos( MathUtils.clamp( theta, - 1, 1 ) );\r\n\r\n\t}\r\n\r\n\tdistanceTo( v:Vector2 ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t}\r\n\r\n\tdistanceToSquared( v:Vector2 ) {\r\n\r\n\t\tconst dx = this.x - v.x, dy = this.y - v.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\r\n\t}\r\n\r\n\tmanhattanDistanceTo( v:Vector2 ) {\r\n\r\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\r\n\r\n\t}\r\n\r\n\tsetLength( length:number ) {\r\n\r\n\t\treturn this.normalize().multiplyScalar( length );\r\n\r\n\t}\r\n\r\n\tlerp( v:Vector2, alpha:number ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tlerpVectors( v1:Vector2, v2:Vector2, alpha:number ) {\r\n\r\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\r\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tequals( v:Vector2 ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\r\n\t}\r\n\r\n\tfromArray( array:Array<number>, offset = 0 ) {\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\ttoArray( array:Array<number> = [], offset = 0 ) {\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n\t// fromBufferAttribute( attribute, index ) {\r\n\r\n\t// \tthis.x = attribute.getX( index );\r\n\t// \tthis.y = attribute.getY( index );\r\n\r\n\t// \treturn this;\r\n\r\n\t// }\r\n\r\n\trotateAround( center:Vector2, angle:number ) {\r\n\r\n\t\tconst c = Math.cos( angle ), s = Math.sin( angle );\r\n\r\n\t\tconst x = this.x - center.x;\r\n\t\tconst y = this.y - center.y;\r\n\r\n\t\tthis.x = x * c - y * s + center.x;\r\n\t\tthis.y = x * s + y * c + center.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\trandom() {\r\n\r\n\t\tthis.x = Math.random();\r\n\t\tthis.y = Math.random();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t*[ Symbol.iterator ]() {\r\n\r\n\t\tyield this.x;\r\n\t\tyield this.y;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { Vector2 };\r\n","import { Color } from './Color';\r\nimport { Euler } from './Euler';\r\nimport * as MathUtils from './MathUtils';\r\nimport { Matrix3 } from './Matrix3';\r\nimport { Matrix4 } from './Matrix4';\r\nimport { Quaternion } from './Quaternion';\r\nimport { Spherical } from './Spherical';\r\n\r\nclass Vector3 {\r\n\r\n    public x  = 0;\r\n    public y  = 0;\r\n    public z  = 0;\r\n\r\n\tconstructor( x = 0, y = 0, z = 0 ) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\r\n\t}\r\n\r\n\tset( x:number, y:number, z:number ) {\r\n\r\n\t\tif ( z === undefined ) z = this.z; // sprite.scale.set(x,y)\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetScalar( scalar:number ) {\r\n\r\n\t\tthis.x = scalar;\r\n\t\tthis.y = scalar;\r\n\t\tthis.z = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetX( x:number ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetY( y:number ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetZ( z:number ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetComponent( index:number, value:number ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tgetComponent( index:number ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new Vector3( this.x, this.y, this.z );\r\n\r\n\t}\r\n\r\n\tcopy( v:Vector3 ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tadd( v:Vector3 ) {\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\taddScalar( s:number ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\taddVectors( a:Vector3, b:Vector3 ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\taddScaledVector( v:Vector3, s:number ) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\t\tthis.z += v.z * s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsub( v:Vector3 ) {\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsubScalar( s:number ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\t\tthis.z -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsubVectors( a:Vector3, b:Vector3 ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmultiply( v:Vector3 ) {\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\t\tthis.z *= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmultiplyScalar( scalar:number ) {\r\n\r\n\t\tthis.x *= scalar;\r\n\t\tthis.y *= scalar;\r\n\t\tthis.z *= scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmultiplyVectors( a:Vector3, b:Vector3 ) {\r\n\r\n\t\tthis.x = a.x * b.x;\r\n\t\tthis.y = a.y * b.y;\r\n\t\tthis.z = a.z * b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tapplyEuler( euler:Euler ) {\r\n\r\n\t\treturn this.applyQuaternion( _quaternion.setFromEuler( euler ) );\r\n\r\n\t}\r\n\r\n\tapplyAxisAngle( axis:Vector3, angle:number ) {\r\n\r\n\t\treturn this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );\r\n\r\n\t}\r\n\r\n\tapplyMatrix3( m:Matrix3 ) {\r\n\r\n\t\tconst x = this.x, y = this.y, z = this.z;\r\n\t\tconst e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\r\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\r\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tapplyNormalMatrix( m:Matrix3 ) {\r\n\r\n\t\treturn this.applyMatrix3( m ).normalize();\r\n\r\n\t}\r\n\r\n\tapplyMatrix4( m:Matrix4 ) {\r\n\r\n\t\tconst x = this.x, y = this.y, z = this.z;\r\n\t\tconst e = m.elements;\r\n\r\n\t\tconst w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\r\n\r\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\r\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\r\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tapplyQuaternion( q:Quaternion ) {\r\n\r\n\t\tconst x = this.x, y = this.y, z = this.z;\r\n\t\tconst qx = q.x, qy = q.y, qz = q.z, qw = q.w;\r\n\r\n\t\t// calculate quat * vector\r\n\r\n\t\tconst ix = qw * x + qy * z - qz * y;\r\n\t\tconst iy = qw * y + qz * x - qx * z;\r\n\t\tconst iz = qw * z + qx * y - qy * x;\r\n\t\tconst iw = - qx * x - qy * y - qz * z;\r\n\r\n\t\t// calculate result * inverse quat\r\n\r\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\r\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\r\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t// project( camera ) {\r\n\r\n\t// \treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\r\n\r\n\t// }\r\n\r\n\t// unproject( camera ) {\r\n\r\n\t// \treturn this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );\r\n\r\n\t// }\r\n\r\n\ttransformDirection( m:Matrix4 ) {\r\n\r\n\t\t// input: THREE.Matrix4 affine matrix\r\n\t\t// vector interpreted as a direction\r\n\r\n\t\tconst x = this.x, y = this.y, z = this.z;\r\n\t\tconst e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\r\n\t\treturn this.normalize();\r\n\r\n\t}\r\n\r\n\tdivide( v:Vector3 ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\t\tthis.z /= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tdivideScalar( scalar:number ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t}\r\n\r\n\tmin( v:Vector3 ) {\r\n\r\n\t\tthis.x = Math.min( this.x, v.x );\r\n\t\tthis.y = Math.min( this.y, v.y );\r\n\t\tthis.z = Math.min( this.z, v.z );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmax( v:Vector3 ) {\r\n\r\n\t\tthis.x = Math.max( this.x, v.x );\r\n\t\tthis.y = Math.max( this.y, v.y );\r\n\t\tthis.z = Math.max( this.z, v.z );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tclamp( min:Vector3, max:Vector3 ) {\r\n\r\n\t\t// assumes min < max, componentwise\r\n\r\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tclampScalar( minVal:number, maxVal:number ) {\r\n\r\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\r\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\r\n\t\tthis.z = Math.max( minVal, Math.min( maxVal, this.z ) );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tclampLength( min:number, max:number ) {\r\n\r\n\t\tconst length = this.length();\r\n\r\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\r\n\r\n\t}\r\n\r\n\tfloor() {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\t\tthis.z = Math.floor( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tceil() {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\t\tthis.z = Math.ceil( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tround() {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\t\tthis.z = Math.round( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\troundToZero() {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tnegate() {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\t\tthis.z = - this.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tdot( v:Vector3 ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\r\n\t}\r\n\r\n\t// TODO lengthSquared?\r\n\r\n\tlengthSq() {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\r\n\t}\r\n\r\n\tlength() {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\r\n\t}\r\n\r\n\tmanhattanLength() {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\r\n\t}\r\n\r\n\tnormalize() {\r\n\r\n\t\treturn this.divideScalar( this.length() || 1 );\r\n\r\n\t}\r\n\r\n\tsetLength( length:number ) {\r\n\r\n\t\treturn this.normalize().multiplyScalar( length );\r\n\r\n\t}\r\n\r\n\tlerp( v:Vector3, alpha:number ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tlerpVectors( v1:Vector3, v2:Vector3, alpha:number ) {\r\n\r\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\r\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\r\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tcross( v:Vector3 ) {\r\n\r\n\t\treturn this.crossVectors( this, v );\r\n\r\n\t}\r\n\r\n\tcrossVectors( a:Vector3, b:Vector3 ) {\r\n\r\n\t\tconst ax = a.x, ay = a.y, az = a.z;\r\n\t\tconst bx = b.x, by = b.y, bz = b.z;\r\n\r\n\t\tthis.x = ay * bz - az * by;\r\n\t\tthis.y = az * bx - ax * bz;\r\n\t\tthis.z = ax * by - ay * bx;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tprojectOnVector( v:Vector3) {\r\n\r\n\t\tconst denominator = v.lengthSq();\r\n\r\n\t\tif ( denominator === 0 ) return this.set( 0, 0, 0 );\r\n\r\n\t\tconst scalar = v.dot( this ) / denominator;\r\n\r\n\t\treturn this.copy( v ).multiplyScalar( scalar );\r\n\r\n\t}\r\n\r\n\tprojectOnPlane( planeNormal:Vector3 ) {\r\n\r\n\t\t_vector.copy( this ).projectOnVector( planeNormal );\r\n\r\n\t\treturn this.sub( _vector );\r\n\r\n\t}\r\n\r\n\treflect( normal:Vector3 ) {\r\n\r\n\t\t// reflect incident vector off plane orthogonal to normal\r\n\t\t// normal is assumed to have unit length\r\n\r\n\t\treturn this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\r\n\r\n\t}\r\n\r\n\tangleTo( v:Vector3 ) {\r\n\r\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\r\n\r\n\t\tif ( denominator === 0 ) return Math.PI / 2;\r\n\r\n\t\tconst theta = this.dot( v ) / denominator;\r\n\r\n\t\t// clamp, to handle numerical problems\r\n\r\n\t\treturn Math.acos( MathUtils.clamp( theta, - 1, 1 ) );\r\n\r\n\t}\r\n\r\n\tdistanceTo( v:Vector3 ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t}\r\n\r\n\tdistanceToSquared( v:Vector3 ) {\r\n\r\n\t\tconst dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\r\n\r\n\t\treturn dx * dx + dy * dy + dz * dz;\r\n\r\n\t}\r\n\r\n\tmanhattanDistanceTo( v:Vector3 ) {\r\n\r\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\r\n\r\n\t}\r\n\r\n\tsetFromSpherical( s:Spherical ) {\r\n\r\n\t\treturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );\r\n\r\n\t}\r\n\r\n\tsetFromSphericalCoords( radius:number, phi:number, theta:number ) {\r\n\r\n\t\tconst sinPhiRadius = Math.sin( phi ) * radius;\r\n\r\n\t\tthis.x = sinPhiRadius * Math.sin( theta );\r\n\t\tthis.y = Math.cos( phi ) * radius;\r\n\t\tthis.z = sinPhiRadius * Math.cos( theta );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t// setFromCylindrical( c ) {\r\n\r\n\t// \treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\r\n\r\n\t// }\r\n\r\n\tsetFromCylindricalCoords( radius:number, theta:number, y:number ) {\r\n\r\n\t\tthis.x = radius * Math.sin( theta );\r\n\t\tthis.y = y;\r\n\t\tthis.z = radius * Math.cos( theta );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromMatrixPosition( m:Matrix4 ) {\r\n\r\n\t\tconst e = m.elements;\r\n\r\n\t\tthis.x = e[ 12 ];\r\n\t\tthis.y = e[ 13 ];\r\n\t\tthis.z = e[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromMatrixScale( m:Matrix4 ) {\r\n\r\n\t\tconst sx = this.setFromMatrixColumn( m, 0 ).length();\r\n\t\tconst sy = this.setFromMatrixColumn( m, 1 ).length();\r\n\t\tconst sz = this.setFromMatrixColumn( m, 2 ).length();\r\n\r\n\t\tthis.x = sx;\r\n\t\tthis.y = sy;\r\n\t\tthis.z = sz;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromMatrixColumn( m:Matrix4, index:number ) {\r\n\r\n\t\treturn this.fromArray( m.elements, index * 4 );\r\n\r\n\t}\r\n\r\n\tsetFromMatrix3Column( m:Matrix3, index:number ) {\r\n\r\n\t\treturn this.fromArray( m.elements, index * 3 );\r\n\r\n\t}\r\n\r\n\tsetFromEuler( e:Euler ) {\r\n\r\n\t\tthis.x = e.x;\r\n\t\tthis.y = e.y;\r\n\t\tthis.z = e.z;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromColor( c:Color ) {\r\n\r\n\t\tthis.x = c.r;\r\n\t\tthis.y = c.g;\r\n\t\tthis.z = c.b;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tequals( v:Vector3 ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\r\n\t}\r\n\r\n\tfromArray( array:Array<number>, offset = 0 ) {\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\t\tthis.z = array[ offset + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\ttoArray( array:Array<number> = [], offset = 0 ) {\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\t\tarray[ offset + 2 ] = this.z;\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n\t// fromBufferAttribute( attribute, index ) {\r\n\r\n\t// \tthis.x = attribute.getX( index );\r\n\t// \tthis.y = attribute.getY( index );\r\n\t// \tthis.z = attribute.getZ( index );\r\n\r\n\t// \treturn this;\r\n\r\n\t// }\r\n\r\n\trandom() {\r\n\r\n\t\tthis.x = Math.random();\r\n\t\tthis.y = Math.random();\r\n\t\tthis.z = Math.random();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\trandomDirection() {\r\n\r\n\t\t// Derived from https://mathworld.wolfram.com/SpherePointPicking.html\r\n\r\n\t\tconst u = ( Math.random() - 0.5 ) * 2;\r\n\t\tconst t = Math.random() * Math.PI * 2;\r\n\t\tconst f = Math.sqrt( 1 - u ** 2 );\r\n\r\n\t\tthis.x = f * Math.cos( t );\r\n\t\tthis.y = f * Math.sin( t );\r\n\t\tthis.z = u;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t*[ Symbol.iterator ]() {\r\n\r\n\t\tyield this.x;\r\n\t\tyield this.y;\r\n\t\tyield this.z;\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst _vector = /*@__PURE__*/ new Vector3();\r\nconst _quaternion = /*@__PURE__*/ new Quaternion();\r\n\r\nexport { Vector3 };\r\n","import { BufferGeometry } from \"../core/BufferGeometry\";\r\nimport { Material } from \"../materials/Material\";\r\nimport { RenderableObject } from \"../core/RenderableObject\";\r\nimport { Object3D } from \"../core/Object3D\";\r\n\r\nexport class Mesh extends RenderableObject{\r\n\r\n    public get type(){\r\n        return \"Mesh\";\r\n    }\r\n\r\n\tpublic static Is(object:Object3D){\r\n\t\treturn object instanceof Mesh;\r\n\t}\r\n    \r\n    constructor(geometry : BufferGeometry,material:Material){\r\n        super(geometry,material);\r\n    }\r\n\r\n}","import { Camera } from \"../cameras/Camera\";\r\nimport { PerspectiveCamera } from \"../cameras/PerspectiveCamera\";\r\nimport { GPUIndexFormat, GPUTextureFormat } from \"../Constants\";\r\nimport { RenderableObject } from \"../core/RenderableObject\";\r\nimport { Context } from \"../core/ResourceManagers\";\r\nimport { Scene } from \"../core/Scene\";\r\nimport { Light } from \"../lights/Light\";\r\nimport { Material } from \"../materials/Material\";\r\nimport { Color } from \"../math/Color\";\r\n\r\ninterface WebGPURendererParameters {\r\n    canvas?: HTMLCanvasElement;\r\n    powerPreference?: GPUPowerPreference;\r\n    sampleCount?: number;\r\n    antialias?: boolean;\r\n}\r\n\r\ninterface RendererSize {\r\n    width: number;\r\n    height: number;\r\n}\r\n\r\n\r\n\r\nexport class WebGPURenderer {\r\n    private _parameters: WebGPURendererParameters;\r\n    private _canvas: HTMLCanvasElement;\r\n    private _powerPreference: GPUPowerPreference;\r\n    private _adapter: GPUAdapter;\r\n    private _device: GPUDevice;\r\n    private _presentationFormat: GPUTextureFormat = GPUTextureFormat.BGRA8Unorm;\r\n    private _context: GPUCanvasContext;\r\n    private _alphaMode: GPUCanvasAlphaMode = \"premultiplied\";\r\n    private _colorBuffer: GPUTexture;\r\n    private _depthBuffer: GPUTexture;\r\n    private _size: RendererSize;\r\n    private _pixelRatio = window.devicePixelRatio || 1;\r\n    private _colorAttachmentView: GPUTextureView;\r\n    private _sampleCount = 1;\r\n    private _clearColor = new Color(1, 1, 1);\r\n    private _sizeChanged = false;\r\n\r\n    private _renderPassDescriptor : GPURenderPassDescriptor;\r\n\r\n    private _materialObjects = new Map<Material,Array<RenderableObject>>();\r\n\r\n    constructor(parameters: WebGPURendererParameters = {}) {\r\n        this._parameters = parameters;\r\n\r\n        if (this._parameters.antialias === true) {\r\n            this._sampleCount = parameters.sampleCount === undefined ? 4 : parameters.sampleCount;\r\n        } else {\r\n            this._sampleCount = 1;\r\n        }\r\n    }\r\n\r\n    public async init() {\r\n        if (!this._parameters.canvas) {\r\n            this._canvas = document.createElement(\"canvas\");\r\n            this._canvas.style.width = \"100%\";\r\n            this._canvas.style.height = \"100%\";\r\n        } else {\r\n            this._canvas = this._parameters.canvas;\r\n        }\r\n\r\n        this._powerPreference = this._parameters.powerPreference\r\n            ? this._parameters.powerPreference\r\n            : \"high-performance\";\r\n        this._adapter = await navigator.gpu.requestAdapter({\r\n            powerPreference: this._powerPreference,\r\n        });\r\n\r\n        this._device = await this._adapter.requestDevice();\r\n\r\n        this._context = this._canvas.getContext(\"webgpu\");\r\n        this._context.configure({\r\n            device: this._device,\r\n            format: this._presentationFormat,\r\n            alphaMode: this._alphaMode,\r\n        });\r\n\r\n        this._initGlobalData();\r\n\r\n        this._renderPassDescriptor = {\r\n            colorAttachments: [\r\n                {\r\n                    view: null,\r\n                    resolveTarget: undefined,\r\n                    clearValue: { r: this._clearColor.r, g: this._clearColor.g, b: this._clearColor.b, a: 1.0 },\r\n                    loadOp: \"clear\",\r\n                    storeOp: \"store\",\r\n                },\r\n            ],\r\n            depthStencilAttachment: {\r\n                view: null,\r\n                depthClearValue: 1.0,\r\n                depthLoadOp: 'clear',\r\n                depthStoreOp: 'store',\r\n              },\r\n        };\r\n    }\r\n\r\n    _initGlobalData() {\r\n        Context.activeDevice = this._device;\r\n    }\r\n\r\n    public setSize(width: number, height: number) {\r\n        this._size = {\r\n            width: width,\r\n            height: height,\r\n        };\r\n        this._canvas.width = width * this._pixelRatio;\r\n        this._canvas.height = height * this._pixelRatio;\r\n        this._setupColorBuffer();\r\n        this._setupDepthBuffer();\r\n        this._sizeChanged = true;\r\n    }\r\n\r\n    public render(scene: Scene, camera: Camera) {\r\n        if (!this._colorAttachmentView) {\r\n            this.setSize(this._canvas.clientWidth, this._canvas.clientHeight);\r\n        }\r\n\r\n        if (this._sizeChanged) {\r\n            if(PerspectiveCamera.Is(camera)){\r\n                const perspectiveCamera = camera as PerspectiveCamera;\r\n                perspectiveCamera.aspect = this._canvas.width / this._canvas.height;\r\n                perspectiveCamera.updateProjectionMatrix();\r\n            }\r\n\r\n            this._sizeChanged = false;\r\n        }\r\n        camera.update();\r\n        this._materialObjects.clear();\r\n\r\n        const commandEncoder = this.device.createCommandEncoder();\r\n\r\n        const view = this.sampleCount > 1 ? this._colorAttachmentView : this._context.getCurrentTexture().createView();\r\n        const resolveTarget = this.sampleCount > 1 ? this._context.getCurrentTexture().createView() : undefined;\r\n        (this._renderPassDescriptor.colorAttachments as Array<GPURenderPassColorAttachment>)[0].view = view;\r\n        (this._renderPassDescriptor.colorAttachments as Array<GPURenderPassColorAttachment>)[0].resolveTarget = resolveTarget;\r\n        (this._renderPassDescriptor.depthStencilAttachment as GPURenderPassDepthStencilAttachment).view = this._depthBuffer.createView();\r\n\r\n        const lights = new Array<Light>();\r\n\r\n        for (let i = 0; i < scene.children.length; ++i) {\r\n            const child = scene.children[i];\r\n            if(RenderableObject.Is(child)){\r\n                const renderableObj = child as RenderableObject;\r\n                const objs = this._materialObjects.get(renderableObj.material);\r\n                if(objs){\r\n                    objs.push(renderableObj);\r\n                }else{\r\n                    this._materialObjects.set(renderableObj.material,[]);\r\n                    this._materialObjects.get(renderableObj.material).push(renderableObj);\r\n                }\r\n            }else if(Light.Is(child)){\r\n                lights.push(child as Light);\r\n            }\r\n            \r\n        }\r\n\r\n        const passEncoder = commandEncoder.beginRenderPass(this._renderPassDescriptor);\r\n\r\n        for(const [material,objects] of this._materialObjects){\r\n            this._renderSamePipeline(passEncoder, material,objects,camera,lights);\r\n        }\r\n\r\n        passEncoder.end();\r\n\r\n        this.device.queue.submit([commandEncoder.finish()]);\r\n    }\r\n\r\n    private _renderSamePipeline(passEncoder: GPURenderPassEncoder, material:Material,objects:Array<RenderableObject>,camera: Camera,lights:Array<Light>){\r\n        if(material.applyLight){\r\n            \r\n        }\r\n        \r\n        material.pipeline.compilePipeline(this);\r\n        passEncoder.setPipeline(material.pipeline.pipeline);\r\n        material.pipeline.createBindGroups(camera);\r\n        material.pipeline.bindCommonUniform(passEncoder,camera);\r\n        material.updateUniforms();\r\n        for(let i = 0;i < objects.length;++i){\r\n            material.pipeline.createObjectBindGroup(objects[i]);\r\n            material.pipeline.bindObjectUnform(passEncoder,objects[i]);\r\n            this._renderObject(passEncoder,objects[i]);\r\n        }\r\n    }\r\n\r\n    private _renderObject(passEncoder: GPURenderPassEncoder, object: RenderableObject ) {\r\n        object.update();\r\n\r\n        const geometry = object.geometry;\r\n        geometry.update();\r\n        geometry.setVertexBuffer(passEncoder,object.material.shaderOptions.attributeValues);\r\n        if (geometry.indices) {\r\n            passEncoder.setIndexBuffer(geometry.indices.buffer.buffer, GPUIndexFormat.Uint32);\r\n            passEncoder.drawIndexedIndirect(object.geometry.drawBuffer.buffer, 0);\r\n        } else {\r\n            passEncoder.drawIndirect(object.geometry.drawBuffer.buffer, 0);\r\n        }\r\n    }\r\n\r\n    private _setupColorBuffer() {\r\n        const device = this._device;\r\n\r\n        if (device) {\r\n            if (this._colorBuffer) this._colorBuffer.destroy();\r\n\r\n            this._colorBuffer = this._device.createTexture({\r\n                size: {\r\n                    width: Math.floor(this._size.width * this._pixelRatio),\r\n                    height: Math.floor(this._size.height * this._pixelRatio),\r\n                    depthOrArrayLayers: 1,\r\n                },\r\n                sampleCount: this._sampleCount,\r\n                format: this._presentationFormat,\r\n                usage: GPUTextureUsage.RENDER_ATTACHMENT,\r\n            });\r\n            this._colorAttachmentView = this._colorBuffer.createView();\r\n        }\r\n    }\r\n\r\n    private _setupDepthBuffer() {\r\n\r\n\t\tif ( this._depthBuffer ) this._depthBuffer.destroy();\r\n\r\n\t\tthis._depthBuffer = this.device.createTexture( {\r\n\t\t\tlabel: 'depthBuffer',\r\n\t\t\tsize: {\r\n                width: Math.floor(this._size.width * this._pixelRatio),\r\n                height: Math.floor(this._size.height * this._pixelRatio),\r\n                depthOrArrayLayers: 1,\r\n            },\r\n\t\t\tsampleCount: this._sampleCount,\r\n\t\t\tformat: GPUTextureFormat.Depth24Plus,\r\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\r\n\t\t} );\r\n\r\n\t}\r\n\r\n    get domElement() {\r\n        return this._canvas;\r\n    }\r\n\r\n    get device() {\r\n        return this._device;\r\n    }\r\n\r\n    get presentationFormat() {\r\n        return this._presentationFormat;\r\n    }\r\n\r\n    get sampleCount() {\r\n        return this._sampleCount;\r\n    }\r\n}\r\n","import { Material } from \"../materials/Material\";\r\nimport { Shader } from \"./Shader\";\r\nimport * as basic from \"./ShaderBasic\"\r\n\r\nexport class MeshBasicShader extends Shader {\r\n\r\n    constructor(material: Material) {\r\n        super(material);\r\n    }\r\n\r\n    protected override _createVertexShader() {\r\n        const shaderOptions = this._material.shaderOptions;\r\n        const indexObj = {index:1} as basic.IndexObj;\r\n\r\n        const uvItem = shaderOptions.attributeValues.get(\"uv\");\r\n\r\n        this._vertexShaderCode = `\r\n            ${basic.location_transform_vert()}\r\n\r\n            struct VertexOutput {\r\n                @builtin(position) Position : vec4<f32>,\r\n                ${basic.itemVary_value(uvItem,indexObj)}\r\n            }\r\n\r\n            @vertex\r\n            fn main(\r\n            @location(0) position : vec3<f32>,\r\n            ${basic.location_vert(uvItem)}\r\n            ) -> VertexOutput {\r\n                var output : VertexOutput;\r\n                ${basic.transform_vert()}\r\n                ${basic.uv_vert(uvItem)}\r\n                return output;\r\n            }\r\n        \r\n        `\r\n    }\r\n\r\n    protected override  _createFragmentShader(){\r\n        const shaderOptions = this._material.shaderOptions;\r\n        const indexObj = {index:1} as basic.IndexObj;\r\n        const uvItem = shaderOptions.attributeValues.get(\"uv\");\r\n\r\n        this._fragmentShaderCode = `\r\n            ${basic.bind_value_frag(shaderOptions.bindValues.get(\"parameters\"))}\r\n            ${basic.bind_value_frag(shaderOptions.bindValues.get(\"color\"))}\r\n            ${basic.bind_value_frag(shaderOptions.bindValues.get(\"colorSampler\"))}\r\n            ${basic.bind_value_frag(shaderOptions.bindValues.get(\"texture\"))}\r\n            \r\n\r\n\r\n            @fragment\r\n            fn main(\r\n                ${basic.itemVary_value(uvItem,indexObj)}\r\n            ) -> @location(0) vec4<f32> {\r\n                var baseColor:vec4<f32>;\r\n                ${basic.getColo_frag(shaderOptions.bindValues.get(\"texture\"),shaderOptions.bindValues.get(\"color\"))}\r\n                return baseColor;\r\n            }\r\n\r\n        `;\r\n    }\r\n}\r\n","import { Material } from \"../materials/Material\";\r\nimport { Shader } from \"./Shader\";\r\nimport * as basic from \"./ShaderBasic\"\r\n\r\nexport class MeshPhongShader extends Shader {\r\n\r\n    constructor(material: Material){\r\n        super(material);\r\n    }\r\n\r\n    protected _createVertexShader(): void {\r\n        const shaderOptions = this._material.shaderOptions;\r\n        const indexObj = {index:1} as basic.IndexObj;\r\n        const uvItem = shaderOptions.attributeValues.get(\"uv\");\r\n        const normalItem = shaderOptions.attributeValues.get(\"normal\");\r\n \r\n        this._vertexShaderCode = `\r\n            ${basic.location_transform_vert()}\r\n\r\n            struct VertexOutput {\r\n                @builtin(position) Position : vec4<f32>,\r\n                ${basic.itemVary_value(uvItem,indexObj)}\r\n                ${basic.itemVary_value(normalItem,indexObj)}\r\n                ${basic.customVary_value(\"vViewPosition\",\"vec3<f32>\",indexObj)}\r\n            }\r\n\r\n            @vertex\r\n            fn main(\r\n            @location(0) position : vec3<f32>,\r\n            ${basic.location_vert(normalItem)}\r\n            ${basic.location_vert(uvItem)}\r\n            ) -> VertexOutput {\r\n                var output : VertexOutput;\r\n                ${basic.transform_vert()}\r\n                ${basic.uv_vert(uvItem)}\r\n                output.vViewPosition = - mvPosition.xyz;\r\n                output.normal = normal;\r\n                return output;\r\n            }\r\n        \r\n        `\r\n    }\r\n\r\n\r\n    protected _createFragmentShader(): void {\r\n        const shaderOptions = this._material.shaderOptions;\r\n        const indexObj = {index:1} as basic.IndexObj;\r\n        const uvItem = shaderOptions.attributeValues.get(\"uv\");\r\n        const normalItem = shaderOptions.attributeValues.get(\"normal\");\r\n\r\n        this._fragmentShaderCode = `\r\n            ${basic.bind_value_frag(shaderOptions.bindValues.get(\"parameters\"))}\r\n            ${basic.bind_value_frag(shaderOptions.bindValues.get(\"color\"))}\r\n            ${basic.bind_value_frag(shaderOptions.bindValues.get(\"colorSampler\"))}\r\n            ${basic.bind_value_frag(shaderOptions.bindValues.get(\"texture\"))}\r\n            ${basic.bind_value_frag(shaderOptions.bindValues.get(\"specular\"))}\r\n            ${basic.bind_value_frag(shaderOptions.bindValues.get(\"emissive\"))}\r\n            ${basic.bind_value_frag(shaderOptions.bindValues.get(\"shininess\"))}\r\n    \r\n\r\n\r\n            const RECIPROCAL_PI = 0.3183098861837907;\r\n            struct IncidentLight {\r\n                color:vec3<f32>,\r\n                direction:vec3<f32>,\r\n                visible:bool,\r\n            };\r\n\r\n            struct ReflectedLight {\r\n                directDiffuse:vec3<f32>,\r\n                directSpecular:vec3<f32>,\r\n                indirectDiffuse:vec3<f32>,\r\n                indirectSpecular:vec3<f32>,\r\n            };\r\n\r\n            struct GeometricContext {\r\n                position:vec3<f32>,\r\n                normal:vec3<f32>,\r\n                viewDir:vec3<f32>,\r\n            };\r\n\r\n            struct BlinnPhongMaterial {\r\n\r\n                diffuseColor:vec3<f32>,\r\n                specularColor:vec3<f32>,\r\n                specularShininess:f32,\r\n                specularStrength:f32,\r\n            \r\n            };\r\n\r\n            struct DirectionalLight {\r\n                direction:vec3<f32>,\r\n                color:vec3<f32>,\r\n            };\r\n\r\n            fn saturate( a:f32 )->f32 {\r\n                return clamp( a, 0.0, 1.0 );\r\n            } \r\n\r\n            fn BRDF_Lambert( diffuseColor:vec3<f32> )->vec3<f32> {\r\n\r\n                return RECIPROCAL_PI * diffuseColor;\r\n            \r\n            }\r\n\r\n            fn F_Schlick( f0:vec3<f32>, f90:f32, dotVH:f32 )->vec3<f32> {\r\n\r\n                var fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\r\n            \r\n                return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\r\n            \r\n            } \r\n\r\n            fn G_BlinnPhong_Implicit()->f32 {\r\n\r\n                return 0.25;\r\n            \r\n            }\r\n\r\n            fn D_BlinnPhong( shininess:f32, dotNH:f32)->f32 {\r\n\r\n                return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\r\n            \r\n            }\r\n\r\n            fn BRDF_BlinnPhong( lightDir:vec3<f32>, viewDir:vec3<f32>, normal:vec3<f32>, specularColor:vec3<f32>, shininess:f32 )->vec3<f32> {\r\n\r\n                var halfDir = normalize( lightDir + viewDir );\r\n            \r\n                var dotNH = saturate( dot( normal, halfDir ) );\r\n                var dotVH = saturate( dot( viewDir, halfDir ) );\r\n            \r\n                var F = F_Schlick( specularColor, 1.0, dotVH );\r\n            \r\n                var G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\r\n            \r\n                var D = D_BlinnPhong( shininess, dotNH );\r\n            \r\n                return F * ( G * D );\r\n            \r\n            }\r\n\r\n            fn RE_Direct_BlinnPhong( \r\n                directLight:IncidentLight, \r\n                geometry:GeometricContext, \r\n                material:BlinnPhongMaterial, \r\n                reflectedLight: ptr<function,ReflectedLight>\r\n                ) {\r\n\r\n                var dotNL = saturate( dot( geometry.normal, directLight.direction ) );\r\n                var irradiance = dotNL * directLight.color;\r\n\r\n                (*reflectedLight).directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\r\n            \r\n                (*reflectedLight).directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\r\n            }\r\n\r\n            @fragment\r\n            fn main(\r\n                ${basic.itemVary_value(uvItem,indexObj)}\r\n                ${basic.itemVary_value(normalItem,indexObj)}\r\n                ${basic.customVary_value(\"vViewPosition\",\"vec3<f32>\",indexObj)}\r\n            ) -> @location(0) vec4<f32> {\r\n                var baseColor:vec4<f32>;\r\n                ${basic.getColo_frag(shaderOptions.bindValues.get(\"texture\"),shaderOptions.bindValues.get(\"color\"))}\r\n\r\n                var diffuse = baseColor.xyz;\r\n                // var emissive = vec3<f32>(0.0,0.0,0.0);\r\n                // var specular = vec3<f32>(0.043,0.043,0.043);\r\n                // var shininess = 30.;\r\n                var opacity = 1.;\r\n                var specularStrength = 1.;\r\n\r\n                var diffuseColor = vec4<f32>( diffuse, opacity );\r\n                var reflectedLight:ReflectedLight;\r\n                reflectedLight.directDiffuse = vec3<f32>( 0.0 );\r\n                reflectedLight.directSpecular = vec3<f32>( 0.0 );\r\n                reflectedLight.indirectDiffuse = vec3<f32>( 0.0 );\r\n                reflectedLight.indirectSpecular = vec3<f32>( 0.0 );\r\n\r\n                var totalEmissiveRadiance = emissive;\r\n\r\n                var material:BlinnPhongMaterial;\r\n                material.diffuseColor = diffuse;\r\n                material.specularColor = specular;\r\n                material.specularShininess = shininess;\r\n                material.specularStrength = specularStrength;\r\n\r\n                var geometry:GeometricContext;\r\n\r\n                geometry.position = - vViewPosition;\r\n                geometry.normal = normal;\r\n                //geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\r\n                geometry.viewDir = normalize( vViewPosition );\r\n\r\n\r\n                var directionalLight:DirectionalLight;\r\n\r\n                directionalLight.direction = vec3<f32>(0.,1.,1.);\r\n                directionalLight.color = vec3<f32>(1.,1.,1.);\r\n\r\n                var directLight:IncidentLight;\r\n                directLight.color = directionalLight.color;\r\n                directLight.direction = directionalLight.direction;\r\n                directLight.visible = true;\r\n\r\n                //getDirectionalLightInfo( directionalLight, geometry, directLight );\r\n\r\n                RE_Direct_BlinnPhong( directLight, geometry, material, &reflectedLight );\r\n\r\n                var outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n\r\n                var finalColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n                return finalColor;\r\n            }\r\n        `;\r\n    }\r\n}","import { Material } from \"../materials/Material\";\r\n\r\nexport abstract class Shader{\r\n    protected _vertexShaderCode: string;\r\n    protected _fragmentShaderCode: string;\r\n    protected _material: Material;\r\n\r\n    constructor(material: Material){\r\n        this._material = material;\r\n    }\r\n\r\n    public recreate() {\r\n        this._createVertexShader();\r\n        this._createFragmentShader();\r\n    }\r\n\r\n    protected abstract _createVertexShader():void;\r\n\r\n    protected abstract _createFragmentShader():void;\r\n\r\n    public get vertexShaderCode() {\r\n        return this._vertexShaderCode;\r\n    }\r\n\r\n    public get fragmentShaderCode() {\r\n        return this._fragmentShaderCode;\r\n    }\r\n}","import { BindShaderItem, BindType, ShaderItem } from \"../core/Defines\";\r\n\r\nexport interface IndexObj {\r\n    index:number\r\n}\r\n\r\nexport function location_transform_vert(){\r\n    return `\r\n            @group(0) @binding(0) var<uniform> projectionMatrix : mat4x4<f32>;\r\n            @group(0) @binding(1) var<uniform> viewMatrix : mat4x4<f32>;\r\n                \r\n            @group(2) @binding(0) var<uniform> modelMatrix : mat4x4<f32>;\r\n            `;\r\n}\r\n\r\nexport function location_vert(item:ShaderItem){\r\n    if(item)\r\n        return `@location(${item.index}) ${item.name} : ${item.shaderItemType},`;\r\n    return \"\";\r\n} \r\n\r\nexport function itemVary_value(item:ShaderItem,index:IndexObj){\r\n    if(item){\r\n        return `@location(${index.index++}) ${item.name} : ${item.shaderItemType},`;\r\n    }\r\n    \r\n    return \"\";\r\n}\r\n\r\nexport function customVary_value(name:string,itemType:string,indexObj:IndexObj){\r\n    return `@location(${indexObj.index++}) ${name} : ${itemType},`;\r\n}\r\n\r\nexport function transform_vert(){\r\n    return `\r\n            var mvPosition = viewMatrix * modelMatrix * vec4<f32>(position, 1.0);\r\n            output.Position = projectionMatrix * mvPosition;\r\n            `;\r\n}\r\n\r\nexport function uv_vert(item:ShaderItem){\r\n    if(item)\r\n        return `output.uv = uv;`;\r\n    return \"\";\r\n}\r\n\r\nexport function bind_value_frag (item:BindShaderItem){\r\n    if(item)\r\n        return `@group(1) @binding(${item.index}) var${item.bindType === BindType.buffer?\"<uniform>\":\"\"} ${item.name} : ${item.shaderItemType};`;\r\n    return \"\";\r\n}\r\n\r\nexport function getColo_frag(textureItem:ShaderItem,colorItem:ShaderItem){\r\n    if(textureItem)\r\n        return `baseColor = textureSample(texture, colorSampler, uv);`;\r\n    else{\r\n        if(colorItem.shaderItemType === \"vec3<f32>\")\r\n            return `baseColor = vec4(color,1.0);`;\r\n        else\r\n            return `baseColor = color;`;\r\n    }\r\n}","import * as MathUtils from '../math/MathUtils';\r\n\r\nexport class Source {\r\n\r\n    public uuid = MathUtils.generateUUID();\r\n    public data:any;\r\n\r\n    public version = 0;\r\n\tconstructor( data:any = null ) {\r\n\r\n\t\tthis.data = data;\r\n\r\n\t\tthis.version = 0;\r\n\r\n\t}\r\n\r\n\tset needsUpdate( value:boolean ) {\r\n\r\n\t\tif ( value === true ) this.version ++;\r\n\r\n\t}\r\n\r\n}\r\n","import * as MathUtils from '../math/MathUtils';\r\nimport { Vector2 } from '../math/Vector2';\r\nimport { Matrix3 } from '../math/Matrix3';\r\nimport * as Constants from '../Constants';\r\nimport { Source } from './Source';\r\n\r\nconst t_nullCanvas = document.createElement(\"canvas\") as HTMLCanvasElement;\r\nt_nullCanvas.width = 1;\r\nt_nullCanvas.height = 1;\r\nconst t_ctx = t_nullCanvas.getContext(\"2d\");\r\nt_ctx.fillStyle = \"#ffffff\";\r\nt_ctx.fillRect(0, 0, t_nullCanvas.width, t_nullCanvas.height);\r\n\r\nconst t_nullImage = document.createElement(\"img\") as HTMLImageElement;\r\nt_nullImage.width = 1;\r\nt_nullImage.height = 1;\r\nt_nullImage.src = t_nullCanvas.toDataURL();\r\nexport class Texture {\r\n    static DEFAULT_IMAGE:HTMLImageElement = t_nullImage;\r\n    static DEFAULT_MAPPING = Constants.UVMapping;\r\n    static DEFAULT_ANISOTROPY = 1;\r\n\r\n    public uuid = MathUtils.generateUUID();\r\n\r\n    public name = '';\r\n\r\n    public source:Source;\r\n    public mipmaps:any = [];\r\n\r\n    public mapping:number;\r\n    public channel = 0;\r\n\r\n    public wrapS:number;\r\n    public wrapT:number;\r\n\r\n    public magFilter:number;\r\n    public minFilter:number;\r\n\r\n    public anisotropy:number;\r\n\r\n    public format:number;\r\n    public type:number;\r\n\r\n    public offset = new Vector2( 0, 0 );\r\n    public repeat = new Vector2( 1, 1 );\r\n    public center = new Vector2( 0, 0 );\r\n    public rotation = 0;\r\n\r\n    public matrixAutoUpdate = true;\r\n    public matrix = new Matrix3();\r\n\r\n    public generateMipmaps = true;\r\n    public premultiplyAlpha = false;\r\n    public flipY = true;\r\n    public unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\r\n\r\n    public colorSpace: string;\r\n    \r\n    public version = 0;\r\n\r\n\tpublic isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not\r\n\tpublic needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)\r\n\r\n\tconstructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, \r\n        wrapS = Constants.ClampToEdgeWrapping, wrapT = Constants.ClampToEdgeWrapping, \r\n        magFilter = Constants.LinearFilter, minFilter = Constants.LinearMipmapLinearFilter, \r\n        format = Constants.RGBAFormat, type = Constants.UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, \r\n        colorSpace = Constants.NoColorSpace ) {\r\n\r\n\t\tthis.uuid = MathUtils.generateUUID();\r\n\r\n\t\tthis.name = '';\r\n\r\n\t\tthis.source = new Source( image );\r\n\t\tthis.mipmaps = [];\r\n\r\n\t\tthis.mapping = mapping;\r\n\t\tthis.channel = 0;\r\n\r\n\t\tthis.wrapS = wrapS;\r\n\t\tthis.wrapT = wrapT;\r\n\r\n\t\tthis.magFilter = magFilter;\r\n\t\tthis.minFilter = minFilter;\r\n\r\n\t\tthis.anisotropy = anisotropy;\r\n\r\n\t\tthis.format = format;\r\n\t\tthis.type = type;\r\n\r\n\t\tthis.colorSpace = colorSpace;\r\n\t}\r\n\r\n\tget image() {\r\n\r\n\t\treturn this.source.data;\r\n\r\n\t}\r\n\r\n\tset image( value:any ) {\r\n\r\n\t\tthis.source.data = value;\r\n\r\n\t}\r\n\r\n\tupdateMatrix() {\r\n\r\n\t\tthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new Texture().copy( this );\r\n\r\n\t}\r\n\r\n\tcopy( source:Texture ) {\r\n\r\n\t\tthis.name = source.name;\r\n\r\n\t\tthis.source = source.source;\r\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\r\n\r\n\t\tthis.mapping = source.mapping;\r\n\t\tthis.channel = source.channel;\r\n\r\n\t\tthis.wrapS = source.wrapS;\r\n\t\tthis.wrapT = source.wrapT;\r\n\r\n\t\tthis.magFilter = source.magFilter;\r\n\t\tthis.minFilter = source.minFilter;\r\n\r\n\t\tthis.anisotropy = source.anisotropy;\r\n\r\n\t\tthis.format = source.format;\r\n\t\tthis.type = source.type;\r\n\r\n\t\tthis.offset.copy( source.offset );\r\n\t\tthis.repeat.copy( source.repeat );\r\n\t\tthis.center.copy( source.center );\r\n\t\tthis.rotation = source.rotation;\r\n\r\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\t\tthis.matrix.copy( source.matrix );\r\n\r\n\t\tthis.generateMipmaps = source.generateMipmaps;\r\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\r\n\t\tthis.flipY = source.flipY;\r\n\t\tthis.unpackAlignment = source.unpackAlignment;\r\n\t\tthis.colorSpace = source.colorSpace;\r\n\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\ttransformUv( uv:Vector2 ) {\r\n\r\n\t\tif ( this.mapping !== Constants.UVMapping ) return uv;\r\n\r\n\t\tuv.applyMatrix3( this.matrix );\r\n\r\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\r\n\r\n\t\t\tswitch ( this.wrapS ) {\r\n\r\n\t\t\t\tcase Constants.RepeatWrapping:\r\n\r\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase Constants.ClampToEdgeWrapping:\r\n\r\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase Constants.MirroredRepeatWrapping:\r\n\r\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\r\n\r\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\r\n\r\n\t\t\tswitch ( this.wrapT ) {\r\n\r\n\t\t\t\tcase Constants.RepeatWrapping:\r\n\r\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase Constants.ClampToEdgeWrapping:\r\n\r\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase Constants.MirroredRepeatWrapping:\r\n\r\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\r\n\r\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.flipY ) {\r\n\r\n\t\t\tuv.y = 1 - uv.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn uv;\r\n\r\n\t}\r\n\r\n\tset needsUpdate( value:boolean ) {\r\n\r\n\t\tif ( value === true ) {\r\n\r\n\t\t\tthis.version ++;\r\n\t\t\tthis.source.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport const NullTexture = new Texture();","import { Matrix4 } from \"../math/Matrix4\";\r\nimport { Vector3 } from \"../math/Vector3\";\r\n\r\nexport const IdentifyMatrix4 = new Matrix4();\r\n\r\nexport const Vector0 = new Vector3();","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export * as GPUConstances from \"./Constants\";\r\n\r\nexport * as Environment from \"./core/Defines\";\r\n\r\nexport { WebGPURenderer } from \"./renderers/WebGPURenderer\";\r\n\r\nexport { BufferAttribute } from \"./core/BufferAttribute\";\r\nexport { BufferGeometry } from \"./core/BufferGeometry\";\r\n\r\nexport { BoxGeometry } from \"./geometries/BoxGeometry\";\r\nexport { PlaneGeometry } from \"./geometries/PlaneGeometry\";\r\nexport { SphereGeometry } from \"./geometries/SphereGeometry\";\r\n\r\nexport { MeshBasicMaterial } from \"./materials/MeshBasicMaterial\";\r\nexport { MeshPhongMaterial } from \"./materials/MeshPhongMaterial\";\r\n\r\nexport { Mesh } from \"./objects/Mesh\";\r\n\r\nexport { Scene } from \"./core/Scene\";\r\n\r\nexport { Color } from \"./math/Color\";\r\nexport { Euler } from \"./math/Euler\";\r\nexport { Matrix3 } from \"./math/Matrix3\";\r\nexport { Matrix4 } from \"./math/Matrix4\";\r\nexport { Quaternion } from \"./math/Quaternion\";\r\nexport { Vector2 } from \"./math/Vector2\";\r\nexport { Vector3 } from \"./math/Vector3\";\r\n\r\nexport { PerspectiveCamera } from \"./cameras/PerspectiveCamera\";\r\nexport { OrthographicCamera } from './cameras/OrthographicCamera'\r\n\r\nexport { OrbitControls } from \"./controls/OrbitControls\";\r\n\r\nexport { FileLoader } from \"./loaders/FileLoader\";\r\nexport { ImageLoader } from \"./loaders/ImageLoader\";\r\nexport { TextureLoader } from \"./loaders/TextureLoader\";\r\n\r\nexport * as ConstantsValues from \"./utils/TMPValues\";"],"names":[],"sourceRoot":""}